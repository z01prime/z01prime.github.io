<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>三蓝一棕：傅里叶变换</title>
      <link href="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
      <url>/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="三蓝一棕：傅里叶变换"><a href="#三蓝一棕：傅里叶变换" class="headerlink" title="三蓝一棕：傅里叶变换"></a>三蓝一棕：傅里叶变换</h3><p>记录<a href="https://www.youtube.com/watch?v=spUNpyF58BY">But what is the Fourier Transform?  A visual introduction.</a>的学习。主要是对傅里叶变换的理解：<br>图形上看是旋转</p><p>物理上看是重心与频率的关系</p><p>数学上看是复平面、欧拉公式和无限积分。</p><p>应用上有去噪、图片处理和降噪耳机等。</p><h4 id="核心定义：从“时域”到“频域”的翻译"><a href="#核心定义：从“时域”到“频域”的翻译" class="headerlink" title="核心定义：从“时域”到“频域”的翻译"></a>核心定义：从“时域”到“频域”的翻译</h4><p>傅里叶变换的核心功能是<strong>拆解</strong>。简单来说，给你一瓶紫色的颜料（叠加后的波形），它能精确地告诉你这瓶紫色是由 40% 的红色、30% 的蓝色和 30% 的白色混合而成的。从音乐的角度理解，交响乐由各种乐器（小提琴、大提琴、长笛）同时演奏，它们的声波叠加在一起。傅里叶变换有绝对音感，能从波形中分辨出里面包含了哪些频率的纯音。</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116102155181.png" alt="image-20260116102155181" style="zoom:67%;"></p><p>在这张图片中，</p><p><strong>时域（上方的黄色波）：</strong> 告诉我们信号在<strong>每一秒钟</strong>的强度是多少。</p><p><strong>频域（下方的彩色波）：</strong> 告诉我们信号里包含了哪些<strong>频率</strong>，以及每个频率的<strong>强度</strong>（振幅）是多少。</p><p>抽象一些的说法就是如果把复杂的波形看作是一个向量，那么那些简单的纯正弦波（彩色波）就是一组坐标轴。傅里叶变换的本质，是计算这个复杂信号在每一个特定频率的“坐标轴”上有多少分量。这就好比把一个颜色（如紫色）分解成一定比例的红色和蓝色。</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116103917653.png" alt="image-20260116103917653"></p><p>这张图展示了如何利用旋转和重心来提取频率。顶部的波形（Intensity）可以想象成一根长长的、有质量的金属丝，把这根“金属丝”按照某个频率（缠绕频率）绕在一个圆柱坐标系上。结果就是每一个时间点 $t$ 的强度值，被转化成了圆圈上距离圆心的距离。从原点到这个图形的每一个点能够形成一个向量，在上图中，顶部的图像纵坐标随时间的变化就可以变成上图中左下角图像向量的旋转，而在下图中， 每过两秒这个向量就转过一整圈。</p><p>为什么要把波形绕起来？核心在于观察这个图形的<strong>重心（Center of Mass）</strong>：</p><ul><li><p>当缠绕频率与波形频率“对不上”时：</p><p>波形会杂乱无章地均匀分布在圆心的四周。此时，这个“金属丝团”的重心非常接近坐标原点 $(0,0)$。</p><p>此时可以对缠绕频率做一定的调整，比如：</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116105209550.png" alt="image-20260116105209550" style="zoom:50%;"></p><p>这个时候图形变得非常整齐、对称，像一朵漂亮的花。这说明<strong>缠绕频率</strong>和<strong>信号频率</strong>之间存在某种<strong>整数倍关系</strong>。虽然它们有节奏上的共鸣，但并不是“同频呼吸”。虽然图形很美，但它是中心对称的。这意味着左边的花瓣和右边的抵消了，上面的和下面的抵消了。重心依然在原点附近。</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116105303814.png" alt="image-20260116105303814"></p><p>这里有两个比较关键的频率，直角坐标系中，一秒三个拍子(上下震荡三次)，而在旋转的图像中，向量每秒钟转半圈(0.50 cycle/second)，可以让他转的快些：</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116113259202.png" alt="image-20260116113259202" style="zoom:50%;"></p><p>也可以让他转的慢些：</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116113326851.png" alt="image-20260116113326851" style="zoom:50%;"></p></li></ul><ul><li><p>当缠绕频率刚好“等于”波形的真实频率时：</p><p>当继续变换频率，直到缠绕频率 = 信号频率（3 次/秒）时，所有的波峰都会堆在该圆形的右侧，波谷都会堆在左侧。</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116113728737.png" alt="image-20260116113728737"></p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116113746097.png" alt="image-20260116113746097" style="zoom:50%;"></p><p>这张图片中白色虚线圆圈表示的是信号的“零偏离”基准线由于我们的原始信号是一个上下波动的正弦波，所以实线会根据波峰和波谷在虚线内外跳动。虚线圆的作用是衬托出实线图案的“不对称性”。实线相对于虚线圆偏移得越厉害，说明在这个频率下的信号分量越强。</p><p>物理含义：此时两者完全同步。</p><p>重心：图形不再是中心对称的，而是整个“甩”向了一边。重心会瞬间跳离原点。</p><p>关于重心的解释：将这个图像中的图形想象成一根铁丝，那么这个图形会有一个重心，上面的花瓣图的重心就在接近原点的位置。</p><p>可以用图像来表述质心关于频率的横坐标</p></li></ul><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116114807593.png" alt="image-20260116114807593"></p><p>显然当频率很小的时候，他的质心横坐标就相对较大：</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116114849790.png" alt="image-20260116114849790" style="zoom:50%;"></p><p>继续旋转：</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116115004546.png" alt="image-20260116115004546"></p><p>而当和节拍一致的时候（每秒三拍），会出现一个尖峰，因为图像大部分都在右边：</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116115404168.png" alt="image-20260116115404168"></p><p>继续增加又会回到0附近：</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116115507421.png" alt="image-20260116115507421"></p><p>当然，如果上下移动这个波形，那么在当频率很小的时候，他的质心横坐标就会产生变化。比如这张图：</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116115822208.png" alt="image-20260116115822208"></p><p>那么0附近就不会出现波峰：</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116115901942.png" alt="image-20260116115901942" style="zoom:50%;"></p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116115929504.png" alt="image-20260116115929504"></p><p>这样这个图像就会在3处出现一个尖峰。当然这样要考虑负值会很麻烦，只要知道0频率附近只和图像移动有关。</p><p>想要分解频率，那么就要关注3处的凸起。傅里叶变换其实就是一个重心测量机器。它把时间信号缠绕在圆圈上，然后在频率轴上记录下哪些频率能让这个圆圈失去平衡。那个让圆圈最不平衡的频率，就是信号原本的频率。</p><p>*这张图只是一个“近傅里叶变换”，和真正的还有一些区别。</p><p>这只是单个波形的情况，如果是多个波形叠加也是可以通过这样的操作分离出来：</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116145612596.png" alt="image-20260116145612596"></p><p>这张图左边展示了2hz和3hz的波形叠加后得到的情况，右边是做了“近傅里叶变换”后的图像，右边波峰的高度确实直接由原始波形的振幅决定。虽然 $2\text{ Hz}$ 和 $3\text{ Hz}$ 的波峰看起来差不多高，但在现实情况中，它们的高度取决于原始分量的振幅。</p><p>关于右边的图，个人理解是横轴 (频率)代表正在使用的探测频率。纵轴 (波峰高度)代表在这个特定频率下，信号所表现出的属性强度。这个属性代表了相关性，或者说是一种同步程度与能量密度，如果在 $3\text{ Hz}$ 处有一个巨大的波峰，这意味着原始信号中有很大一部分能量是在以每秒 3 次的频率振动的。</p><h4 id="傅里叶变换的应用"><a href="#傅里叶变换的应用" class="headerlink" title="傅里叶变换的应用"></a>傅里叶变换的应用</h4><p>比如一段音频，有很高频的噪声，傅里叶变换可以找到高频的尖啸部分，并且将他去掉。</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116151149014.png" alt="image-20260116151149014"></p><p>然后在对其做逆傅里叶变换，还原回原先的信号，这样就能够有效的去噪。</p><p>这个“单一尖峰”是为了演示方便而设定的理想化噪声，真实情况下，可能不是一个波峰而是好几个小波峰，甚至铺满整个高频区域的一段连续起伏。在去噪时，工程师不是只删掉一个点，而是会用“低通滤波器”把某一频率之后的整个区域全部“抹平”。</p><p>应用：</p><p>1.可以用在音频去噪。去掉背景音中的蜂鸣器发出的尖啸（滤掉高频），去掉空调、机箱等发出的声音（滤掉低频）。</p><p>2.并且由于每一种声音对应的频率都是固定的，可以用于降噪耳机的噪声算法识别。</p><p>3.图片美化。傅里叶变换处理的是随时间变化的波，而图片虽然是静止的像素点，也可以看作是一种“波”，只不过它是空间上的“频率”。沿着图片的一行像素走过去，像素的亮度（从黑到白）在不断变化，这个就是一种波。比如磨皮与锐化，皮肤上的瑕疵、皱纹、毛孔都属于高频细节。磨皮本质上就是一个低通滤波器：它保留了皮肤红润的底色（低频），但过滤掉了代表瑕疵的剧烈波动（高频）。这就是为什么磨皮太厉害照片会显得没细节，因为把所有的轮廓细节（高频）全滤掉了。</p><p>4.图片压缩(JPEG)人的眼睛对大面积的颜色（低频）很敏感，但对极细微的纹理变化（高频）不那么敏感。压缩算法会通过类似傅里叶变换的手段（如 DCT 变换），把图片中不重要的高频属性直接扔掉，从而极大地减小文件体积。</p><p>*学到这里的时候，我想既然峰值对应能量大小，那么这些频率的积分应该就是某一个常数，查了一下是叫做帕塞瓦尔定理：一个信号在时域里的总能量，严格等于它在“频域”里所有频率分量能量的积分（总和）。</p><p>*所以换一种角度来看，傅里叶变换的核心假设就是宇宙万物都可以由不同频率的圆周运动（正余弦波）叠加而成。这也是为什么FEDformer做时序列预测往往效果都还可以，如果一个时序列有重复规律，说明它内部存在稳定的频率成分。傅里叶变换就就可以把时序中那些藏得很深的、不同节奏的循环给找出来。这样就能够给模型提供一个全局视野，因为它直接把这种每隔几个时间步重复一次的规律浓缩成了一个频率分量（波峰）。而在时域中，信息是分散在数千个时间点里的；但在频域中，最关键的信息（规律）通常集中在少数几个频率点上。对这几个关键频率做 Attention，相当于把注意力集中在了信号的重要特征上，自动过滤掉了那些随机波动的杂质，这非常符合注意力机制的设计理念。</p><h4 id="真正的傅里叶变换"><a href="#真正的傅里叶变换" class="headerlink" title="真正的傅里叶变换"></a>真正的傅里叶变换</h4><p>之前讨论的一直是“近傅里叶变换”，因为只记录了重心在 x 轴（左右）移动。但在现实中，当频率对上时，重心可能会偏向任何方向——上方、下方、或者斜着。如果只看 $x$ 轴，你可能会漏掉信息。</p><p>如果用复平面来表示的话会方便很多。复平面是描述旋转的高效工具，因为在复数的世界里，“乘法”的本质就是“旋转”。</p><p>在复平面上，一个复数 $a + bi$ 可以完美地代表二维平面上的一个<strong>点</strong>。</p><ul><li><strong>实部 ($a$)</strong>：代表重心的左右偏移（也就是你之前看到的 $x$ 坐标）。</li><li><strong>虚部 ($bi$)</strong>：代表重心的上下偏移（$y$ 坐标）。</li><li><strong>模（距离）</strong>：代表重心偏离原点的总距离。这就是你之前理解的<strong>“属性强度”或“振幅”</strong>。</li><li><strong>辐角（角度）</strong>：代表重心偏向了哪个方向。这就是<strong>“相位”</strong>。</li></ul><p>例如欧拉公式($e^{ix} = \cos x + i\sin x$)，$e^{ni}$ 能表示成在圆周上“走” $n$ 个单位，</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116162352684.png" alt="image-20260116162352684" style="zoom:50%;"></p><p>想要描述一个每秒钟转一圈的旋转，那么就可以用$e^{2\pi it}$表示，其中t表示经过的时间。</p><p>如果在圆周上走了 $\pi$（约 3.14）个单位，从右边出发走半圆，则会刚好落在左边的 <strong>$-1$</strong> 位置。这就是著名的 $e^{i\pi} + 1 = 0$。</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116163335773.png" alt="image-20260116163335773" style="zoom:50%;"></p><p>通常会在公式中引入 $f$（或者常说的 $\xi$），是为了把“走的距离”和“时间”关联起来，当把公式写成 $e^{i 2\pi f t}$ 时，这个$f$作为频率，起到了调节速度的作用。</p><p>*其实$2\pi f$就是和物理中的角速度的相关，$\theta = \omega t$，$\omega$ 是角速度，代表每秒转过的弧度。</p><div class="table-container"><table><thead><tr><th><strong>物理概念</strong></th><th><strong>物理符号</strong></th><th><strong>傅里叶/欧拉公式中的符号</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>频率</strong></td><td>$f$</td><td>$f$ (或 $\xi$)</td><td>每秒钟旋转的圈数（缠绕频率）</td></tr><tr><td><strong>周期</strong></td><td>$T$</td><td>$1/f$</td><td>转完一圈需要的时间</td></tr><tr><td><strong>角速度</strong></td><td>$\omega$</td><td>$2\pi f$</td><td>每秒钟转过的“角度”（弧度）</td></tr><tr><td><strong>相位/角度</strong></td><td>$\phi$</td><td>$2\pi f t$</td><td>在 $t$ 时刻，点落在了圆周的哪个位置</td></tr></tbody></table></div><p>在物理中，我们经常用 $\cos(\omega t)$ 或 $\sin(\omega t)$ 来描述波动。但欧拉公式把这两者合二为一了：</p><script type="math/tex; mode=display">e^{i \omega t} = \text{(水平方向的波动)} + i \times \text{(垂直方向的波动)}</script><p>这种表达方式让“波动”变成了一个在空间中不断旋转的向量。</p><p>而在傅里叶变换的语境下，向量都是按照顺时针的方式旋转的，所以一般来说，这个公式要加一个负号： $e^{-i 2\pi f t}$ ，并且由于这个公式表示的是一个“标准圆”，而在实际的波形中，或者采用刚才可以弯曲的金属丝的类比，需要乘上一个$g(t)$来表示不同形状的金属丝。</p><p>乘以 $g(t)$的作用：</p><ul><li><strong>距离变化</strong>：圆周上的点到原点的距离不再固定为 $1$，而是变成了 $g(t)$ 在那一时刻的大小。</li><li><strong>结果</strong>：原本完美的圆被“拉伸”或“挤压”了。当 $g(t)$ 的数值大时，点离原点远；当 $g(t)$ 小时，点离原点近。</li><li>这就形成了那些像花瓣、像心形、或者很乱的的缠绕图案。</li></ul><p>数学一点的理解，可以把这个乘法看作是给旋转运动“加权”：</p><ul><li>$e^{-2\pi ift}$ 提供了<strong>旋转的角度</strong>（节奏）。</li><li>$g(t)$ 提供了<strong>旋转的幅度</strong>（内容）。</li><li>组合起来，$g(t)e^{-2\pi ift}$ 就代表了：在时间 $t$，原始信号在旋转圆盘上所处的真实的二维位置。</li></ul><p>由于一开始是为了表示这个图案的质心，那么可以用积分来表示。</p><p>如果你把 $g(t)e^{-2\pi ift}$​ 看作是在圆盘上画出的那条复杂的曲线，那么积分的操作本质上就是在计算这条曲线的总和。想找一个物体的重心，最简单的方法就是把物体上所有点的坐标加起来，然后除以总长度（或者总质量）。</p><ul><li>相加的动作在数学里，在处理连续变化的曲线时，就是积分。</li><li>公式：$\int_{t_1}^{t_2} g(t)e^{-2\pi ift} dt$， 这个积分，实际上是在把这段时间内金属丝在复平面上经过的所有位置点全部累加在一起。</li></ul><p>这个公式能够解释那张3hz处突然起来的波峰。</p><p>当频率不对时：金属丝在圆盘上均匀地绕来绕去，正向的点和负向的点互相抵消了，积分（累加）的结果接近于 0。</p><p>当频率对上时：所有的点都堆在了圆的一侧（像那个心形图），大家劲儿往一处使，积分（累加）的结果就会变成一个很大的数值。</p><p>所以这个就是最后的公式：</p><script type="math/tex; mode=display">\hat{g}(f) = \int_{t_1}^{t_2} g(t) e^{-i 2\pi f t} dt</script><p>其实就是在说为了在频率 $f$ 处得到一个值，把信号 $g(t)$ 按照频率 $f$ 顺时针（负号）卷在圆盘上，然后算出这段时间内所有点的总和（积分）。</p><p>当然关于刚才那一张质心在x轴的位置随频率变化的图像，也可以根据这个公式画上其在虚部的变化。</p><p><img src="/2026/01/16/%E4%B8%89%E8%93%9D%E4%B8%80%E6%A3%95%EF%BC%9A%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20260116171758100.png" alt="image-20260116171758100"></p><p>简单来说，实部（Real part）记录的是重心在 $x$ 轴上的位置，而虚部（Imaginary part）记录的是重心在 $y$ 轴上的位置。</p><p>虚部的意义在物理上的解释就是相位。如果只看实部，那么只能知道这个频率的成分有多强，但你不知道它的起跑时刻。</p><ul><li><strong>例子</strong>：想象两个频率一模一样的声波，但一个比另一个晚了半秒钟响起。</li><li><strong>结果</strong>：它们的实部波形可能看起来完全一样，但它们的<strong>虚部会截然不同</strong>。</li><li><strong>结论</strong>：虚部和实部共同决定了重心的<strong>偏转角度</strong>。这个角度精确地告诉了我们：这个频率的波是从哪一个瞬间开始震动的。</li></ul><p><strong>注：在视频中，为了理解重心，作者用的是有限长的金属丝。但真正的傅里叶变换定义中，积分区间其实是从 $-\infty$ 到 $+\infty$。完整的公式如下：</strong></p><script type="math/tex; mode=display">\hat{g}(f) = \int_{-\infty}^{\infty} g(t) e^{-i 2\pi f t} dt</script>]]></content>
      
      
      <categories>
          
          <category> 时间序列预测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于雅思</title>
      <link href="/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/"/>
      <url>/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<p>这几个月发生了很多事情导致博客好久没更新，主要是一直在被雅思折磨。前几天终于考过了，记录一下我学雅思的过程。</p><p>时间线</p><p>从原本计划的学两个月之后9月去考一直拖到10月份中旬去考，我选的是机考，考了第一次成绩是5 8.5 6 6:</p><p><img src="/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/image-20251221093714798.png" alt="image-20251221093714798"></p><p>考试一开始的时候很迷，听力直接考崩了（5.0相当于40到题目错了20多道），因为申请的国家大多都是支持单科重考的，所以后来想着单科重考一次试试，然后考的成绩还是挺意外，居然能上7，最终成绩：</p><p><img src="/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/image-20251221093413450.png" alt="image-20251221093413450"></p><p>英语高考100多分四级525六级没过，所以这个分数差不多就是我目前的英语极限了，短期内应该不会想着再去刷分了。纯学英语有点折磨希望这是最后一次考试吧。</p><h4 id="书本网课-前期准备"><a href="#书本网课-前期准备" class="headerlink" title="书本网课/前期准备"></a>书本网课/前期准备</h4><p>练习题主要是剑雅全套，当然如果机考可以选择直接在<a href="https://ieltscat.xdf.cn/">新东方雅思</a>上练，来不及的话可以就做最新的四五套，如果有钱可以买<a href="https://www.igopx.cn/index">躺着学</a>的SVIP，里面有一个邪修题库，这里面基本都是考试真题的还原题：</p><p><img src="/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/image-20251221102052372.png" alt="image-20251221102052372"></p><p>不是很建议买，感觉真的是在摸奖，我听力阅读全部刷完都没有遇到过一个（同校有人确实是8月份碰到了一篇阅读），而且吃相是真的难看，之前只要89块一个月就能刷题库现在要好几百，客服说的话也没几句是真的，说什么“剑雅是真题就是误人子弟”，然后各种制造焦虑忽悠你买线下课……最小丑的是自己服务器被打了还说自己服务器在更新，头一次见流量这么大的网站在白天流量高峰停机维护。有能力的可以去咸鱼上买个几个小时的SVIP账号，然后抓紧时间把网站资源（比如听力音频，题目文本什么的）下到本地，然后再自己本地练，像我这样的手不干净的熟练工可以做到6小时把所有资源爬下来，买账号的成本基本上就十来块。其实剑雅一套练下来基本足够了，唯一的缺点就是剑雅的题型比较固定，考试的时候运气不好特别是听力会遇上阴间题，比如让你一口气填个三个单词啥的，或者是part4出现连连看的题，可以适当刷刷躺着学，但不建议把他当做真正的参考题目，命中率全靠运气，目前已知我听力两次阅读一次都没中，其他人是三次阅读中了一次。</p><p><img src="/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/image-20251221103711089.png" alt="image-20251221103711089" style="zoom:67%;"></p><p>剑雅做的差不多了可以看看一个小红书上的博主，叫ZYZ Reading Walks，这个老师会整理分享机考的真题，运气好可以在考试的时候碰到，当然这也是看运气，其实听力和阅读基本上剑雅的得分是多少考出来就是多少，状态好可能会比剑雅的平均分高个一分半分，我这次就碰到ZYZ Reading Walks给出的机考原题了，但是我考前没有看，也是靠自己做的做到8.5分（剑雅平均分是7.5）。</p><p><img src="/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/image-20251221105001297.png" alt="image-20251221105001297"></p><p>参考资料主要是学为贵（刘洪波）的书。</p><p>听力就是王陆语料库，其他什么奇奇怪怪的书都不建议，像什么听力考点词之类的基本没用。</p><p>阅读是刘洪波的雅思阅读真经5，雅思词汇真经，雅思阅读总纲，雅思阅读538考点词。真经5是按题型分类的阅读题，出题很规范，风格和雅思真题一模一样，还有一部分文章是目前在考阅读题库中的文章，不过占比较少，好像我知道的就一篇叫pearl的。词汇真经是分类高频单词，总纲教你技巧，538考点词是极高频词汇。</p><p>写作是刘洪波的雅思写作真经总纲，把除范文以外的几章节看完就差不多了。</p><p>口语淘宝搜“雅思过过过”，这家店的题库就是从考官手里拿到的题本摸过来的，不可能出现在题库范围外的题目。关注杨帅老师的微信公众号，他有一个每日背三句，按他的要求来练习。</p><p>网课除了写作都挺重要的，听力看何琼，阅读看刘洪波，口语看杨帅。</p><p>写作看杜世明，不过最重要的还是自己根据写作真经总纲积累词汇。</p><h4 id="听力："><a href="#听力：" class="headerlink" title="听力："></a>听力：</h4><p>（1）听王陆语料库，3/4/5/11章，书上说要连着听中间不能暂停，并且这四章准确率超过95%才有6.5左右的水平，但是我感觉考到6.5-7分没有这么高要求，特别是第五章按照我敲英文的手速基本上不太可能听一个写一个（其实3 4章也很勉强跟的上更不用说还要求倍速播放）。我是把音频下载下来自己编程把每一个的单词都从音频里面分割开来听一个然后等我写出来再播放下一个单词：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydub <span class="keyword">import</span> AudioSegment</span><br><span class="line"><span class="keyword">from</span> pydub.silence <span class="keyword">import</span> split_on_silence</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_audio_to_sentences</span>(<span class="params"></span></span><br><span class="line"><span class="params">    audio_path,</span></span><br><span class="line"><span class="params">    output_folder,</span></span><br><span class="line"><span class="params">    min_silence_len=<span class="number">1400</span>,</span></span><br><span class="line"><span class="params">    silence_thresh_offset=<span class="number">14</span>,</span></span><br><span class="line"><span class="params">    keep_silence=<span class="number">500</span>,</span></span><br><span class="line"><span class="params">    gap_duration=<span class="number">0</span>,</span></span><br><span class="line"><span class="params">    prefix=<span class="string">&quot;sentence_&quot;</span>,</span></span><br><span class="line"><span class="params">    <span class="built_in">format</span>=<span class="string">&quot;mp3&quot;</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将一段音频根据静音切分为多个片段并保存。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    - audio_path: 输入音频路径</span></span><br><span class="line"><span class="string">    - output_folder: 输出片段保存的文件夹</span></span><br><span class="line"><span class="string">    - min_silence_len: 最小静音长度（ms），超过此长度视为分割点</span></span><br><span class="line"><span class="string">    - silence_thresh_offset: 相对于音频平均音量 dBFS 的阈值（如 -14）</span></span><br><span class="line"><span class="string">    - keep_silence: 每段前后保留静音的毫秒数</span></span><br><span class="line"><span class="string">    - gap_duration: 每段结尾额外添加的静音时长（ms）</span></span><br><span class="line"><span class="string">    - prefix: 输出文件前缀（如 sentence_）</span></span><br><span class="line"><span class="string">    - format: 导出音频格式（如 mp3）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    audio = AudioSegment.from_file(audio_path)</span><br><span class="line">    silence_thresh = audio.dBFS - silence_thresh_offset</span><br><span class="line">    gap = AudioSegment.silent(duration=gap_duration)</span><br><span class="line"></span><br><span class="line">    chunks = split_on_silence(</span><br><span class="line">        audio,</span><br><span class="line">        min_silence_len=min_silence_len,</span><br><span class="line">        silence_thresh=silence_thresh,</span><br><span class="line">        keep_silence=keep_silence</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    os.makedirs(output_folder, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, chunk <span class="keyword">in</span> <span class="built_in">enumerate</span>(chunks, <span class="number">1</span>):</span><br><span class="line">        final_chunk = chunk + gap</span><br><span class="line">        out_file = os.path.join(output_folder, <span class="string">f&quot;<span class="subst">&#123;prefix&#125;</span><span class="subst">&#123;i:03&#125;</span>.<span class="subst">&#123;<span class="built_in">format</span>&#125;</span>&quot;</span>)</span><br><span class="line">        final_chunk.export(out_file, <span class="built_in">format</span>=<span class="built_in">format</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;导出：<span class="subst">&#123;out_file&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><del>python最有用的一集</del></p><p>这样整体准确率到95%左右就行。</p><p>关于听写，可以在知乎搜王陆语料库excel表，有个叫江元裔的博主做了一个每一章的excel，可以用他的来拼写，核对：</p><p><img src="/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/image-20251221101236038.png" alt="image-20251221101236038"></p><p>（2）只要完整听写过一遍之后就差不多可以开始做真题了，我做了剑雅17-20，每做完4套就复盘一次，并且精听，精听我用的是叫做每日英语听力这个软件（<a href="https://dict.eudic.net/ting">官网</a>），上面有很多的听力资源，搜剑雅听力音频就可以了</p><p><img src="/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/1766229543498-a5a335dc-f909-4beb-b059-62574017fd9d-1766287927802-9.png" alt="1766229543498-a5a335dc-f909-4beb-b059-62574017fd9d-1766287927802-9"></p><p>里面的VIP可以白嫖，有一个30天打卡活动，打卡满30天就把钱退还给你。</p><p>主要还是靠做和多听，语料库准确率只是参考因为如果听力的时候阅读速度不快的话是反应不过来题目在说什么的，所以每天练习真题是最重要的。</p><h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h4><p>没什么好讲的，看刘洪波阅读真经课看完之后每天一套剑雅保持手感就行。词汇是看他的词汇真经以及538考点词，一整本过一遍就差不多了。</p><p>关于词汇量的问题，我认为只要你能够知道每句话的大致意思就不用去花时间背单词了，如果是每个单词意思都懂但就是看不懂句子，那么是语法结构不熟悉的问题，比如一些句子里面介词一多就会很复杂，可以让ChatGPT分析句子结构，不建议用国内的，chat毕竟训练数据里面英文居多，理解会更深一些。</p><h4 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h4><p>看刘洪波的写作真经总纲，里面会把好的词汇分类给出，记忆的时候可以把这一类词汇让ChatGPT编一段话：</p><p><img src="/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/image-20251221105630839.png" alt="image-20251221105630839" style="zoom:50%;"></p><p><img src="/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/Users/10562/Desktop/博客/image-20251221105654431.png" alt="image-20251221105654431" style="zoom:50%;"></p><p>然后自己录音说一遍或者一些专业的AI文本转语音软件做一段音频，我用的是<a href="https://elevenlabs.io/text-to-speech">eleven labs</a>。每天晚上睡前听30min，听一个月基本上词汇全都记住并且考试的时候直接可以默写。</p><h4 id="口语"><a href="#口语" class="headerlink" title="口语"></a>口语</h4><p>其实口语分数我自己也很迷惑为什么我能有6分…我看了不少的5.5案例，发了份邮件给BC问问他们我具体的小分是怎么样的目前也没回我，我能想到的唯一解释就是评分标准中的发音和语法准确性，光看内容完全没有到6分的理由，还有一个可能是我全程嬉皮笑脸随便说的缘故，因为淘宝上口语外教跟我说全程保持微笑和自信并且回答的时候说一些积极地语言会很加分，我part3基本没怎么发挥，每个问题回答的都是两三句话，但是给出的都是很正面的回答。</p><p>也不排除是考官的原因，可能那个黑姐比较善良加上那天她有点累想着我差不多6分就给了6，就考了一次也不知道是不是真的和网上说的一样黑人女考官给的分高，不过雅思官方明确指出了他们会抽查考官和考生的对话，并且定期给考官做测试，那么我认为大多数考官评分应该是客观的。</p><p>如果张嘴困难，没法微笑同时很紧张的话可以去淘宝上找口语陪练，一节课50块，我练了6节课就够了。</p><p>口音和语调会很扣分，我身边不少人都是口音太严重了，并且说话的语调听上去像是背的导致分数一直卡在5.5，口音问题可以b站看<a href="https://www.bilibili.com/video/BV1n54y1B7bE/?spm_id_from=333.337.search-card.all.click">【初阶篇】一个神仙级别的美式英语发音教程，不刷十遍都亏了</a>这个视频跟着练，语调问题建议看杨帅公众号的每日背三句，对着镜子练习。</p><p>关于口语的练习，part1和part2是很好拿分的，因为题库是固定的，特别是part2，我真正背题库就花了一周，时间紧的可以考虑先准备part2，基本上part2会了part1也自然能说出来，part2看上去50道题挺多的其实就准备几个小故事就行，主要脑洞要大些，临场的反应要快，看到题目要想着怎么迁移到自己的故事里，练习可以用ChatGPT，给他所有的题目让他分类，我是让他分了4类(博物馆，流星雨照片，传统故事，大雁)，每一类的题目都是用一个很详细的小故事串起来的，比如流星雨照片，原先的构思是这个照片是用框裱起来的，那么可以用在“两个朋友发生争执（Describe an occasion when two of your friends disagreed about something. ）”这个part2主题里面，可以说两个好朋友因为弄坏了你的流星雨照片，一个说是另一个朋友的问题，另一个则说it was all his fault：</p><p><img src="/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/image-20251221110754779.png" alt="image-20251221110754779" style="zoom: 67%;"></p><p>每个问题都录音说3遍以上，3天就能记住所有的题目。</p><p>part1除了背题库以外，还有一个就是加入自己真实的经历，背景，除了准备题库以外，最好准备一下自己学习的经历，因为学习或是工作是必考的，有些考官会问的很细，可以做一个思维导图：</p><p><img src="/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/image-20251221111243445.png" alt="image-20251221111243445" style="zoom:67%;"></p><p>每个问题都加入自己的想法和经历：</p><p><img src="/2025/12/22/%E5%85%B3%E4%BA%8E%E9%9B%85%E6%80%9D/image-20251221111341868.png" alt="image-20251221111341868" style="zoom:67%;"></p><p>但是在考试的时候适当加一些停顿，填充词啥的，不然考官会觉得你是在背题。其实关于背题，雅思官方在评分标准中没有说背题就会打低分，但是明确指出背题会影响你的发音这一评分，因为语调变化不对，所以其实如果真的演的像考官不会关心你的经历是不是真的，说的是不是背的。</p><p>我真正有效的学习时间是两个多月，当时在学校附近租的房子里面当了一个暑假的哥布林，从7月份练到9月份，然后又因为听力分低又去重考听力，一直不想学拖到12月份后集中复习了一个星期每天半天以上最后考过了。其实考试最重要的是心态，第一次考听力当时很紧张没发挥好，其实基本上剑雅多少分就是多少分打底。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021SCCPC</title>
      <link href="/2025/04/21/2021SCCPC/"/>
      <url>/2025/04/21/2021SCCPC/</url>
      
        <content type="html"><![CDATA[<p>题面：</p><div class="row">    <embed src="2021sichan-en.pdf" width="100%" height="550" type="application/pdf"></div><p>24年的好像打完了……从cf上随便找了一个打着玩。</p><p>四川的依然还是那么简单，单挑差两题ak（cf上的没有C I J题）。</p><h3 id="签到-简单题"><a href="#签到-简单题" class="headerlink" title="签到/简单题"></a>签到/简单题</h3><p>A题就是求方程<code>x+y=k</code>的解的个数。直接枚举就行。</p><p>M题在说有n个旅客在位置0同时出发赶飞机，飞机的位置是x。每个人都是按一定的速度匀速运动。初始时，飞机预定在时刻p0起飞。有m 个广播，第i个广播表示在某个时刻（可能早于p0时刻）告诉所有旅客飞机延误到了pi， 保证ti和pi是递增的。每个旅客在每个时刻都会根据当前自己的位置、当前自己的速度和当前预定的起飞时间来决定行动：如果赶得上飞机就继续移动，否则就原地停留，求总共有多少人可以顺利登机。问最终有多少个旅客赶得上飞机。先预处理姜所有的广播时间和p0比较，如果早于p0就改成p0，然后计算其总共延长的时间，找到最大的延长时间，如果这段时间按该乘客的移动速度可以到达机场就说明这个乘客能登机，遍历一遍就可以统计出有多少人能顺利起飞。这题是简单题里面通过率最低的一个，我感觉还是题目实在是太绕了导致的（我至少读了20min的题面还没理解wa了一次）。怎么会有这么反人类的题目背景还说是True Story……</p><p>H题是告诉你日语中一些动词的罗马音变换形式。写个循环找后缀去匹配。</p><p>K题是构造排列，求一个最大化相邻数字之间的差等于k的、长度为n的排列。贪心去构造，每相邻k的数字放在一块，可以反证出不同块之间绝对互相干扰并且此时是最优解，所以最后将这些块随便按什么顺序组合都行，全部输出就可以过了。</p><p>D题，两个玩家博弈玩石头剪刀布，每个玩家的卡牌个数总数相同，计分数为赢一局加一分，输一局减一分，出拳一样分数不增不减，双方明牌，Alice先手，希望最小化得分，Bob后手，希望最大化得分，求两者均最优策略下的得分是多少。那么显然后手占优，最后的答案一定是所有可能结果中最大得分的那一个，范围给的小，直接枚举排列就行。</p><p>B题在说n个人（0索引开始的编号）围成环形吃火锅，每个人都有喜欢的火锅材料，从第0个人开始一共循环进行m次操作，分两种情况，如果当前火锅中有这个编号的人喜欢吃的材料那么这个人就会把这个东西从火锅里面捞出来吃，并且好感度++,否则就把材料放火锅里面，这个人的好感度不变。求这m轮操作后所有人好感度的总和。也不难只要先计算一次2n个操作，因为2n个操作中，喜欢第i个材料的人的总数一定是偶数，这样就能在内部处理好所有的情况，然后数有几个2n的倍数，之后再加上剩余的好感度就可以了。</p><h3 id="L-Spicy-Restaurant"><a href="#L-Spicy-Restaurant" class="headerlink" title="L - Spicy Restaurant"></a><a href="https://codeforces.com/gym/103117/problem/L"><font style="color:rgb(0, 0, 204);">L - Spicy Restaurant</font></a></h3><p>形式化来说就是给了一个无向图，每个顶点有一个属性$ W_i $，边权是1，$ Q $个询问，第i个询问给定顶点$ p_i<br> $和阈值$ a_i $，问距离点$ p_i $最近的$ W_i \le a_i $的$ i $距离$ p_i $有多远。$ 1 \le W_i \le 100 $。 </p><p>vp的时候MLE了一次。</p><p>显然是最短路相关的题，离线查询后暴力每一个顶点的最短路，这种写法肯定要超时，因为最劣是n*最短路复杂度。注意到$ W_i $范围很小，所以可以考先预处理出每一个阈值对应的最短路，将所有的小于这个阈值的顶点与一个超级源点链接，从源点开始跑最短路，跑100种情况就行，但是这样用dij跑的话会有问题，空间和时间都会超。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dij爆空间爆时间</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SP</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="type">int</span> to;</span><br><span class="line"><span class="type">int</span> w;</span><br><span class="line"><span class="built_in">Edge</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">to = a;</span><br><span class="line">w = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n, s;</span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; edge;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dist;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SP</span>(<span class="type">int</span> _n, <span class="type">int</span> _s) : <span class="built_in">n</span>(_n), <span class="built_in">s</span>(_s), <span class="built_in">edge</span>(_n + <span class="number">1</span>), <span class="built_in">dist</span>(_n + <span class="number">1</span>), <span class="built_in">st</span>(_n + <span class="number">1</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">fill</span>(<span class="built_in">all</span>(dist), <span class="number">1e18</span>);</span><br><span class="line">dist[s] = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;&gt;&gt; heap;</span><br><span class="line">heap.<span class="built_in">emplace</span>(<span class="number">0</span>, s);</span><br><span class="line"><span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> ver = heap.<span class="built_in">top</span>().second;</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : edge[ver]) &#123;</span><br><span class="line"><span class="type">int</span> j = i.to;</span><br><span class="line"><span class="keyword">if</span> (dist[j] &gt; dist[ver] + i.w) &#123;</span><br><span class="line">dist[j] = dist[ver] + i.w;</span><br><span class="line">heap.<span class="built_in">emplace</span>(dist[j], j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; w[i];</span><br><span class="line"><span class="function">SP <span class="title">sp1</span><span class="params">(n,<span class="number">0ll</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,v,u;i&lt;m;++i)&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">sp1.edge[u].<span class="built_in">push_back</span>(&#123;v,<span class="number">1</span>&#125;);</span><br><span class="line">sp1.edge[v].<span class="built_in">push_back</span>(&#123;u,<span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;SP&gt; hot;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)&#123;</span><br><span class="line"><span class="function">SP <span class="title">sp</span><span class="params">(n,<span class="number">0ll</span>)</span></span>;</span><br><span class="line">sp.edge = sp1.edge;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(w[j] &lt;= i) sp.edge[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;j + <span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">sp.<span class="built_in">dij</span>();</span><br><span class="line">hot.<span class="built_in">push_back</span>(sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="type">int</span> p,a;</span><br><span class="line">cin&gt;&gt;p&gt;&gt;a;</span><br><span class="line">a--;</span><br><span class="line">cout&lt;&lt;(hot[a].dist[p] == <span class="number">1e18</span> ? <span class="number">-1</span> :hot[a].dist[p])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意到边权是1，所以可以直接跑bfs求最短路。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; w[i];</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edge</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, u, v; i &lt; m; ++i) &#123;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">edge[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">edge[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(<span class="number">101</span>);</span><br><span class="line"><span class="keyword">auto</span> bfs = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (w[i - <span class="number">1</span>] &lt;= x) q.<span class="built_in">push</span>(i),d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : edge[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (d[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">dist[x] = d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="type">int</span> a,p;</span><br><span class="line">cin&gt;&gt;p&gt;&gt;a;</span><br><span class="line">cout&lt;&lt;dist[a][p]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Don’t-Really-Like-How-The-Story-Ends"><a href="#E-Don’t-Really-Like-How-The-Story-Ends" class="headerlink" title="E - Don’t Really Like How The Story Ends"></a><a href="https://codeforces.com/gym/103117/problem/E"><font style="color:rgb(0, 0, 204);">E - Don’t Really Like How The Story Ends</font></a></h3><p>给定一张无向图，问最少添加多少条边，可以使得1,2,··· ,n是 这张图的一个合法DFS序列。</p><p>考虑什么时候不得不加边：如果在我们dfs的过程中走到了i，并且不可能在下一步走到i+1，那么我们必须添加一条边使得下一步能走到i+1，就是在说当前的DFS栈中，最深的一个有未访问邻居的 点与i+1不相邻。</p><p>vp的时候的代码，写的很乱很丑，乱搞一遍过的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edge</span>(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,u,v;i&lt;m;++i)&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">edge[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">edge[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">st</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">b</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i) <span class="built_in">sort</span>(<span class="built_in">all</span>(edge[i]));</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u)-&gt;<span class="type">void</span>&#123;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;u&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(u &gt; n) <span class="keyword">return</span>;</span><br><span class="line">st[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : edge[u]) b[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">si</span>(edge[u]);++i)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[u][i];</span><br><span class="line"><span class="keyword">if</span>(st[v])<span class="keyword">continue</span>;</span><br><span class="line">ok = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//p++;</span></span><br><span class="line"><span class="keyword">if</span>(v != p)&#123;</span><br><span class="line">p++;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;u&lt;&lt;endl;</span></span><br><span class="line">ans++;</span><br><span class="line"><span class="built_in">dfs</span>(p - <span class="number">1</span>);</span><br><span class="line">--i;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;u&lt;&lt;endl;</span></span><br><span class="line">p++;</span><br><span class="line"><span class="built_in">dfs</span>(p - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!ok &amp;&amp; p &lt;= n &amp;&amp; !b[p])&#123;</span><br><span class="line">p++;</span><br><span class="line">ans++;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;u&lt;&lt;&#x27; &#x27;&lt;&lt;p&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//cerr&lt;&lt;p&lt;&lt;endl;</span></span><br><span class="line"><span class="built_in">dfs</span>(p - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四川 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024CCPC山东邀请赛</title>
      <link href="/2024/12/31/2024CCPC%E5%B1%B1%E4%B8%9C%E9%82%80%E8%AF%B7%E8%B5%9B/"/>
      <url>/2024/12/31/2024CCPC%E5%B1%B1%E4%B8%9C%E9%82%80%E8%AF%B7%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>题面：</p><div class="row">    <embed src="2024shandong-zh.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="I-Left-Shifting"><a href="#I-Left-Shifting" class="headerlink" title="I - Left Shifting"></a><a href="https://codeforces.com/gym/105385/problem/I">I - Left Shifting</a></h3><p>签到题，从左往右检查字符串中有没有相邻两个一样的位置，注意有可能一开始就已经是首尾相同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">front</span>() == s.<span class="built_in">back</span>()) <span class="keyword">return</span> cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl,<span class="built_in">void</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;<span class="built_in">si</span>(s);++i)</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[i<span class="number">-1</span>]) <span class="keyword">return</span> cout&lt;&lt;i&lt;&lt;endl,<span class="built_in">void</span>();</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-Printer"><a href="#A-Printer" class="headerlink" title="A - Printer"></a><a href="https://codeforces.com/gym/105385/problem/A">A - Printer</a></h3><p>一道很明显的二分题，二分最后的时间，固定时间根据能产生多少的试题来左移或者右移mid，注意直接统计能产生的试题个数的时候可能会爆longlong，可以写int128或者check的时候如果大于k就直接返回true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="comment">// 自定义int128输出，这道题不需要</span></span><br><span class="line"><span class="comment">// std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, i128 n) &#123;</span></span><br><span class="line"><span class="comment">// std::string s;</span></span><br><span class="line"><span class="comment">// while (n) &#123;</span></span><br><span class="line"><span class="comment">// s += &#x27;0&#x27; + n % 10;</span></span><br><span class="line"><span class="comment">// n /= 10;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// std::reverse(s.begin(), s.end());</span></span><br><span class="line"><span class="comment">// return os &lt;&lt; s;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第 i 台打印机将重复进行以下工作计划：持续工作</span></span><br><span class="line"><span class="comment">ti × li 秒，然后停机 wi 秒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">t</span><span class="params">(n)</span>, <span class="title">l</span><span class="params">(n)</span>, <span class="title">w</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; t[i] &gt;&gt; l[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, r = <span class="number">2e18</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">        i128 cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> temp = x / (t[i] * l[i] + w[i]);</span><br><span class="line">            <span class="type">int</span> rest = x - temp * (t[i] * l[i] + w[i]);</span><br><span class="line">            <span class="keyword">if</span> (rest &gt; t[i]*l[i]) &#123;</span><br><span class="line">                cnt +=  (temp + <span class="number">1</span>) * l[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt += temp * l[i] + rest / t[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + r) &gt;&gt; <span class="number">1ll</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; left + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-Divide-the-Sequence"><a href="#F-Divide-the-Sequence" class="headerlink" title="F - Divide the Sequence"></a><a href="https://codeforces.com/gym/105385/problem/F">F - Divide the Sequence</a></h3><p>观察式子$ \sum i\times S_i $可以理解为越靠后的区间累积的越多，设最后m段的元素总和为$ p_m $，则变形一下原式可以得到$ \sum p_i $, 所以实际上就是按顺序从大到小选后缀和累加就行，注意第一个位置的后缀和（即所有数的和）不能参与排序因为是只有一个区间必须要一开始就先选。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,ans = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n+<span class="number">1</span>,<span class="number">0ll</span>)</span>,<span class="title">suf</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        suf[i] += suf[i+<span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="built_in">sort</span>(suf.<span class="built_in">begin</span>() + <span class="number">1</span>,suf.<span class="built_in">end</span>() - <span class="number">1</span>,<span class="built_in">greater</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        ans += suf[i];</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&quot; \n&quot;</span>[i==n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K-Matrix"><a href="#K-Matrix" class="headerlink" title="K - Matrix"></a><a href="https://codeforces.com/gym/105385/problem/K">K - Matrix</a></h3><p>因为提供了2n个数，对于一个矩阵来说很难不想到是一行一列或者是一斜行，构造的时候可以主对角线从1到n依次填进去，然后左上角弄一个2*2的矩阵，这个矩阵的四个元素都不一样，其他每一行每一列除主对角线上的都是一样的数，这样就能保证除了左上角那个矩阵是对角四个元素都不一样其他子矩阵的右上和左下一定是一样的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如长这样的</span></span><br><span class="line"><span class="comment">// 1 5 7 8</span></span><br><span class="line"><span class="comment">// 6 2 7 8</span></span><br><span class="line"><span class="comment">// 7 7 3 8</span></span><br><span class="line"><span class="comment">// 8 8 8 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i][i] = i;</span><br><span class="line">    a[<span class="number">2</span>][<span class="number">1</span>] = n + <span class="number">1</span>, a[<span class="number">1</span>][<span class="number">2</span>] = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            a[i][j] = n + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            a[j][i] = n + i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; \n&quot;</span>[j == n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Colorful-Segments-2"><a href="#C-Colorful-Segments-2" class="headerlink" title="C - Colorful Segments 2"></a><a href="https://codeforces.com/gym/105385/problem/C">C - Colorful Segments 2</a></h3><p>因为和顺序无关，先想到排序。</p><p>按左端点从大到小排序，枚举每条线段然后用小根堆贪心，找前面有几个是包含当前这条线段的。因为已经按照左端点排序了所以如果前面有右端点在这条线段的左端点之前一定是不干扰的，如果右端点在这条线段左端点之后那么一定是被干扰的，并且因为是排了序所以直接弹出不干扰这条线的右端点对后面的线段也不会有影响，最后留在堆里的一定是和这条线段有重叠的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="function">vector&lt;PII&gt; <span class="title">line</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        cin&gt;&gt;line[i].fi&gt;&gt;line[i].se;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(line));</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; r;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!r.<span class="built_in">empty</span>() &amp;&amp; r.<span class="built_in">top</span>()&lt;line[i].fi)&#123;</span><br><span class="line">            r.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        (ans *= (k - <span class="built_in">si</span>(r)))%=mod;</span><br><span class="line">        r.<span class="built_in">push</span>(line[i].se);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="J-Colorful-Spanning-Tree"><a href="#J-Colorful-Spanning-Tree" class="headerlink" title="J - Colorful Spanning Tree"></a><a href="https://codeforces.com/gym/105385/problem/J">J - Colorful Spanning Tree</a></h3><p>可以这样理解相同颜色的点：选出k-1（k为相同颜色点的个数）个找和这个颜色组合权值最小的一个点链接，全部连这一个点，这样就算最小的是自身也没有问题，就相当于那一个点是附带了这k-1个点的点集，对所有的点集跑一遍最小生成树即可保证得到的生成树是最小的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i) cin&gt;&gt;a[i];</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(n);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 输入，找最小的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> minn = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>,t;j&lt;n;++j)&#123;</span><br><span class="line">            cin&gt;&gt;t;</span><br><span class="line">            mat[i].<span class="built_in">push_back</span>(t);</span><br><span class="line">            minn = <span class="built_in">min</span>(minn,t);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += minn*(a[i]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连边</span></span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>,3&gt;&gt; edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;n;++j)&#123;</span><br><span class="line">            edge.<span class="built_in">push_back</span>(&#123;mat[i][j],i,j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// kruskal</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">par</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i) par[i] = i;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span> x)&gt; find = [&amp;](<span class="type">int</span> x)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> par[x] == x ? par[x] : par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">int</span>()&gt; krus = [&amp;]()-&gt;<span class="type">int</span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(edge));</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [w,u,v] : edge)&#123;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(u),pb = <span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(pa == pb) <span class="keyword">continue</span>;</span><br><span class="line">            par[pa] = pb;</span><br><span class="line">            ret += w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ans += <span class="built_in">krus</span>();</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-Hero-of-the-Kingdom"><a href="#D-Hero-of-the-Kingdom" class="headerlink" title="D - Hero of the Kingdom"></a><a href="https://codeforces.com/gym/105385/problem/D">D - Hero of the Kingdom</a></h3><p>看范围T是500，其他都是1e9的范围，那么如果每轮能在根号范围内处理那么就是一个比较合理的处理，所以要考虑在暴力枚举的时候优化一些不必要重复的操作。注意到如果当前是买x袋面粉，那么如果想要买x+1袋面粉则可能需要跑好几轮，所以如果能计算出购买x袋面粉的轮次一定是一种优化，考虑极端情况是进行k种交易，那么假设买一次物品最少是2s，则有$ (1+2+…+k)\times2 \le t $，得出k大概是根号级别的，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p, a, b;</span><br><span class="line"><span class="type">int</span> q, c, d;</span><br><span class="line"><span class="type">int</span> m, t;</span><br><span class="line">cin &gt;&gt; p &gt;&gt; a &gt;&gt; b;</span><br><span class="line">cin &gt;&gt; q &gt;&gt; c &gt;&gt; d;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; t;</span><br><span class="line"><span class="type">int</span> rest = t;</span><br><span class="line"><span class="comment">// 特判一次都不行的时候</span></span><br><span class="line">    <span class="keyword">if</span>(m&lt;p) <span class="keyword">return</span> cout&lt;&lt;m&lt;&lt;endl,<span class="built_in">void</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">int</span> x = m / p;</span><br><span class="line"><span class="type">int</span> epo = ((x + <span class="number">1</span>) * p - m - <span class="number">1</span>) / ((q - p) * x) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 处理买m/p袋一共会跑几轮</span></span><br><span class="line">        epo = <span class="built_in">min</span>(rest / (a*x + b + c*x + d), epo);</span><br><span class="line">m += epo*x*(q-p);</span><br><span class="line">rest -= epo*(a*x + b + c*x + d);</span><br><span class="line">        <span class="comment">// 一次都买不了就先结束</span></span><br><span class="line"><span class="keyword">if</span>(rest &lt; (a*(x+<span class="number">1</span>) + b + c*(x + <span class="number">1</span>) + d))<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//特判最后一轮</span></span><br><span class="line"><span class="type">int</span> maxn = (rest - b - d)/(a+c);</span><br><span class="line">m += <span class="built_in">max</span>(maxn*(q-p),<span class="number">0ll</span>);</span><br><span class="line">cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 山东 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024HNCPC</title>
      <link href="/2024/11/22/2024HNCPC/"/>
      <url>/2024/11/22/2024HNCPC/</url>
      
        <content type="html"><![CDATA[<p>题面：</p><div class="row">    <embed src="HNCPC2024-final.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="C-easy-math"><a href="#C-easy-math" class="headerlink" title="C - easy math"></a><a href="https://codeforces.com/gym/105423/problem/C">C - easy math</a></h3><p>给出一个长度为n整数数组a。数组a中的每一个整数$ a_i $都是2的幂。求满足$ \prod_{i=1}^{n} a_i \leq 2024^b $的最小整数b。</p><p>注意到每个数都是2的幂所以可以直接对每个元素取对数让乘法变加法，最后直接用换底公式搞一下2024的b次方把b提出来就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        a[i] = (<span class="type">int</span>)<span class="built_in">log2</span>(a[i]);</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> base = <span class="built_in">log</span>(<span class="number">2024</span>),p = <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> logg = p/base;</span><br><span class="line">    <span class="type">int</span> ans = (ceil)(sum * logg);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C要处理高精度所以要想想对数，贴个python，可以直接用python写这样就不用动脑子了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>()</span><br><span class="line">a = <span class="built_in">str</span>.split()</span><br><span class="line">t = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    t *= <span class="built_in">int</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(math.ceil(math.log(t,<span class="number">2024</span>)))</span><br></pre></td></tr></table></figure><p>xcpc要是真敢出高精度估计选手能让出题人飞起来</p><h3 id="I-数据检索系统"><a href="#I-数据检索系统" class="headerlink" title="I - 数据检索系统"></a><a href="https://codeforces.com/gym/105423/problem/I">I - 数据检索系统</a></h3><p>按题意模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;N&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k,m,q;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        <span class="type">int</span> temp = t % n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=k;++j)&#123;</span><br><span class="line">            st[temp] = <span class="number">1</span>;</span><br><span class="line">            temp *= t;</span><br><span class="line">            temp %= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(int i = 0;i&lt;n;++i) cerr&lt;&lt;st[i]&lt;&lt;&quot; \n&quot;[i == n-1];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;q;++i)&#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        <span class="type">int</span> temp = t % n;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=k;++j)&#123;</span><br><span class="line">            <span class="comment">//st[temp] = 1;</span></span><br><span class="line">            ok &amp;= st[temp];</span><br><span class="line">            temp *= t;</span><br><span class="line">            temp %= n;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ok&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-拼接串"><a href="#E-拼接串" class="headerlink" title="E - 拼接串"></a><a href="https://codeforces.com/gym/105423/problem/E">E - 拼接串</a></h3><p>注意到每个数都只能出现一次，这就容易想到每种状态都是独立的互不干扰的且$ a_i $很小只有18种，每种状态对应的都是选与不选，就可以往状态压缩方向去想了。</p><p>那么首先就是怎么不重不漏的找出状态。先定义dp[s]表示有没有区间是s这个状态的并记录下集合s中的数字个数，因为18种，n范围由是1e6，18*1e6又是符合时限的，考虑在枚举的过程中每个位置操作大约20次的实现，因为要求是不能重复的所以可以想到直接每个位置往后枚举一遍，每次在枚举的时候更新状态。</p><p>比如样例一，第一个位置，2，然后继续往后遍历到出现重复数字为止也就是第三位为止出现了两个1，那么更新$ dp[(0…11)_2]=max(1,dp[(0…11)_2],2) $表示s = 000…11（即包含1和2的这个集合）被更新一次。</p><p>通过这样的遍历就能尽可能的得到每个子区间的最大集合。</p><p>题目要求是两个区间相加，那么可以将问题转化为枚举一个集合，找它的补集以及补集的子集中最多的那个，那么问题就转化为了如何找补集以及补集的子集中最多的那个。</p><p>可以考虑区间从小到大合并，比如只有一个数字的集合肯定是这个集合和只有0个数字的集合取max，有两个数字的集合一定是自己本身和只有1个数字集合取max，这样就大概能在$ O(18*2^{18}) $的复杂度预处理出每一个集合以及它的子集中最多的那个。</p><p>然后就是枚举每一个集合和它的补集以及补集的子集中最多的那个相加取最大就是答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> M = (<span class="number">1ll</span>&lt;&lt;<span class="number">18</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; a[i];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(M)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="type">int</span> bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(j &lt; n &amp;&amp; !st.<span class="built_in">count</span>(a[j]))&#123;</span><br><span class="line">st.<span class="built_in">insert</span>(a[j]);</span><br><span class="line">bit += (<span class="number">1ll</span>&lt;&lt;(a[j]<span class="number">-1</span>));</span><br><span class="line">j++;</span><br><span class="line">dp[bit] = <span class="built_in">max</span>(dp[bit],<span class="built_in">si</span>(st));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int i = 0;i&lt;16;++i) cerr&lt;&lt;dp[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//cerr&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;M;++i)&#123;</span><br><span class="line"><span class="type">int</span> tot = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;=<span class="number">18</span>;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(tot &amp; (<span class="number">1ll</span>&lt;&lt;j))&#123;</span><br><span class="line"><span class="type">int</span> k = tot - (<span class="number">1ll</span>&lt;&lt;j);</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[k],dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int i = 0;i&lt;16;++i) cerr&lt;&lt;dp[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//cerr&lt;&lt;endl;</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;M;++i)&#123;</span><br><span class="line"><span class="type">int</span> s = i;</span><br><span class="line"><span class="type">int</span> antis = ((<span class="number">1ll</span>&lt;&lt;<span class="number">18</span>) - <span class="number">1</span>)^s;</span><br><span class="line">ans = <span class="built_in">max</span>(dp[s] + dp[antis],ans);</span><br><span class="line"><span class="comment">//cerr&lt;&lt;ans&lt;&lt;&#x27; &#x27;&lt;&lt;s&lt;&lt;&#x27;:&#x27;&lt;&lt;&#x27; &#x27;&lt;&lt;dp[s]&lt;&lt;&#x27; &#x27;&lt;&lt;antis&lt;&lt;&#x27;:&#x27;&lt;&lt;&#x27; &#x27;&lt;&lt;dp[antis]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K-渡劫"><a href="#K-渡劫" class="headerlink" title="K - 渡劫"></a><a href="https://codeforces.com/gym/105423/problem/K">K - 渡劫</a></h3><p>vp的时候没想到分层图当时只是随口提了一句：我觉得好像可以每条边额外加一条为0的边但是不知道怎么处理。然后就直接牢了。知道这东西还是很简单的。</p><p>先简化条件，不考虑法宝，假设初始传送在i号岛屿，最终在j号岛屿上，那么所需要的能量是dist[i-&gt;j] + a[j]，考虑建一个超级源点从源点反向跑每一个点，这样就能转化为单源最短路问题，一遍dij之后再对所有的dist取一个max就能得到至少要的能量。</p><p>然后有一次免费的机会，这种带条件的最短路就应该往分层图上去想，比如这道板题：<a href="https://www.luogu.com.cn/problem/P4568">P4568[JLOI2011] 飞行路线</a>。</p><p>建图的时候，把第二层表示为用掉一次免费的机会，比如在从u走到v的时候用掉了法宝，就可以表示为从第一层的u连向第二层的v，边权为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">8</span></span><br><span class="line"><span class="number">27</span> <span class="number">27</span> <span class="number">9</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/22/QXosRi78HkOgPjS.png" alt></p><p>跑一遍dij就没了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SP</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="type">int</span> to&#123;&#125;;</span><br><span class="line"><span class="type">int</span> w&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Edge</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">to = a;</span><br><span class="line">w = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n&#123;&#125;, s&#123;&#125;;</span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; edge;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dist;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SP</span>(<span class="type">int</span> _n, <span class="type">int</span> _s): <span class="built_in">n</span>(_n), <span class="built_in">s</span>(_s), <span class="built_in">edge</span>(_n + <span class="number">1</span>), <span class="built_in">dist</span>(_n + <span class="number">1</span>), <span class="built_in">st</span>(_n + <span class="number">1</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">fill</span>(<span class="built_in">all</span>(dist), <span class="number">4e18</span>);</span><br><span class="line">dist[s] = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;&gt;&gt; heap;</span><br><span class="line">heap.<span class="built_in">emplace</span>(<span class="number">0</span>, s);</span><br><span class="line"><span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> ver = heap.<span class="built_in">top</span>().second;</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">st[ver] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : edge[ver]) &#123;</span><br><span class="line"><span class="type">int</span> j = i.to;</span><br><span class="line"><span class="keyword">if</span> (dist[j] &gt; dist[ver] + i.w) &#123;</span><br><span class="line">dist[j] = dist[ver] + i.w;</span><br><span class="line">heap.<span class="built_in">emplace</span>(dist[j], j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="function">SP <span class="title">dij</span><span class="params">(n * <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, u, v, w; i &lt; m; ++i) &#123;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (j) dij.edge[u + (j - <span class="number">1</span>) * n].<span class="built_in">emplace_back</span>(v + j * n, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (j) dij.edge[v + (j - <span class="number">1</span>) * n].<span class="built_in">emplace_back</span>(u + j * n, <span class="number">0</span>);</span><br><span class="line">dij.edge[u + j * n].<span class="built_in">emplace_back</span>(v + j * n, w);</span><br><span class="line">dij.edge[v + j * n].<span class="built_in">emplace_back</span>(u + j * n, w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, w; i &lt;= n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; w;</span><br><span class="line">dij.edge[<span class="number">0</span>].<span class="built_in">emplace_back</span>(i, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自己在自己这个岛上渡劫，不连接的话那么对于ans的求法会出问题，</span></span><br><span class="line"><span class="comment">//因为下面这个ans的写法强制要求一定要用掉一次法宝，即不能在自己这个岛上渡劫</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dij.edge[i].<span class="built_in">emplace_back</span>(i + n, <span class="number">0</span>);</span><br><span class="line">dij.<span class="built_in">dijkstra</span>();</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = <span class="built_in">max</span>(dij.dist[i + n], ans);</span><br><span class="line"><span class="comment">//for (int i = 1; i &lt;= n; ++i) cerr &lt;&lt; dij.dist[i + n] &lt;&lt; &quot; \n&quot;[i == n];</span></span><br><span class="line"><span class="comment">//for (int i = 1; i &lt;= n; ++i) cerr &lt;&lt; dij.dist[i] &lt;&lt; &quot; \n&quot;[i == n];</span></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是这个像下面这样的实现需要考虑在自己这个岛上渡劫的情况，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">10</span> <span class="number">5</span> <span class="number">2</span> <span class="number">7</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p>那么dist的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一层dist[<span class="number">1</span><span class="number">-5</span>]:<span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line">第二层dist[<span class="number">1</span><span class="number">-5</span>]:<span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>发现dist[3]在用了法宝花费还变多了，原因在于我在统计答案的时候必须要用一次移动而没有考虑在自己岛上直接渡劫的情况。所以对于样例一的图应该还要再加上连向自己的边。</p><p><img src="https://s2.loli.net/2024/11/22/ven5fNa89xHMJqm.webp" alt></p><p>当然直接把ans改为<code>ans = max(min(dij.dist[i + n],dij.dist[i]), ans);</code>也可以。</p><p>复杂度大概是$ O(2nlog2m) $。不知道这开个2.5s的时限是在暗示什么……分层图不熟还往双log的算法方向想了半天。</p><p>可以把分层图的操作用数组存下来用一种类似于dp的记忆化存储状态。</p><p><img src="https://s2.loli.net/2024/11/22/6iv5A8krjM3fCTZ.webp" alt></p><p>注意到这张图在连向第二层的时候是有向边，也就是说在这一步转移的时候是有顺序的，符合dp的原则，可以考虑把这一步用dp的思想来转移。</p><p>定义dist[i][j]表示是第i个点，<code>j == 0</code>的时候是没用过，<code>j == 1</code>的时候是用过法宝了</p><p>从i号点走到j号点，对于这一张图有三种情况：<br>1.没用过走到没用过的点-&gt;dist[j][0] = dist[i][0] + w</p><p>2.没用过走到用过的点,即这次用了法宝-&gt;dist[j][1] = dist[i][0] + 0</p><p>3.用过走到用过的点 -&gt; dist[j][1] = dist[i][1] + w</p><p>注意第二种情况只有不是0号源点的时候是存在的对应到图上就是因为0号点没有连向第二层图的边。</p><p>其他就是正常的dij贪心。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SP</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="type">int</span> to&#123;&#125;;</span><br><span class="line"><span class="type">int</span> w&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Edge</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">to = a;</span><br><span class="line">w = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; PIII;</span><br><span class="line"><span class="type">int</span> n&#123;&#125;, s&#123;&#125;;</span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; edge;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; dist;</span><br><span class="line">vector&lt;array&lt;<span class="type">bool</span>, 2&gt;&gt; st;</span><br><span class="line"><span class="built_in">SP</span>(<span class="type">int</span> _n, <span class="type">int</span> _s): <span class="built_in">n</span>(_n), <span class="built_in">s</span>(_s), <span class="built_in">edge</span>(_n + <span class="number">1</span>), <span class="built_in">dist</span>(_n + <span class="number">1</span>, array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;), <span class="built_in">st</span>(_n + <span class="number">1</span>,array&lt;<span class="type">bool</span>, <span class="number">2</span>&gt; &#123;<span class="literal">false</span>,<span class="literal">false</span>&#125;) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> temp = <span class="number">4e18</span>;</span><br><span class="line"><span class="built_in">fill</span>(<span class="built_in">all</span>(dist), array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; &#123;temp, temp&#125;);</span><br><span class="line">dist[s][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;&gt;&gt; heap;</span><br><span class="line">heap.<span class="built_in">emplace</span>(<span class="number">0</span>, s, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> [fi, ver, kind] = heap.<span class="built_in">top</span>();</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (st[ver][kind]) <span class="keyword">continue</span>;</span><br><span class="line">st[ver][kind] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : edge[ver]) &#123;</span><br><span class="line"><span class="type">int</span> j = i.to;</span><br><span class="line"><span class="keyword">if</span> (kind == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (dist[j][<span class="number">0</span>] &gt; dist[ver][<span class="number">0</span>] + i.w) &#123;</span><br><span class="line">dist[j][<span class="number">0</span>] = dist[ver][<span class="number">0</span>] + i.w;</span><br><span class="line">heap.<span class="built_in">emplace</span>(dist[j][<span class="number">0</span>], j, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ver != <span class="number">0</span> &amp;&amp; dist[j][<span class="number">1</span>] &gt; dist[ver][<span class="number">0</span>]) &#123;</span><br><span class="line">dist[j][<span class="number">1</span>] = dist[ver][<span class="number">0</span>];</span><br><span class="line">heap.<span class="built_in">emplace</span>(dist[j][<span class="number">1</span>], j, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dist[j][<span class="number">1</span>] &gt; dist[ver][<span class="number">1</span>] + i.w) &#123;</span><br><span class="line">dist[j][<span class="number">1</span>] = dist[ver][<span class="number">1</span>] + i.w;</span><br><span class="line">heap.<span class="built_in">emplace</span>(dist[j][<span class="number">1</span>], j, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="function">SP <span class="title">dij</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, u, v, w; i &lt; m; ++i) &#123;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">dij.edge[u].<span class="built_in">emplace_back</span>(v, w);</span><br><span class="line">dij.edge[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, w; i &lt;= n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; w;</span><br><span class="line">dij.edge[<span class="number">0</span>].<span class="built_in">emplace_back</span>(i, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dij.<span class="built_in">dijkstra</span>();</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = <span class="built_in">max</span>(<span class="built_in">min</span>(dij.dist[i][<span class="number">0</span>], dij.dist[i][<span class="number">1</span>]), ans);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-贪吃蛇"><a href="#A-贪吃蛇" class="headerlink" title="A - 贪吃蛇"></a><a href="https://codeforces.com/gym/105423/problem/A">A - 贪吃蛇</a></h3><p>感觉A题还比其他后面的题要简单些不知道为什么过的人这么少</p><p>首先注意到这个n是很小的，允许做一些像是枚举线段这样很暴力的处理。</p><p>因为可以旋转坐标系，那么贪心的想，以零点到任意一个点作为x轴方向就能尽可能多的吃到金币。</p><p>这两点就允许了做一个$ O(n^2) $的枚举方向线段。</p><p>通过枚举就得到了一个方向线段，注意到和一般的不一样的是这个蛇可以在两个分量上移动任意的距离，这说明分成两种情况，一种是和这个线段夹角成[0°,90°]以内的，另一种是和这个线段夹角成[-90°，0°]以内的，这两种分开讨论只要满足以这条线段为初始的方向在[0°,90°]（或[-90°，0°]）的点，他们构成的线段都有机会是蛇的移动路线，吃的多那就是贪吃蛇的移动路径最长。</p><p>所以就可以想到建图，用方向来连边，如果两个点都在[0°,90°]（或[-90°，0°]）的范围内并且构成的有向线段的方向是和初始线段的方向夹角小于[0°,90°]（或[-90°，0°]）那么就是允许这个点连向另一个点，这样就就能不重不漏的枚举每一种情况。</p><p>判断方向可以用向量的点乘和叉乘，如果向量a和b点乘和叉乘都是大于0的那么说明a和b的夹角小于90°并且b位于a的逆时针方向，如果点乘大于0叉乘小于0说明b位于a的顺时针方向。</p><p>样例给的还有点良心注意如果如果金币在原点就有的话（样例一）还要对这个特殊点进行处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">vector&lt;PII&gt; p;</span><br><span class="line">p.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line"><span class="comment">//for(int i = 1;i&lt;=n;++i) cin&gt;&gt;p[i].fi&gt;&gt;p[i].se;</span></span><br><span class="line"><span class="type">bool</span> f = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,x,y;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)&#123;</span><br><span class="line">n--;</span><br><span class="line">i--;</span><br><span class="line">f = <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">p.<span class="built_in">push_back</span>(&#123;x,y&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> dot = [&amp;](<span class="type">const</span> PII &amp;a, <span class="type">const</span> PII &amp;b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.fi * b.fi + a.se * b.se;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> cross = [&amp;](<span class="type">const</span> PII &amp;a, <span class="type">const</span> PII &amp;b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.fi * b.se - a.se * b.fi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ve = [&amp;](PII a,PII b)&#123;</span><br><span class="line"><span class="keyword">return</span> PII&#123;a.fi - b.fi,a.se - b.se&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> isok = [&amp;](PII st,PII a,PII b,<span class="type">int</span> clockwise)&#123;</span><br><span class="line"><span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">ok &amp;= (<span class="built_in">dot</span>(st,a) &gt;= <span class="number">0</span>) &amp;&amp; (<span class="built_in">cross</span>(st,a) * clockwise &gt;= <span class="number">0</span>);</span><br><span class="line">ok &amp;= (<span class="built_in">dot</span>(st,b) &gt;= <span class="number">0</span>) &amp;&amp; (<span class="built_in">cross</span>(st,b) * clockwise &gt;= <span class="number">0</span>);</span><br><span class="line">ok &amp;= (<span class="built_in">dot</span>(st,<span class="built_in">ve</span>(a,b)) &gt;= <span class="number">0</span>) &amp;&amp; (<span class="built_in">cross</span>(st,<span class="built_in">ve</span>(a,b)) * clockwise &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ok;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> bfs = [&amp;](PII ve,<span class="type">int</span> clockwise)&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; <span class="built_in">dis</span>(n+<span class="number">1</span>,<span class="number">0ll</span>),<span class="built_in">deg</span>(n+<span class="number">1</span>,<span class="number">0ll</span>);</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edge</span>(n+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//都在同一侧，那么就可以连一条边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;=n;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isok</span>(ve,p[i],p[j],clockwise)) edge[j].<span class="built_in">push_back</span>(i),deg[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int u = 0;u&lt;=n;++u)&#123;</span></span><br><span class="line"><span class="comment">//cerr&lt;&lt;u&lt;&lt;&quot;:\n&quot;;</span></span><br><span class="line"><span class="comment">//for(int v : edge[u]) cerr&lt;&lt;v&lt;&lt;&quot; \n&quot;[v == edge[u].back()];</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//for(int i = 0;i&lt;=n;++i) cerr&lt;&lt;deg[i]&lt;&lt;&quot; \n&quot;[i == n];</span></span><br><span class="line"><span class="comment">//拓扑跑最长路</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : edge[u]) &#123;</span><br><span class="line">dis[v] = <span class="built_in">max</span>(dis[v],dis[u] + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//deg[v]--;</span></span><br><span class="line"><span class="keyword">if</span>(--deg[v] == <span class="number">00</span>) q.<span class="built_in">push</span>(v);</span><br><span class="line"><span class="comment">//if(deg[v] == 0) q.push(v);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : dis) ans = <span class="built_in">max</span>(ans,i);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;=n;++j)&#123;</span><br><span class="line"><span class="comment">//枚举线段</span></span><br><span class="line"><span class="keyword">if</span>(j == i) <span class="keyword">continue</span>;</span><br><span class="line">PII t = <span class="built_in">ve</span>(p[i],p[j]);</span><br><span class="line"><span class="comment">//debug</span></span><br><span class="line"><span class="comment">//cerr&lt;&lt;t.fi&lt;&lt;&#x27; &#x27;&lt;&lt;t.se&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//分两个方向建图，负方向对应关于t的翻转</span></span><br><span class="line"><span class="built_in">bfs</span>(t,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//cerr&lt;&lt;ans + f&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//debug</span></span><br><span class="line"><span class="built_in">bfs</span>(t,<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//cerr&lt;&lt;ans + f&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//debug</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int i = 0;i&lt;n;++i) cerr&lt;&lt;dis[i]&lt;&lt;&quot; \n&quot;[i == n - 1];</span></span><br><span class="line">cout&lt;&lt;ans + f&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 湖南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024ICPC昆明邀请赛</title>
      <link href="/2024/10/25/2024ICPC%E6%98%86%E6%98%8E%E9%82%80%E8%AF%B7%E8%B5%9B/"/>
      <url>/2024/10/25/2024ICPC%E6%98%86%E6%98%8E%E9%82%80%E8%AF%B7%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>题面：</p><div class="row">    <embed src="2024kunming-en.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="B-Gold-Medal"><a href="#B-Gold-Medal" class="headerlink" title="B - Gold Medal"></a><a href="https://codeforces.com/gym/105386/problem/B">B - Gold Medal</a></h3><p>签到题，很显然先分配那些补较少人数就能产生牌子的比赛，那么补全了之后如果还有剩的直接除k向下取整就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i) cin&gt;&gt;a[i],ans += a[i] / k,a[i] %= k;</span><br><span class="line"><span class="type">int</span> m,p = <span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(a),<span class="built_in">greater</span>());</span><br><span class="line"><span class="keyword">while</span>(p &lt; n &amp;&amp; m - (k - a[p]) &gt;= <span class="number">0</span>) ans++,m -= (k - a[p++]);</span><br><span class="line">ans += m / k;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="G-Be-Positive"><a href="#G-Be-Positive" class="headerlink" title="G - Be Positive"></a><a href="https://codeforces.com/gym/105386/problem/G">G - Be Positive</a></h3><p>观察样例可以发现当n == 4 || n == 1的时候归零了。</p><p>首先不难看出0,1,2,3;4,5,6,7;8,9,10,11;这样每四个连续的数异或都是0。</p><p>所以可以假设n是4的倍数&lt;=&gt;无解的（等于0）。</p><p>那么想让每一个前缀都大于0就要对其偏移一位就行，比如n == 2的时候是先1后0，即1 0,其他情况直接顺序排就行。</p><p>用队列实现比较容易一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">4</span> == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> cout&lt;&lt;<span class="string">&quot;impossible\n&quot;</span>,<span class="built_in">void</span>();</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span> || i == <span class="number">0</span>)&#123;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(!q.<span class="built_in">empty</span>()) cout&lt;&lt;q.<span class="built_in">front</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>,q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="I-Left-Shifting-2"><a href="#I-Left-Shifting-2" class="headerlink" title="I - Left Shifting 2"></a><a href="https://codeforces.com/gym/105386/problem/I">I - Left Shifting 2</a></h3><p> 左移操作最优的情况就是把一段相同字符拆成两段，如果一个偶数拆成了两个奇数，那么答案能减小1，只有奇数不影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">si</span>(s);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="comment">//双指针求每个连续的段的长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">a.<span class="built_in">push_back</span>(j - i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (s[i] == s[j]) j++;</span><br><span class="line">a.<span class="built_in">push_back</span>(j - i);</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意都是一个字母的情况就无所谓左移了</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">si</span>(a) == <span class="number">1</span>) <span class="keyword">return</span> cout&lt;&lt;a[<span class="number">0</span>] / <span class="number">2</span>&lt;&lt;endl,<span class="built_in">void</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ok表示存不存在偶数长度的连续段</span></span><br><span class="line"><span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先特判头尾都是一样的字母</span></span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">front</span>() == s.<span class="built_in">back</span>() &amp;&amp; !a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">a.<span class="built_in">front</span>() += a.<span class="built_in">back</span>();</span><br><span class="line">a.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : a) ans += i &gt;&gt; <span class="number">1</span>,ok |= (i % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; ans - ok &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-Two-star-Contest"><a href="#A-Two-star-Contest" class="headerlink" title="A - Two-star Contest"></a><a href="https://codeforces.com/gym/105386/problem/A">A - Two-star Contest</a></h3><p>直接贪心就行，注意题目没有说每个比赛的评级是不一样的，所以可能有评级一样的比赛，但是分数不一样，下一评级的比赛必须要大于这一级比赛的最大的分数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span>, p</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">info</span>(n, <span class="built_in">vector</span>(m, <span class="number">0ll</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">p.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt; m; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span>) cin &gt;&gt; s[i];</span><br><span class="line"><span class="keyword">else</span> cin &gt;&gt; info[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(p), [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line"><span class="keyword">return</span> s[x] &lt; s[y];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">int</span> pre = <span class="number">-1</span>, prep = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> maxn = pre;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;pre&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : p) &#123;</span><br><span class="line"><span class="type">int</span> tot, cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(prep != s[i]) pre = maxn;</span><br><span class="line"></span><br><span class="line">tot = pre + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j : info[i]) <span class="keyword">if</span>(j != <span class="number">-1</span>) cur += j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j : info[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span>) &#123;</span><br><span class="line">j = cur &gt;= tot ? <span class="number">0ll</span> : <span class="built_in">min</span>(k, tot - cur);</span><br><span class="line">cur += j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tot &gt; cur) <span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">maxn = <span class="built_in">max</span>(maxn, cur);</span><br><span class="line">prep = s[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) cout &lt;&lt; info[i][j] &lt;&lt; <span class="string">&quot; \n&quot;</span>[j == m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">队友的写法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct Info &#123;</span></span><br><span class="line"><span class="comment">int q, l, r, v, pos;</span></span><br><span class="line"><span class="comment">&#125; Data[N];</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">int n, m, k;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">vector&lt;int&gt; p[N];</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">void solve() &#123;</span></span><br><span class="line"><span class="comment">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; ++i) &#123;</span></span><br><span class="line"><span class="comment">cin &gt;&gt; Data[i].q;</span></span><br><span class="line"><span class="comment">for (int j = 0; j &lt; m; ++j) &#123;</span></span><br><span class="line"><span class="comment">int t;</span></span><br><span class="line"><span class="comment">cin &gt;&gt; t;</span></span><br><span class="line"><span class="comment">p[i].push_back(t);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; ++i) &#123;</span></span><br><span class="line"><span class="comment">Data[i].pos = i;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; ++i) &#123;</span></span><br><span class="line"><span class="comment">for (auto j : p[i]) &#123;</span></span><br><span class="line"><span class="comment">if (j == -1) &#123;</span></span><br><span class="line"><span class="comment">Data[i].r += k;</span></span><br><span class="line"><span class="comment">&#125; else &#123;</span></span><br><span class="line"><span class="comment">Data[i].l += j;</span></span><br><span class="line"><span class="comment">Data[i].r += j;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">sort(Data + 1, Data + 1 + n, [&amp;](Info x, Info y) &#123;</span></span><br><span class="line"><span class="comment">return x.q &lt; y.q;</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">Data[1].v = Data[1].l;</span></span><br><span class="line"><span class="comment">int x = Data[1].l;</span></span><br><span class="line"><span class="comment">int pre = 0;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">for (int i = 2; i &lt;= n; ++i) &#123;</span></span><br><span class="line"><span class="comment">if (Data[i].q != Data[i - 1].q) &#123;</span></span><br><span class="line"><span class="comment">pre = x + 1;</span></span><br><span class="line"><span class="comment">x = 0;</span></span><br><span class="line"><span class="comment">if (Data[i].r &gt;= pre) &#123;</span></span><br><span class="line"><span class="comment">Data[i].v = max(Data[i].l, pre);</span></span><br><span class="line"><span class="comment">x = max(x, Data[i].v);</span></span><br><span class="line"><span class="comment">&#125; else &#123;</span></span><br><span class="line"><span class="comment">for(int i = 1;i&lt;=n + 5;++i) Data[i].r = Data[i].v = Data[i].q = Data[i].l = Data[i].pos = 0;</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; ++i) p[i].clear();</span></span><br><span class="line"><span class="comment">return cout &lt;&lt; &quot;No&quot; &lt;&lt; endl, void();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125; else &#123;</span></span><br><span class="line"><span class="comment">if (Data[i].r &gt;= pre) &#123;</span></span><br><span class="line"><span class="comment">Data[i].v = max(Data[i].l, pre);</span></span><br><span class="line"><span class="comment">x = max(x, Data[i].v);</span></span><br><span class="line"><span class="comment">&#125; else &#123;</span></span><br><span class="line"><span class="comment">for(int i = 1;i&lt;=n + 5;++i) Data[i].r = Data[i].v = Data[i].q = Data[i].l = Data[i].pos = 0;</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; ++i) p[i].clear();</span></span><br><span class="line"><span class="comment">return cout &lt;&lt; &quot;No&quot; &lt;&lt; endl, void();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">sort(Data + 1, Data + 1 + n, [&amp;](Info x, Info y) &#123;</span></span><br><span class="line"><span class="comment">return x.pos &lt; y.pos;</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">//for(int i = 1;i&lt;=n;++i)&#123;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;Data[i].v&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; ++i) &#123;</span></span><br><span class="line"><span class="comment">int temp = 0;</span></span><br><span class="line"><span class="comment">for (auto j : p[i]) temp += max(j, 0ll);</span></span><br><span class="line"><span class="comment">temp = Data[i].v - temp;</span></span><br><span class="line"><span class="comment">for (auto &amp;j : p[i]) &#123;</span></span><br><span class="line"><span class="comment">if (j == -1 &amp;&amp; temp &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">j = min(temp, k);</span></span><br><span class="line"><span class="comment">temp -= j;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; ++i) &#123;</span></span><br><span class="line"><span class="comment">for (auto &amp;j : p[i]) &#123;</span></span><br><span class="line"><span class="comment">if(j == -1) j = 0;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; j &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">p[i].clear();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for(int i = 1;i&lt;=n + 5;++i) Data[i].r = Data[i].v = Data[i].q = Data[i].l = Data[i].pos = 0;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>致敬传奇二星级比赛ICPC。</p><h3 id="E-Relearn-through-Review"><a href="#E-Relearn-through-Review" class="headerlink" title="E - Relearn through Review"></a><a href="https://codeforces.com/gym/105386/problem/E">E - Relearn through Review</a></h3><p> 问你一个长度为n的正整数序列，可以选一个连续的子序列（可以为空）加上k，k为非负整数，问你这样操作之后这个序列整个的gcd最大是多少。</p><p>首先想一下最暴力的解法。</p><p>枚举左右端点，这个区间内的所有数加k。那么最坏至少是$ O(n^2) $的。</p><p>考虑优化，把这个前后缀打表，如第一个样例的数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">13</span> <span class="number">8</span> <span class="number">10</span> <span class="number">555</span></span><br><span class="line">pre:</span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">suf:</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">555</span></span><br></pre></td></tr></table></figure><p>可以发现其实有很多都是重复的数，其实最大大致只有logN个，N是这个数组中具有最多因子数的数。</p><p>前缀一定是单调递减的，因为重复的数一定是连续的，那么贪心的想，选每次即将变小的位置作为加k的左端点一定是当前这个gcd最优的情况。因为这能尽可能地保证后缀是最大的。因为最多是log级别的，所以每固定一个l，然后枚举r。暴力跑一遍大致就是$ O(nlogN) $的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; a[i];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">suf</span><span class="params">(n + <span class="number">2</span>)</span>, <span class="title">pre</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//pre[0] = 0, suf[n] = suf[n+1] = a[n - 1];</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) pre[i + <span class="number">1</span>] = <span class="built_in">gcd</span>(pre[i], a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; --i) suf[i] = <span class="built_in">gcd</span>(suf[i + <span class="number">1</span>], a[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//for(int i = 1;i&lt;=n;++i) cerr&lt;&lt;pre[i]&lt;&lt;&quot; \n&quot;[i == n];</span></span><br><span class="line"><span class="comment">//for(int i = 1;i&lt;=n;++i) cerr&lt;&lt;suf[i]&lt;&lt;&quot; \n&quot;[i == n];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特判所有前后缀gcd都是一样的时候</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">in:</span></span><br><span class="line"><span class="comment">5 2 </span></span><br><span class="line"><span class="comment">5 10 10 10 5 </span></span><br><span class="line"><span class="comment">out:</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//int maxn = 0;</span></span><br><span class="line"><span class="type">int</span> maxn = pre[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="comment">//gcd前缀种类最多是log个，且单调递减</span></span><br><span class="line"><span class="comment">//那么贪心的想当当前这个位置就要变小时前缀gcd一定是最大的，对答案的影响一定不劣</span></span><br><span class="line"><span class="keyword">if</span>(pre[i] != pre[i - <span class="number">1</span>])&#123;</span><br><span class="line"><span class="type">int</span> g = pre[i<span class="number">-1</span>];</span><br><span class="line"><span class="comment">//枚举右区间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;=n;++j)&#123;</span><br><span class="line">g = <span class="built_in">gcd</span>(g,a[j<span class="number">-1</span>] + k);</span><br><span class="line">maxn = <span class="built_in">max</span>(maxn,<span class="built_in">gcd</span>(g,suf[j+<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;maxn&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;maxn&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 昆明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024JXCPC</title>
      <link href="/2024/09/18/2024JXCPC/"/>
      <url>/2024/09/18/2024JXCPC/</url>
      
        <content type="html"><![CDATA[<p>题面：</p><div class="row">    <embed src="jxcpc.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="A-Maliang-Learning-Painting"><a href="#A-Maliang-Learning-Painting" class="headerlink" title="A - Maliang Learning Painting"></a><a href="https://codeforces.com/gym/105231/problem/A">A - Maliang Learning Painting</a></h3><p>签到题问你a + b + c等于多少</p><h3 id="C-Liar"><a href="#C-Liar" class="headerlink" title="C - Liar"></a><a href="https://codeforces.com/gym/105231/problem/C">C - Liar</a></h3><p> n 个人每人有一个数，分别宣称自己的数为 a1, a2, . . . , an。已知所有人的 数的和为 s，求至多有多少人没撒谎。  </p><p>显然如果$ \sum a_i == s $那么最优的是每个人都说了真话答案是n，如果不相等那就贪心的认为只有一个人说了谎其他人都没说谎，答案是n-1。</p><h3 id="G-Multiples-of-5"><a href="#G-Multiples-of-5" class="headerlink" title="G - Multiples of 5"></a><a href="https://codeforces.com/gym/105231/problem/G">G - Multiples of 5</a></h3><p> 给出一个 11 进制的数，问这个数是否是 5 的倍数。数的长度比较长，以 二元组 (x, y) 的形式逐个给出，表示接下来有 x 个 y 将要拼接到右侧。  </p><p>每一位拆开来看，对于长度为n的数可以理解为</p><p>$\sum a_i*(11)^{i-1} $</p><p>因为任意个11相乘模5等于1，即</p><p>$ (11)^{n}\%5 = 1 $即</p><p>$ (11)^n\equiv 1\ (mod\ 5) $</p><p>所以原式可以化为</p><p>$ \sum a_i*(11)^{i-1} \%5=\sum a_i\%5 $</p><p>所以求和取模即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, cnt; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; cnt &gt;&gt; c;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span>) t = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">else</span> t = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">(tot += cnt * t) %= <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tot) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K-Magic-Tree"><a href="#K-Magic-Tree" class="headerlink" title="K - Magic Tree"></a><a href="https://codeforces.com/gym/105231/problem/K">K - Magic Tree</a></h3><p> 2 × n 格子从 (1, 1) 走四连通进行 dfs，每次随机选择一个没走过的格子扩 展。问一共有多少种可能的方案，答案对998244353取模。</p><p>方案数是2的n-1次方，找规律猜结论猜出来的。</p><p>因为每增加一列，都有两种走法：</p><p>1：换行，换行走还不能重复走，所以只能走当前列</p><p>2：不换行，因为四联通走法，只能走当前列</p><p>所以就是$ 2^{n-1} $。甚至不需要快速幂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, ans = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) (ans &lt;&lt;= <span class="number">1</span>) %= mod;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="J-Magic-Mahjong"><a href="#J-Magic-Mahjong" class="headerlink" title="J - Magic Mahjong"></a><a href="https://codeforces.com/gym/105231/problem/J">J - Magic Mahjong</a></h3><p> 给出初始的 14 张麻将手牌，判断是否达成对应的条件。  </p><p>模拟题，队友写的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si(x) (int) x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="comment">//#define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug cerr&lt;&lt;<span class="string">&quot;******&quot;</span>&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">si</span>(s); i += <span class="number">2</span>) &#123;</span><br><span class="line">string t = s.<span class="built_in">substr</span>(i, <span class="number">2</span>);</span><br><span class="line">mp[t]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : mp) cnt += y == <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">7</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;7 Pairs&quot;</span>&lt;&lt;endl,<span class="built_in">void</span>();</span><br><span class="line"><span class="keyword">if</span> (mp[<span class="string">&quot;1z&quot;</span>] &gt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        mp[<span class="string">&quot;2z&quot;</span>] &gt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        mp[<span class="string">&quot;3z&quot;</span>] &gt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        mp[<span class="string">&quot;4z&quot;</span>] &gt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        mp[<span class="string">&quot;5z&quot;</span>] &gt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        mp[<span class="string">&quot;6z&quot;</span>] &gt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        mp[<span class="string">&quot;7z&quot;</span>] &gt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        mp[<span class="string">&quot;1s&quot;</span>] &gt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        mp[<span class="string">&quot;9s&quot;</span>] &gt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        mp[<span class="string">&quot;1p&quot;</span>] &gt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        mp[<span class="string">&quot;9p&quot;</span>] &gt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        mp[<span class="string">&quot;1m&quot;</span>] &gt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        mp[<span class="string">&quot;9m&quot;</span>] &gt;= <span class="number">1</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;Thirteen Orphans&quot;</span>&lt;&lt;endl,<span class="built_in">void</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Otherwise&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; fixed;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H-Convolution"><a href="#H-Convolution" class="headerlink" title="H - Convolution"></a><a href="https://codeforces.com/gym/105231/problem/H">H - Convolution</a></h3><p> 给定一个二维矩阵 I 以及卷积核 K 的大小，其中卷积核中每个元素只能 是 −1 或 0 或 1。矩阵 I 在卷积核的作用下会生成一个新的矩阵 O。 在所有可能的卷积核中，求输出矩阵 O 中的所有元素和的最大值。  </p><p>打一半去上厕所了然后回来队友就说自己做出来了……题目有点抽象大概意思就是对于一个二维矩阵I对于每个大小为K的子矩阵和K相乘之后最大化结果，K是你自己构造的。</p><p>像矩阵这样的题目一般都是对公式进行变形拆分之后进行计算的。</p><p>分开考虑贡献，比如原式矩阵是4×4的，卷积核是2×2的。</p><p>那么就有左上角的三行三列都是能够和卷积核的第一行第一例这个位置相乘一次，同样的右上角就能够和卷积核的第一行第二列元素相乘一次，考虑如何构造卷积核的元素，那么如果说这个前缀和是负数的，对应的卷积核的位置就应该是-1，相乘能到达正数，反之则是1。所以直接前缀和一遍取绝对值累加就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如4*4，2*2的</span></span><br><span class="line"><span class="comment">// 卷积核可以这样相乘</span></span><br><span class="line">|<span class="number">1</span> <span class="number">2</span>| <span class="number">3</span> <span class="number">4</span></span><br><span class="line">|<span class="number">5</span> <span class="number">6</span>| <span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="comment">// 也可以这样</span></span><br><span class="line"><span class="number">1</span> |<span class="number">2</span> <span class="number">3</span>| <span class="number">4</span></span><br><span class="line"><span class="number">5</span> |<span class="number">6</span> <span class="number">7</span>| <span class="number">8</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="comment">// 所以对于左上角的三行三列都有一次乘以卷积核的第一行第一列元素</span></span><br><span class="line">|<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>| <span class="number">4</span></span><br><span class="line">|<span class="number">5</span> <span class="number">6</span> <span class="number">7</span>| <span class="number">8</span></span><br><span class="line">|<span class="number">3</span> <span class="number">5</span> <span class="number">6</span>| <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="comment">// 求前缀和累加答案即可</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 106</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si(x) (int)(x.size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug cerr&lt;&lt;<span class="string">&quot;*******\n&quot;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, k, l;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; l;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0ll</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">cin &gt;&gt; mat[i][j];</span><br><span class="line">mat[i][j] += mat[i][j - <span class="number">1</span>] + mat[i - <span class="number">1</span>][j] - mat[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; sum = [&amp;](<span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2, <span class="type">int</span> r2)-&gt;<span class="type">int</span>&#123;</span><br><span class="line"><span class="keyword">return</span> mat[l2][r2] - mat[l1 - <span class="number">1</span>][r2] - mat[l2][r1 - <span class="number">1</span>] + mat[l1 - <span class="number">1</span>][r1 - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for(int i = 1;i&lt;=n;++i)</span></span><br><span class="line"><span class="comment">//for(int j = 1;j&lt;=m;++j)</span></span><br><span class="line"><span class="comment">//cerr&lt;&lt;mat[i][j]&lt;&lt;&quot; \n&quot;[j == m];</span></span><br><span class="line"><span class="type">int</span> sizel = n - k + <span class="number">1</span>,sizew = m - l + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - sizel + <span class="number">1</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m - sizew + <span class="number">1</span>; ++j) &#123;</span><br><span class="line"><span class="type">int</span> L = i, R = j;</span><br><span class="line"><span class="type">int</span> L1 = L + sizel - <span class="number">1</span>, R1 = R + sizew - <span class="number">1</span>;</span><br><span class="line">ans += <span class="built_in">llabs</span>(<span class="built_in">sum</span>(L, R, L1, R1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;my.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; fixed;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="comment">//cerr&lt;&lt;1e3 * clock() / CLOCKS_PER_SEC&lt;&lt;&quot; ms&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;%.3lf ms\n&quot;, 1e3 * clock() / CLOCKS_PER_SEC);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="L-Campus"><a href="#L-Campus" class="headerlink" title="L - Campus"></a><a href="https://codeforces.com/gym/105231/problem/L">L - Campus</a></h3><p> 一个 n 个点 m 条边的无向图，每个节点上有 ai 个人。n 个节点中有 k 个节点为出口，每个出口有一个开放时间$ [l_i,r_i] $。求第 1 ∼ T 时刻所有人到 最近的开放出口的路径长度之和。  </p><p>注意到k很小，所以考虑在k的上面跑暴力单源最短路。</p><p>题目给的限制很多，考虑从简单的版本入手，因为k很小，而且有一些情况对于答案影响不是很大，那么就考虑所有出口的开放时间无限。</p><p>那么就是建立一个超级源点，将源点连一条无向边到出口，然后跑一遍dij就行。</p><p>那么如果有时间限制呢？不难想到对于每一刻时间来说开放的出口是固定的，进而想到可以对[1,t]进行分段，连续的有相同开放出口的时间为同一段。这个最多最多只能达到2k个，对这些都建图跑dij就行。</p><p>具体可以用差分数组来实现。</p><p>比如有这样的2个出口开放时间是[1,4],[3,5];</p><p>那么对时间进行差分，求前缀和得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure><p>那么就[1,2],[3,4],[5,5]这样分段即可。</p><p>然后考虑每一段有多少的出口是开放的，开放的出口连边道源点。</p><p>然后每一段都分别跑dij就行。</p><p>注意判断无解的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si(x) (int) x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="comment">//#define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug cerr&lt;&lt;<span class="string">&quot;******&quot;</span>&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SP</span> &#123;</span><br><span class="line"><span class="type">int</span> n&#123;&#125;, s&#123;&#125;, t&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="type">int</span> to&#123;&#125;;</span><br><span class="line"><span class="type">int</span> w&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Edge</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">to = a;</span><br><span class="line">w = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;Edge&gt; edge[N];</span><br><span class="line"><span class="type">int</span> dist[N] &#123;&#125;;</span><br><span class="line">bitset&lt;N&gt; st&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : edge) i.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">fill</span>(dist + <span class="number">1</span>, dist + n + <span class="number">1</span>, <span class="number">1e9</span>);</span><br><span class="line">dist[s] = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">heap.<span class="built_in">emplace</span>(<span class="number">0</span>, s);</span><br><span class="line"><span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> ver = heap.<span class="built_in">top</span>().second;</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">st[ver] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : edge[ver]) &#123;</span><br><span class="line"><span class="type">int</span> j = i.to;</span><br><span class="line"><span class="keyword">if</span> (dist[j] &gt;= dist[ver] + i.w) &#123;</span><br><span class="line">dist[j] = dist[ver] + i.w;</span><br><span class="line">heap.<span class="built_in">emplace</span>(dist[j], j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br><span class="line">&#125; sp[<span class="number">35</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> diff[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, k, t;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; t;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; <span class="built_in">gate</span>(k);</span><br><span class="line">    <span class="comment">// gate存出口的信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) </span><br><span class="line">cin &gt;&gt; gate[i][<span class="number">0</span>] &gt;&gt; gate[i][<span class="number">1</span>] &gt;&gt; gate[i][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 对出口进行差分，求前缀和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [p, l, r] : gate)diff[l]++,diff[r+<span class="number">1</span>]--;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;N;++i) diff[i] += diff[i<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// 双指针求区间</span></span><br><span class="line">vector&lt;PII&gt; vis;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == N) vis.<span class="built_in">push_back</span>(&#123;j,i&#125;);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(diff[i] == diff[j]) <span class="keyword">continue</span>;</span><br><span class="line">vis.<span class="built_in">push_back</span>(&#123;j,i<span class="number">-1</span>&#125;);</span><br><span class="line">j = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 存边的信息</span></span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>,3&gt;&gt; <span class="built_in">edge</span>(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) </span><br><span class="line">cin &gt;&gt; edge[i][<span class="number">0</span>] &gt;&gt; edge[i][<span class="number">1</span>] &gt;&gt; edge[i][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// tot为总共有多少个区间</span></span><br><span class="line">    <span class="type">int</span> tot = <span class="built_in">si</span>(vis);</span><br><span class="line">    <span class="comment">// 每一个时间区间内的开放的出口是一样的，都是同一张图，</span></span><br><span class="line">    <span class="comment">// 每张图设0号点是超级源点，出口向源点连边。从0开始跑dij，</span></span><br><span class="line">    <span class="comment">// dist[i]表示第i个区间中的超级源点到所有点的距离之和，即所有点到开放的出口的距离之和</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(tot)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) &#123;</span><br><span class="line"><span class="keyword">auto</span> [x, y] = vis[i];</span><br><span class="line">        <span class="comment">// 一共有n+1个点（这题不写也没事）</span></span><br><span class="line">sp[i].n = n+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 起点是0号源点</span></span><br><span class="line">sp[i].s = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 终止点（可不写）</span></span><br><span class="line"><span class="comment">// sp[i].t = n;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [p, l, r] : gate) &#123;</span><br><span class="line">            <span class="comment">// 如果这个出口在这个区间是开放的那就连一条边到0号源点</span></span><br><span class="line"><span class="keyword">if</span> (l &lt;= x &amp;&amp; x &lt;= r) &#123;</span><br><span class="line">sp[i].edge[p].<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">sp[i].edge[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;p, <span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 连其他的边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [u, v, w] : edge) &#123;</span><br><span class="line">sp[i].edge[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">sp[i].edge[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 跑dij</span></span><br><span class="line">sp[i].<span class="built_in">dijkstra</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="comment">// 如果有点到不了出口，即0号点到这个点没有最短路，</span></span><br><span class="line">            <span class="comment">// 那么说明这个图没有出口，这个时间段是无解的</span></span><br><span class="line"><span class="keyword">if</span>(sp[i].dist[j] == <span class="number">1e9</span>)&#123;</span><br><span class="line">dist[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 否则就计算距离</span></span><br><span class="line">dist[i] += sp[i].dist[j] * a[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 查询时间输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;tot;++j)&#123;</span><br><span class="line">            <span class="comment">// 区间数很少直接跑暴力找这个时间属于哪一段</span></span><br><span class="line"><span class="keyword">if</span>(vis[j].first &lt;= i &amp;&amp; i &lt;= vis[j].second)&#123;</span><br><span class="line"> cout&lt;&lt;dist[j]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; fixed;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-Magic-LCM"><a href="#D-Magic-LCM" class="headerlink" title="D - Magic LCM"></a><a href="https://codeforces.com/gym/105231/problem/D">D - Magic LCM</a></h3><p> 给你一个长 n 的序列 ，每次可以选择两个位置，把其中一个位置变为 它们的最大公约数，另一个变为最小公倍数，求无限次操作后最大的序列之和。</p><p>对于两个数a和b，</p><p>将a和b分解质因数：</p><p>$ a= P_1^{a_1}P_2^{a_2}…P_k^{a_k},b=P_1^{b_1}P_2^{b_2}…P_k^{b_k} $</p><p>他们的gcd和lcm有这样的结论：</p><p>$ gcd(a,b)=\prod p_i^{min(a_i,b_i)},lcm[a,b]=\prod p_i^{max(a_i,b_i)} $  </p><p>首先如果能操作的话那么一定是变换后最优。</p><p>假设两个数A和B分解质因数之后是A = a,B = bc。如果能变换则可假设a整除c(即a|c)，a + bc显然是小于c + ba，因为作差后得到c + ba - (a + bc) = (b-1)(a-c)，因为b是质因子显然是大于等于2的，那么作差结果大于0。</p><p>其他情况也可以归纳证明。</p><p>观察这个变换，其实在变换对应的质因子，所以无论按照什么顺序变换，质因子的个数种类都是不会变的，所以只要变换到不能再变时一定是最优解。</p><p>所以只需要对每个数进行质因数分解，独立考虑每个质因子的次幂，将它们排序，只要将$ P_i^{j} $大的和大的合在一起就一定是最优的。</p><p>用代码中用了<code>map&lt;int,vector&lt;int&gt;&gt;</code>来存每个质因子的幂，这样写方便修改，49-61行这里如果不进行<code>erase</code>操作就会t。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000006</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si(x) (int)(x.size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug cerr&lt;&lt;<span class="string">&quot;*******\n&quot;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">//auto &amp;fac = sieve.fac;</span></span><br><span class="line">map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, a; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="comment">//分解质因数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j * j &lt;= a; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (a % j == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (a % j == <span class="number">0</span>) &#123;</span><br><span class="line">res *= j;</span><br><span class="line">a /= j;</span><br><span class="line">&#125;</span><br><span class="line">m[j].<span class="built_in">push_back</span>(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a != <span class="number">1</span>) &#123;</span><br><span class="line">m[a].<span class="built_in">emplace_back</span>(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//从小到大排序，这样就能保证大数在后面</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[p, v] : m) &#123;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">maxn = <span class="built_in">max</span>(maxn, <span class="built_in">si</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = (n - maxn) % mod;</span><br><span class="line"><span class="keyword">while</span> (!m.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; del;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[p, v] : m) &#123;</span><br><span class="line">(res *= v.<span class="built_in">back</span>()) %= mod;</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//直接去掉对于迭代器来说会出问题</span></span><br><span class="line"><span class="comment">//if(v.empty()) m.erase(p);</span></span><br><span class="line"><span class="keyword">if</span> (v.<span class="built_in">empty</span>()) del.<span class="built_in">push_back</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : del) m.<span class="built_in">erase</span>(x);</span><br><span class="line">(ans += res) %= mod;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;my.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; fixed;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="comment">//cerr&lt;&lt;1e3 * clock() / CLOCKS_PER_SEC&lt;&lt;&quot; ms&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;%.3lf ms\n&quot;, 1e3 * clock() / CLOCKS_PER_SEC);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这份代码跑了2s多，瓶颈在于分解质因数，如果想要快些可以先线性筛出1e6范围内的数中每一个数的最小质因子。然后每次就能在大概在ln级别的找齐所有的质因子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000006</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si(x) (int)(x.size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug cerr&lt;&lt;<span class="string">&quot;*******\n&quot;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EulerSieve</span> &#123;</span><br><span class="line">bitset &lt; N + 5 &gt; isprime;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; prime;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; fac;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Euler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fac.<span class="built_in">assign</span>(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isprime[i]) prime.<span class="built_in">push_back</span>(i), fac[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)prime.<span class="built_in">size</span>() &amp;&amp; i * prime[j] &lt;= N; ++j) &#123;</span><br><span class="line">isprime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">fac[i * prime[j]] = prime[j];</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; sieve;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">auto</span> &amp;fac = sieve.fac;</span><br><span class="line">map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, a; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="comment">//ln级别的分解质因数</span></span><br><span class="line"><span class="keyword">while</span> (fac[a]) &#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>, p = fac[a];</span><br><span class="line"><span class="keyword">while</span> (a % p == <span class="number">0</span>) &#123;</span><br><span class="line">res *= p;</span><br><span class="line">a /= p;</span><br><span class="line">&#125;</span><br><span class="line">m[p].<span class="built_in">emplace_back</span>(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//从小到大排序，这样就能保证大数在后面</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[p, v] : m) &#123;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">maxn = <span class="built_in">max</span>(maxn, <span class="built_in">si</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = (n - maxn) % mod;</span><br><span class="line"><span class="keyword">while</span> (!m.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; del;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[p, v] : m) &#123;</span><br><span class="line">(res *= v.<span class="built_in">back</span>()) %= mod;</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//直接去掉对于迭代器来说会出问题</span></span><br><span class="line"><span class="comment">//if(v.empty()) m.erase(p);</span></span><br><span class="line"><span class="keyword">if</span> (v.<span class="built_in">empty</span>()) del.<span class="built_in">push_back</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : del) m.<span class="built_in">erase</span>(x);</span><br><span class="line">(ans += res) %= mod;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;my.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; fixed;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//先筛出每一个数的最小质因子</span></span><br><span class="line">sieve.<span class="built_in">Euler</span>();</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="comment">//cerr&lt;&lt;1e3 * clock() / CLOCKS_PER_SEC&lt;&lt;&quot; ms&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;%.3lf ms\n&quot;, 1e3 * clock() / CLOCKS_PER_SEC);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 江西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024SXCPC</title>
      <link href="/2024/07/26/2024SXCPC/"/>
      <url>/2024/07/26/2024SXCPC/</url>
      
        <content type="html"><![CDATA[<p>题面：</p><div class="row">    <embed src="2024kunming-en.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="F-Try-a-try-AC-is-OK"><a href="#F-Try-a-try-AC-is-OK" class="headerlink" title="F - Try a try, AC is OK"></a><a href="https://codeforces.com/gym/105257/problem/F">F - Try a try, AC is OK</a></h3><p> 得分就是单次提交所能获得的最高分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> maxx=INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        maxx=<span class="built_in">max</span>(tmp,maxx);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxx&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-chmod"><a href="#A-chmod" class="headerlink" title="A - chmod"></a><a href="https://codeforces.com/gym/105257/problem/A">A - chmod</a></h3><p>模拟即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string x, s = <span class="string">&quot;xwr&quot;</span>;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : x) &#123;</span><br><span class="line"><span class="type">int</span> n = i - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">string t;</span><br><span class="line">t.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">t[i] = (n &amp; (<span class="number">1</span> &lt;&lt; i) ? s[i] : <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="built_in">reverse</span>(<span class="built_in">all</span>(t));</span><br><span class="line">cout &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="M-Window-Decoration"><a href="#M-Window-Decoration" class="headerlink" title="M - Window Decoration"></a><a href="https://codeforces.com/gym/105257/problem/M">M - Window Decoration</a></h3><p>注意到每个中心点的代表的面积一样的，那么并且如果一个点的上下左右四个方位中也有其他的点就一定是重叠了1单位的面积，容斥一下就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">bool</span>&gt;f;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">f[&#123;x, y&#125;] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> ans = f.<span class="built_in">size</span>() * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">99</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">99</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[&#123;i, j&#125;]) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[&#123;i - <span class="number">1</span>, j&#125;])num++;</span><br><span class="line"><span class="keyword">if</span>(f[&#123;i, j - <span class="number">1</span>&#125;])num++;</span><br><span class="line"><span class="keyword">if</span>(f[&#123;i + <span class="number">1</span>, j&#125;])num++;</span><br><span class="line"><span class="keyword">if</span>(f[&#123;i, j + <span class="number">1</span>&#125;])num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num /= <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; ans - num * <span class="number">0.5</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="G-Disappearing-Number"><a href="#G-Disappearing-Number" class="headerlink" title="G - Disappearing Number"></a><a href="https://codeforces.com/gym/105257/problem/G">G - Disappearing Number</a></h3><p>一个十进制数每一位都去掉了一个数字，问你在这个条件下这个十进制数是排在第几个。<br>现在想想每一位从原来的10种数字变成了9种数字，那不就是个十进制转换成九进制……怎么当时往数位dp上去想了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,x;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line"><span class="type">int</span> base=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line"><span class="type">int</span> tmp=n%<span class="number">10</span>;</span><br><span class="line">n/=<span class="number">10</span>;</span><br><span class="line">tmp -= tmp &gt; x;</span><br><span class="line">ans += tmp*base;</span><br><span class="line">base *= <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="L-Chess"><a href="#L-Chess" class="headerlink" title="L - Chess"></a><a href="https://codeforces.com/gym/105257/problem/L">L - Chess</a></h3><p>写一下证明。<br>先令<code>k == 2</code>，此时的LNC数是<code>pow(2,n)-1</code>找哪些数是必胜哪些数是必败的：<br>1：最简单的情况，显然先手必胜。<br>2：因为此时比他小的LNC数只有1，拿掉1后剩1，对于下家来说只存在必胜态1，下家必赢，先手必败，当前状态是必败的。<br>3：此时比他小的LNC数也是只有1，拿掉1后剩2，下家是必败态，此时先手必胜。<br>推测奇数是必胜否则必败(1)。<br>证明：因为在二进制下的LNC数都是形如<code>1111...111</code>这样的也就是说末尾一定是1，而必胜态是奇数，末尾是1，必败态末尾是0，那么一定存在一种方法使得先手在轮到自己的时候减去LNC数后是转向必败态，所以一定是必胜的。<br>然后令<code>k == 3</code>，也就是<code>k == 2</code>不行的时候，观察什么情况下<code>k == 3</code>是必胜的。<br>此时的LNC数是1 2 4 8<br>1：先手必胜。<br>2：先手必胜。<br>3(10)：先手可以拿掉1或者2，但都会转向必胜态，先手必败。<br>4(11)：先手可以拿1或拿2，或者直接拿完，存在转向必败的情况，由于考虑最优策略先手为了赢肯定让必败态转到下家，所以先手必胜。<br>5(12)：拿1转向必胜，拿2转向必败，拿4转向必胜，也存在转向必败的情况，先手必胜<br>6(20)：拿掉1,2,4，对应变成5,4,2，都是必胜的，下家必胜，先手必败。<br>7(21)：拿掉1,2,4，对应变成6,5,3，存在下家必败，先手必胜。<br>可以发现是1,2,3,4,5,6,7,8,9对应的输赢是赢赢输赢赢输赢赢输，推测<code>n % 3 != 0</code>是必胜否则必败(2)。<br>结合(1)(2)，推测<code>n % k != 0</code>时一定是先手赢。<br>证明：<br>显然对于k进制下个位数一定是LNC（除了0以外，即[1,k-1]），而且如果该进制下个位数是0的话一定不是LNC，也就不能一次性全部拿走，那么<code>n % k != 0</code>时，对于先手而言，如果当前不是个位数，那么就一定能拿的保证剩余的数在该进制下末位是0，下家就无法把它全部拿走，直到剩个位数的时候全部拿走就行。<br>有点像巴什博奕，改成一次只能拿[1,k-1]个石子也是一样的输赢结果。<br>实现的时候只要枚举进制就行，最小非因子考虑极端情况n是一些素数相乘这样才能尽可能大，这样n在1e18的范围是很小的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;;++k)</span><br><span class="line">        <span class="keyword">if</span>(x%k!=<span class="number">0</span>) <span class="keyword">return</span> cout&lt;&lt;k&lt;&lt;endl,<span class="built_in">void</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Expression-Matrix"><a href="#B-Expression-Matrix" class="headerlink" title="B - Expression Matrix"></a><a href="https://codeforces.com/gym/105257/problem/B">B - Expression Matrix</a></h3><p>队友找规律手算硬生生算出来打表的我也不知道怎么证明这个结果一定就是最小的，放下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">3</span> <span class="keyword">and</span> m==<span class="number">3</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span> <span class="keyword">and</span> m==<span class="number">4</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">1111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span> <span class="keyword">and</span> m==<span class="number">5</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span> <span class="keyword">and</span> m==<span class="number">6</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span> <span class="keyword">and</span> m==<span class="number">7</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111111</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">1111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span> <span class="keyword">and</span> m==<span class="number">8</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111111</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span> <span class="keyword">and</span> m==<span class="number">9</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111111</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">111111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">4</span> <span class="keyword">and</span> m==<span class="number">3</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">4</span> <span class="keyword">and</span> m==<span class="number">4</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">11*1</span></span><br><span class="line"><span class="string">1111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">4</span> <span class="keyword">and</span> m==<span class="number">5</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11+11</span></span><br><span class="line"><span class="string">11111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">4</span> <span class="keyword">and</span> m==<span class="number">6</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">11*1*1</span></span><br><span class="line"><span class="string">111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">4</span> <span class="keyword">and</span> m==<span class="number">7</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111111</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">11+1*11</span></span><br><span class="line"><span class="string">1111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">4</span> <span class="keyword">and</span> m==<span class="number">8</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111111</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11*1*1*1</span></span><br><span class="line"><span class="string">11111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">4</span> <span class="keyword">and</span> m==<span class="number">9</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111111</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">11+1*1*11</span></span><br><span class="line"><span class="string">111111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">5</span> <span class="keyword">and</span> m==<span class="number">3</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">5</span> <span class="keyword">and</span> m==<span class="number">4</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">11+1</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">1111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">5</span> <span class="keyword">and</span> m==<span class="number">5</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11+11</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">5</span> <span class="keyword">and</span> m==<span class="number">6</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">11+1+1</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">5</span> <span class="keyword">and</span> m==<span class="number">7</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111111</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">11+1+11</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">1111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">5</span> <span class="keyword">and</span> m==<span class="number">8</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111111</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11+1+1+1</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">5</span> <span class="keyword">and</span> m==<span class="number">9</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111111</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">11+1+1+11</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">111111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">6</span> <span class="keyword">and</span> m==<span class="number">3</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">6</span> <span class="keyword">and</span> m==<span class="number">4</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">11*1</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">11*1</span></span><br><span class="line"><span class="string">1111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">6</span> <span class="keyword">and</span> m==<span class="number">5</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11+11</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11+11</span></span><br><span class="line"><span class="string">11111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">6</span> <span class="keyword">and</span> m==<span class="number">6</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">11*1*1</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">11*1*1</span></span><br><span class="line"><span class="string">111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">6</span> <span class="keyword">and</span> m==<span class="number">7</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111111</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">11+1*11</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">11*1+11</span></span><br><span class="line"><span class="string">1111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">6</span> <span class="keyword">and</span> m==<span class="number">8</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111111</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11*1*1*1</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11*1*1*1</span></span><br><span class="line"><span class="string">11111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">6</span> <span class="keyword">and</span> m==<span class="number">9</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111111</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">11+1*1*11</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">11*1*1+11</span></span><br><span class="line"><span class="string">111111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">7</span> <span class="keyword">and</span> m==<span class="number">3</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">7</span> <span class="keyword">and</span> m==<span class="number">4</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">11+1</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">11*1</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">1111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">7</span> <span class="keyword">and</span> m==<span class="number">5</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11+11</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11+11</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">7</span> <span class="keyword">and</span> m==<span class="number">6</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">11+1*1</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">11*1+1</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">7</span> <span class="keyword">and</span> m==<span class="number">7</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111111</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">11+1*11</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">11*1+11</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">1111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">7</span> <span class="keyword">and</span> m==<span class="number">8</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111111</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11+1*1*1</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11*1+1+1</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">7</span> <span class="keyword">and</span> m==<span class="number">9</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111111</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">11+1*1*11</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">11*1+1+11</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">111111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">8</span> <span class="keyword">and</span> m==<span class="number">3</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">8</span> <span class="keyword">and</span> m==<span class="number">4</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">11*1</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">11*1</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">11*1</span></span><br><span class="line"><span class="string">1111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">8</span> <span class="keyword">and</span> m==<span class="number">5</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11+11</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11+11</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11+11</span></span><br><span class="line"><span class="string">11111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">8</span> <span class="keyword">and</span> m==<span class="number">6</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">11*1*1</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">11*1*1</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">11*1*1</span></span><br><span class="line"><span class="string">111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">8</span> <span class="keyword">and</span> m==<span class="number">7</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111111</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">11+1*11</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">11*1+11</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">11+1*11</span></span><br><span class="line"><span class="string">1111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">8</span> <span class="keyword">and</span> m==<span class="number">8</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111111</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11*1*1*1</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11*1*1*1</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11*1*1*1</span></span><br><span class="line"><span class="string">11111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">8</span> <span class="keyword">and</span> m==<span class="number">9</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111111</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">11+1*1*11</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">11*1+1*11</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">11*1*1+11</span></span><br><span class="line"><span class="string">111111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">9</span> <span class="keyword">and</span> m==<span class="number">3</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">1*1</span></span><br><span class="line"><span class="string">111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">9</span> <span class="keyword">and</span> m==<span class="number">4</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">11+1</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">11*1</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">11*1</span></span><br><span class="line"><span class="string">1*11</span></span><br><span class="line"><span class="string">1111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">9</span> <span class="keyword">and</span> m==<span class="number">5</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11+11</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11+11</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11+11</span></span><br><span class="line"><span class="string">1*1*1</span></span><br><span class="line"><span class="string">11111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">9</span> <span class="keyword">and</span> m==<span class="number">6</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">11+1*1</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">11*1*1</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">11*1+1</span></span><br><span class="line"><span class="string">1*1*11</span></span><br><span class="line"><span class="string">111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">9</span> <span class="keyword">and</span> m==<span class="number">7</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(1111111</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">11+1*11</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">11*1+11</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">11+1*11</span></span><br><span class="line"><span class="string">1*1*1*1</span></span><br><span class="line"><span class="string">1111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">9</span> <span class="keyword">and</span> m==<span class="number">8</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(11111111</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11+1*1*1</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11*1*1+1</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11*1+1*1</span></span><br><span class="line"><span class="string">1*1*1*11</span></span><br><span class="line"><span class="string">11111111)&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">9</span> <span class="keyword">and</span> m==<span class="number">9</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">R&quot;(111111111</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">11+1*1*11</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">11*1+1*11</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">11*1*1+11</span></span><br><span class="line"><span class="string">1*1*1*1*1</span></span><br><span class="line"><span class="string">111111111)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Seats"><a href="#C-Seats" class="headerlink" title="C - Seats"></a><a href="https://codeforces.com/gym/105257/problem/C">C - Seats</a></h3><p>首先遇到存在表示关系的问题，都可以考虑抽象成点与点之间的关系，然后就可以将关系转为边建图。<br>对于第$i$个人希望坐在$a_i$，可以理解为$i$到$a_i$有一条有向边。找几个样例画一下图：<img src="https://s2.loli.net/2024/07/26/HfvxmbYqtZPQhSK.png#errorMessage=unknown%20error&amp;id=ykZuH&amp;originHeight=480&amp;originWidth=889&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=error&amp;style=none" alt><br>所以前n个点的出度一定是1。并且可以发现相互之间存在关系的才会互相影响，又因为每个人都只有一个喜欢的座位，所以对于一块区域，如果有环，那么一定是只有一个环，且这个环生在这个区域的末尾，如第二张图。<br>（1）如果不是一条直链或者一整个环的区域，并且如果该区域有环，最大贡献就是环的大小。<br>因为如果区域内的从一个点开始断开和其他点的边，也就是不满足这个点的条件，那么这个点前面的点都不能满足。所以如果环上的点不满足，也就是环上的边断开了，这个断开处的点的前面所有点都不满足，又因为是一个环，其实也就变成了所有的点都不满足。所以存在环的区域贡献其实就是环的大小。这一点其实就是有向有环图为什么没有拓扑序，因为没有了先后关系。<br>（2）如果不是一条直链或者一整个环的区域，并且如果该区域没有环，最大贡献就是最长路。有向无环图，可以拓扑dp跑最长路。<br>（3）如果是一整个环的区域，归到（1）中解决。<br>（4）如果是一条直链的区域，归到（2）中解决。<br>具体的实现先处理自环，直接累加答案。然后用tarjan找环，对于强联通分量(SCC)的大小是大于1的SCC，累加SCC的大小。<br>处理完环之后跑拓扑序上的最长路dp，其实不用管环，因为环是在最后出现的并且每个点出度都是1,比如第二张图中到3就停下来了原因是2还有1连着它，做拓扑序的时候不满足前面的点都出队的条件，进不了队列，在3出队之后就停下来了有环并不影响结果。<br>然后统计所有有向无环的区域的汇点的最长路径累加即可。对于小于等于n的点，汇点可以用出度为0判断，对于大于n的点，汇点可以用只有一条入边，也就是入度为1来判断，因为大于n汇点是0有可能是和谁都没有连边的情况。并且要注意大于n的最长路要减去1，因为末尾大于n的那个位置并不是一个嘉宾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SCC</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edge, scc;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dfn, low, bel;</span><br><span class="line"><span class="type">int</span> idx, cnt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SCC</span>() &#123;&#125;</span><br><span class="line"><span class="built_in">SCC</span>(<span class="type">int</span> n) &#123;</span><br><span class="line"><span class="built_in">init</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">edge.<span class="built_in">assign</span>(n, &#123;&#125;);</span><br><span class="line">dfn.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">low.<span class="built_in">resize</span>(n);</span><br><span class="line">bel.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">stk.<span class="built_in">clear</span>();</span><br><span class="line">idx = cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">dfn[u] = low[u] = idx++;</span><br><span class="line">stk.<span class="built_in">push_back</span>(u);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : edge[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (dfn[v] == <span class="number">-1</span>) <span class="built_in">dfs</span>(v);</span><br><span class="line"><span class="keyword">if</span> (bel[v] == <span class="number">-1</span>) low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">v = stk.<span class="built_in">back</span>();</span><br><span class="line">c.<span class="built_in">push_back</span>(v);</span><br><span class="line">bel[v] = cnt;</span><br><span class="line">stk.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125; <span class="keyword">while</span> (v != u);</span><br><span class="line">cnt++;</span><br><span class="line">scc.<span class="built_in">push_back</span>(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">if</span> (dfn[i] == <span class="number">-1</span>) <span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="keyword">return</span> bel;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">deg</span><span class="params">(<span class="number">2</span> * n + <span class="number">1</span>)</span>, <span class="title">out</span><span class="params">(<span class="number">2</span> * n + <span class="number">1</span>)</span></span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edge</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//tarjan</span></span><br><span class="line"><span class="function">SCC <span class="title">scc</span><span class="params">(<span class="number">2</span> * n)</span></span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">scc.<span class="built_in">addEdge</span>(i - <span class="number">1</span>, t - <span class="number">1</span>);</span><br><span class="line">edge[i].<span class="built_in">push_back</span>(t);</span><br><span class="line"><span class="keyword">if</span> (i == t) ans++;</span><br><span class="line"><span class="comment">//deg存入度,用于拓扑序</span></span><br><span class="line">deg[t]++;</span><br><span class="line"><span class="comment">//出度</span></span><br><span class="line">out[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存一下入度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in</span><span class="params">(<span class="number">2</span> * n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++i) in[i] = deg[i];</span><br><span class="line"><span class="comment">//for(int i = 1;i&lt;=2*n;++i)</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;deg[i]&lt;&lt;&quot; \n&quot;[i == 2*n];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//先处理环</span></span><br><span class="line">scc.<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; scc.cnt; ++i)</span><br><span class="line"><span class="keyword">if</span> (scc.scc[i].<span class="built_in">size</span>() &gt; <span class="number">1</span>) ans += scc.scc[i].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">2</span> * n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//跑dp</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (deg[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i), dist[i]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (u &gt; n) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> v = edge[u][<span class="number">0</span>];</span><br><span class="line">dist[v] = <span class="built_in">max</span>(dist[v], dist[u] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (--deg[v] == <span class="number">0</span>) q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt;= n) &#123;</span><br><span class="line"><span class="keyword">if</span> (out[i] == <span class="number">0</span>) ans += dist[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (in[i]) ans += dist[i] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2024.08.06upd:好吧这个东西叫做基环树……当时没学vp的时候硬是用tarjan做出来了</p><p>剩下的金银牌题以后再补。</p>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 陕西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024SCCPC</title>
      <link href="/2024/07/24/2024SCCPC/"/>
      <url>/2024/07/24/2024SCCPC/</url>
      
        <content type="html"><![CDATA[<p>题面：</p><div class="row">    <embed src="sccpc.pdf" width="100%" height="550" type="application/pdf"></div><p>有点可惜要是先看的A题说不定就过金牌线了。</p><h3 id="L-Beef-Tripe-in-Soup-Pot"><a href="#L-Beef-Tripe-in-Soup-Pot" class="headerlink" title="L Beef Tripe in Soup Pot?"></a><a href="https://codeforces.com/gym/105222/problem/L">L Beef Tripe in Soup Pot?</a></h3><p>阅读理解题<del>，我和另一个队友当时没看到有中文题面看了半天</del>，就是在说有n种物品，每个有四个信息，第一个和第二个信息表示第一和第二个种类对应的值表示代价，第三个和第四个是这种物品的是属于第一种类还是第二种类。问你个每个物品划分完之后的最小代价。<br>就是排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a,p1,p2;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,x,y,u,v;i&lt;n;++i)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="keyword">if</span>(u &amp;&amp; v)&#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt; y) a.<span class="built_in">push_back</span>(y),p2.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">else</span> a.<span class="built_in">push_back</span>(x),p1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(u) a.<span class="built_in">push_back</span>(x),p1.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">else</span> a.<span class="built_in">push_back</span>(y),p2.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(p1),[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> a[x] &lt; a[y];&#125;);</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(p2),[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> a[x] &lt; a[y];&#125;);</span><br><span class="line">cout&lt;&lt;<span class="built_in">si</span>(p1)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : p1) cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; \n&quot;</span>[i == p1.<span class="built_in">back</span>()];</span><br><span class="line">cout&lt;&lt;<span class="built_in">si</span>(p2)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : p2) cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; \n&quot;</span>[i == p2.<span class="built_in">back</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H-GG-and-YY’s-Stone-Game"><a href="#H-GG-and-YY’s-Stone-Game" class="headerlink" title="H GG and YY’s Stone Game"></a><a href="https://codeforces.com/gym/105222/problem/H">H GG and YY’s Stone Game</a></h3><p>一道很简单的博弈论，甚至在我小学就听说过。<br>先考虑谁是获胜者。必胜态：当前只剩下一个或者两个。进而推出必败态：当前还剩三个，因为不管拿多少都拿不完，下家一定能全部拿走。接着推广：剩四个，因为可以拿一个或者两个，拿两个的时候剩两个，下家必赢，这样拿此时的玩家是输的，拿一个的时候剩三个，下家必输，这样拿此时的玩家是赢的，因为存在必胜态，或者说此时的玩家可以把结果引导到下家的必败态，所以剩四个的时候此时的玩家必赢，同理剩五个此时的玩家也是必赢的，剩六个可以发现不管怎么拿下家都是必胜态，所以剩六个此时的玩家必败……所以当<code>n%3 == 0</code>，先手必败，否则必胜。<br>同样的推理可以知道拿石子的数量的关系：<br>当先手是必败的，即<code>n%3 == 0</code>先手为了尽可能的多拿，肯定要拿两个，而后手为了保证下一步是对手必败，只能拿一个，因为这样的话能保证轮到对手的时候<code>n%3 == 0</code>恒成立，所以此时赢家（即后手）最多拿<code>n/3</code>个。<br>当先手是必胜的，也是一样的，第一步先拿<code>n%3</code>的部分，这样<code>n%3 == 0</code>始终是对手的。而自己就成了先手必败的时候后手的状态，每次都要拿一个，所以总共是<code>n%3 + n/3</code>个。<br>代码就不放了没什么要写的。</p><h3 id="E-L-Covering-Checker"><a href="#E-L-Covering-Checker" class="headerlink" title="E L-Covering Checker"></a><a href="https://codeforces.com/gym/105222/problem/E">E L-Covering Checker</a></h3><p>模拟题队伍里有是模拟仙人在我题还没看懂就写完了。<br>代码是队友的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">string s[n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)cin &gt;&gt; s[i], s[i] = <span class="string">&quot;0&quot;</span> + s[i];</span><br><span class="line"><span class="type">int</span> dot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line"><span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;.&#x27;</span>)dot++;</span><br><span class="line"><span class="keyword">if</span> (dot == <span class="number">1</span> <span class="keyword">and</span> s[<span class="number">1</span>][m] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="type">bool</span> a[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">a[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line"><span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">a[i][j] = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">1</span> <span class="keyword">and</span> s[i - <span class="number">1</span>][j] == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">a[i - <span class="number">1</span>][j] = <span class="literal">true</span>, num++;</span><br><span class="line"><span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">1</span> <span class="keyword">and</span> s[i][j - <span class="number">1</span>] == <span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">a[i][j - <span class="number">1</span>] = <span class="literal">true</span>, num++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> &lt;= m <span class="keyword">and</span> s[i][j + <span class="number">1</span>] == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">a[i][j + <span class="number">1</span>] = <span class="literal">true</span>, num++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt;= n <span class="keyword">and</span> s[i + <span class="number">1</span>][j] == <span class="string">&#x27;U&#x27;</span>)</span><br><span class="line">a[i + <span class="number">1</span>][j] = <span class="literal">true</span>, num++;</span><br><span class="line"><span class="keyword">if</span> (num != <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line"><span class="keyword">if</span> (s[i][j] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Link-Summon"><a href="#B-Link-Summon" class="headerlink" title="B Link Summon"></a><a href="https://codeforces.com/gym/105222/problem/B">B Link Summon</a></h3><p> 给你能力值为 1 到 5 的精灵的数量，问你最多能连接召唤出多 少能力值为 6 的精灵，注意这道题的召唤规则：选 k 只精灵出来，每个能力值为 x 的精灵<strong>当做x或者1</strong>，不是所有小于等于x的数。求和为 s, 并得到能力值为 s 的精灵一只。<br>直接贪心模拟就行。写起来比较复杂，先考虑2只就能合成6的，这个只有可能是能力5的精灵和其他能力的精灵，然后考虑能力是4的精灵和其他小于4的任选两只。注意能力值小于等于3的精灵，变成1和别的凑和直接<code>(a[1] * 1 + a[2] * 2 + a[3] * 3)/6</code>是一样的，因为考虑什么时候有剩余：对于3而言，肯定是自己两两一组最划算，否则和1 2的和至少要三个一组。对于2而言，和1组合至少要4个这一组，不如直接自己先组合。这样就剩了这些可能：3只能剩一个，在3剩余的情况下，合法的1和2的组合有(0,2),(3,0)，因为直接累加能多的只有是多一个2的贡献，也就是说直接加得到的是比变成1要多1；当3一个不剩的时候，剩下的各种情况都是直接凑是最优的，可以发现直接累加后多出来的部分不影响结果，所以上面的式子是正确的。<br>看出这个式子写起来会简单些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll t,a[<span class="number">6</span>],m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;++i)cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;++i)&#123;</span><br><span class="line">            m=<span class="built_in">min</span>(a[i],a[<span class="number">6</span>-i]);</span><br><span class="line">            sum+=m,a[i]-=m,a[<span class="number">6</span>-i]-=m;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=a[<span class="number">3</span>]/<span class="number">2</span>;</span><br><span class="line">        a[<span class="number">3</span>]%=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">5</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            m=<span class="built_in">min</span>(a[<span class="number">5</span>],a[<span class="number">2</span>]+a[<span class="number">3</span>]+a[<span class="number">4</span>]);</span><br><span class="line">            sum+=m;</span><br><span class="line">            a[<span class="number">5</span>]-=m;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">2</span>]&gt;m)a[<span class="number">2</span>]-=m;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                m-=a[<span class="number">2</span>],a[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">3</span>]&gt;m)a[<span class="number">3</span>]-=m;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    m-=a[<span class="number">3</span>],a[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(a[<span class="number">4</span>]&gt;m)a[<span class="number">4</span>]-=m;</span><br><span class="line">                    <span class="keyword">else</span> m-=a[<span class="number">4</span>],a[<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">5</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=a[<span class="number">5</span>]/<span class="number">2</span>;</span><br><span class="line">                a[<span class="number">5</span>]%=<span class="number">2</span>;</span><br><span class="line">                a[<span class="number">1</span>]+=a[<span class="number">5</span>];</span><br><span class="line">                a[<span class="number">5</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">4</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            m=<span class="built_in">min</span>(a[<span class="number">4</span>],(a[<span class="number">1</span>]+a[<span class="number">3</span>])/<span class="number">2</span>);</span><br><span class="line">            sum+=m;</span><br><span class="line">            a[<span class="number">4</span>]-=m;</span><br><span class="line">            m*=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>]&gt;m)a[<span class="number">1</span>]-=m;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                m-=a[<span class="number">1</span>],a[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">3</span>]&gt;m)a[<span class="number">3</span>]-=m;</span><br><span class="line">                <span class="keyword">else</span> m-=a[<span class="number">3</span>],a[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">4</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=a[<span class="number">4</span>]/<span class="number">3</span>;</span><br><span class="line">                a[<span class="number">4</span>]%=<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">4</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                    a[<span class="number">1</span>]++,a[<span class="number">4</span>]--;</span><br><span class="line">                    m=<span class="built_in">min</span>(a[<span class="number">4</span>],(a[<span class="number">1</span>]+a[<span class="number">3</span>])/<span class="number">2</span>);</span><br><span class="line">                    sum+=m;</span><br><span class="line">                    a[<span class="number">4</span>]-=m;</span><br><span class="line">                    m*=<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(a[<span class="number">1</span>]&gt;m)a[<span class="number">1</span>]-=m;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        m-=a[<span class="number">1</span>],a[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span>(a[<span class="number">3</span>]&gt;m)a[<span class="number">3</span>]-=m;</span><br><span class="line">                        <span class="keyword">else</span> m-=a[<span class="number">3</span>],a[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">4</span>]&gt;<span class="number">0</span>)a[<span class="number">1</span>]++,a[<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += (a[<span class="number">1</span>] * <span class="number">1</span> + a[<span class="number">2</span>] * <span class="number">2</span> + a[<span class="number">3</span>] * <span class="number">3</span>)/<span class="number">6</span>;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-Isoball-2D-Version"><a href="#F-Isoball-2D-Version" class="headerlink" title="*F Isoball: 2D Version"></a>*<a href="https://codeforces.com/gym/105222/problem/F">F Isoball: 2D Version</a></h3><p>队友没调出来</p><h3 id="I-Container-Scheduling"><a href="#I-Container-Scheduling" class="headerlink" title="*I Container Scheduling"></a>*<a href="https://codeforces.com/gym/105222/problem/I">I Container Scheduling</a></h3><p>大模拟懒得看</p><h3 id="A-Reverse-Pairs-Coloring"><a href="#A-Reverse-Pairs-Coloring" class="headerlink" title="A Reverse Pairs Coloring"></a><a href="https://codeforces.com/gym/105222/problem/A">A Reverse Pairs Coloring</a></h3><p>单杀的题，一眼扫描线。<br>观察第一个样例（5 9 1 8 2 6 4 7 3），可以发现每一行拆开来看的话长这样：<br>第一步 ：5，后面有1,2,3,4，涂色：<br><img src="https://s2.loli.net/2024/07/24/IcJDbNMdwgoGQhu.png#errorMessage=unknown%20error&amp;height=349&amp;id=JR6sE&amp;originHeight=582&amp;originWidth=558&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=error&amp;style=none&amp;width=335" alt><br>第二步：9，后面有1,2,3,4，6,7,8，涂色：<br><img src="https://s2.loli.net/2024/07/24/vDd7JPxgpQGNfwA.png#errorMessage=unknown%20error&amp;height=351&amp;id=UdIh5&amp;originHeight=586&amp;originWidth=562&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=error&amp;style=none&amp;width=337" alt><br>第三步：1，后面小于它的没有。<br><img src="https://s2.loli.net/2024/07/24/GaRWkypAO9T5Vx2.png#errorMessage=unknown%20error&amp;height=350&amp;id=nvD8d&amp;originHeight=585&amp;originWidth=563&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=error&amp;style=none&amp;width=337" alt><br>第四步：8，后面有2,3,4，6,7，涂色：<br><img src="https://s2.loli.net/2024/07/24/zHpZ2SMiahD8P6v.png#errorMessage=unknown%20error&amp;height=335&amp;id=G1sw9&amp;originHeight=584&amp;originWidth=561&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=error&amp;style=none&amp;width=322" alt><br>按照行来看，把二维的面积压成一条数轴，则前面4步数轴上的值可以表示为：<br>1:[1,1,1,1,0,0,0,0,0]，产生了1个块<br>2:[1,1,1,1,0,1,1,1,0]，多产生了1个块<br>3:[1,1,1,1,0,1,1,1,0]，多产生了0个块<br>4:[1,1,1,1,0,1,1,1,0]，多产生了2个块<br>可以发现第i行对于第i-1行而言，能够多出来的数只有是这个位置的前面闭上一行的多出来的连续1的 段数。<br>所以统计每一行从序号0开始到$a_i-1$为止连续1的段数，记为$p_i$,每行对答案的贡献为$max(0,p_i - p_{i-1})$。<br>统计段数可以用线段树，区间合并+单点修改的板子，这样实现的时候只要单点修改此时的点，统计这个位置前面没有出现过的数形成的段数即可。好像写复杂了官方题解用树状数组就能维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="comment">//#define N 103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si(x) (int)(x.size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug cout&lt;&lt;<span class="string">&quot;*******\n&quot;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Info</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::vector&lt;Info&gt; info;</span><br><span class="line"><span class="built_in">SegmentTree</span>() : <span class="built_in">n</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">SegmentTree</span>(<span class="type">int</span> n_, Info v_ = <span class="built_in">Info</span>()) &#123;</span><br><span class="line"><span class="built_in">init</span>(n_, v_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="title">SegmentTree</span><span class="params">(std::vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line"><span class="built_in">init</span>(init_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_, Info v_ = Info())</span> </span>&#123;</span><br><span class="line"><span class="built_in">init</span>(std::<span class="built_in">vector</span>(n_, v_));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line">n = init_.<span class="built_in">size</span>();</span><br><span class="line">info.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; std::__lg(n), <span class="built_in">Info</span>());</span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">info[p] = init_[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">2</span> * p, l, m);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r);</span><br><span class="line"><span class="built_in">pull</span>(p);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">info[p] = info[<span class="number">2</span> * p] + info[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">info[p] = v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">2</span> * p, l, m, x, v);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pull</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line"><span class="keyword">return</span> info[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p, l, m, x, y) + <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> r = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Info <span class="keyword">operator</span>+(Info a, Info b) &#123;</span><br><span class="line"><span class="keyword">if</span> (a.r == <span class="number">0</span> &amp;&amp; b.l == <span class="number">0</span>) &#123;</span><br><span class="line">a.cnt += b.cnt - <span class="number">1</span>;</span><br><span class="line">a.r = b.r;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">a.cnt += b.cnt;</span><br><span class="line">a.r = b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;Info&gt; <span class="title">init</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">init[i].l = <span class="number">0</span>, init[i].r = <span class="number">0</span>, init[i].cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SegmentTree&lt;Info&gt; <span class="title">seg</span><span class="params">(init)</span></span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>,pre = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="type">int</span> p = a[i];</span><br><span class="line">p--;</span><br><span class="line">seg.<span class="built_in">modify</span>(p, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">Info info = seg.<span class="built_in">rangeQuery</span>(<span class="number">0</span>, p);</span><br><span class="line">cnt = info.cnt;</span><br><span class="line">ans += <span class="built_in">max</span>(cnt - pre,<span class="number">0ll</span>);</span><br><span class="line">pre = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt) ans += cnt;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; fixed;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四川 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件管理系统的搭建</title>
      <link href="/2024/07/18/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/07/18/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>先搓了个本地的，等什么时候买了服务器弄个云端的玩玩。<br>用的是<a href="https://github.com/xddcode/free-fs">free-fs</a>。<br>装完mysql和navicat之后，配置好环境等，打开服务器，然后把它连到navicat（新建连接，选MySQL，起个名称，以下以名称local为例，主机选本地即localhost，端口用默认的3306，用户名和密码自定义，以下以root和123456为例）。</p><p><img src="https://s2.loli.net/2024/07/18/Ws6n3TUbafziuvl.png" alt="image.png"><br>然后右键local连接，选择新建数据库，将数据库名称改为free-fs，字符集选择utf8mb4，排序规则选utf8mb4_general_ci。<br><img src="https://s2.loli.net/2024/07/18/vE2mRKTrN6Xn4WS.png" alt="image.png"><br>最后在这个数据库上新建一个查询，打开用IDEA打开项目，找到sql文件，里面有一个free-fs.sql脚本。<br><img src="https://s2.loli.net/2024/07/18/l8H6y5AnMQwaDkC.png#id=yKprB&amp;originHeight=488&amp;originWidth=284&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none" alt><br>复制这个文件的内容到这个查询，选择运行。<br><img src="https://s2.loli.net/2024/07/18/GkvQqeWCBdrxT5l.png" alt="image.png"><br>这样就创建好了数据库。<br>然后是配置文件的修改部分：<br>先找到配置文件，在fs-admin里面，具体位置是../src/main/resources/application.yml，可以配置端口啥的。<br>必须要改的地方就一两处：<br>1.spring里的部分，profiles里的active改成dev，表示用的是dev这个配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">profiles:</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>2.fs配置，文件上传配置，即files-server要改为本地，本地的目录也要修改一个自己创建的目录，这里以存在F盘的fs/upload为例，这样上传的文件都会被保存到本地的这个文件夹里面。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">---</span> <span class="comment"># fs配置</span></span><br><span class="line"><span class="attr">fs:</span></span><br><span class="line">  <span class="attr">files-server:</span></span><br><span class="line">    <span class="comment"># 文件上传模式，local 本地，qiniu 七牛云，aliyunOss 阿里云OSS，minio MinIO</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">local:</span></span><br><span class="line">      <span class="comment"># 本地存储目录</span></span><br><span class="line">      <span class="attr">directory:</span> <span class="string">F:/fs/upload</span></span><br><span class="line">  <span class="string">......</span></span><br></pre></td></tr></table></figure><p>此外还要改同文件夹下的application-dev.yml，前几行要修改让他能够连接到数据库，具体要修改url，username，password。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/free-fs?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;useSSL=false&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>然后<del>原神</del>启动FreeFsApplication.java类即可，访问<a href="http://127.0.0.1:8081">http://127.0.0.1:8081</a>就可以看到成品了。</p><p><img src="https://s2.loli.net/2024/07/18/KBVrcCtZQgOYwRv.png" alt="image.png"></p><p>有时间解决一下无法在线预览的问题吧。<br>-upd 2024.07.08<br>……写这篇文档的目的是github上的说明太简略怕自己忘记了当时是怎么抓瞎折腾出来的，弄完了才发现在readme里面给了在线文档，真就眼睛瞎了(</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件管理系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18thZJCPC</title>
      <link href="/2024/04/06/18thZJCPC/"/>
      <url>/2024/04/06/18thZJCPC/</url>
      
        <content type="html"><![CDATA[<h3 id="A-League-of-Legends"><a href="#A-League-of-Legends" class="headerlink" title="A - League of Legends"></a><a href="https://codeforces.com/gym/103055/problem/A">A - League of Legends</a></h3><p>格莱美喜欢玩世界著名的英雄联盟游戏。<br>在最新版本中，有一个特殊的规则供玩家选择玩。根据此规则, 10 玩家将被分为红队和蓝队。每支队伍由 5 名玩家组成，每个玩家都有一个初始生命值。如果一支队伍中的所有 5 玩家均没有正HP值，则该队伍将输掉这场比赛。每回合，队伍可以选择一名球员并减少他的生命值 1。蓝队首先开始。<br>现在格莱美想知道两支球队是否都按照最优策略比赛，哪支球队会赢得比赛。<br>枚举，比大小，平局蓝队赢</p><h3 id="C-Cube"><a href="#C-Cube" class="headerlink" title="C - Cube"></a><a href="https://codeforces.com/gym/103055/problem/C">C - Cube</a></h3><p>给你三维空间中的八个点，请检查它们是否可以组成一个立方体。<br>立方体是正六面体，由六个正方形面包围，每个顶点有三个相交点。<br>T≤100组数据。<br>两两枚举点对之间的距离，根据对角线，体对角线，面对角线，棱的长度和数量关系判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t,x[<span class="number">8</span>],y[<span class="number">8</span>],z[<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)cin&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;z[i];</span><br><span class="line">        <span class="type">bool</span> tr= <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> h=<span class="number">0</span>;h&lt;<span class="number">8</span>;++h)&#123;</span><br><span class="line">            map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">               <span class="keyword">if</span>(i!=h)&#123;</span><br><span class="line">                   <span class="type">int</span> q=<span class="number">0</span>;</span><br><span class="line">                   q+=<span class="built_in">abs</span>(x[h]-x[i])*<span class="built_in">abs</span>(x[h]-x[i]);</span><br><span class="line">                   q+=<span class="built_in">abs</span>(y[h]-y[i])*<span class="built_in">abs</span>(y[h]-y[i]);</span><br><span class="line">                   q+=<span class="built_in">abs</span>(z[h]-z[i])*<span class="built_in">abs</span>(z[h]-z[i]);</span><br><span class="line">                   mp[q]++;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">size</span>()!=<span class="number">3</span>)&#123;</span><br><span class="line">                tr= <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> q[<span class="number">3</span>],w[<span class="number">3</span>],T=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp)&#123;</span><br><span class="line">                    q[T]=i.first;</span><br><span class="line">                    w[T]=i.second;</span><br><span class="line">                    T++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(q[<span class="number">0</span>]*<span class="number">2</span>==q[<span class="number">1</span>]&amp;&amp;q[<span class="number">0</span>]*<span class="number">3</span>==q[<span class="number">2</span>]&amp;&amp;w[<span class="number">0</span>]==<span class="number">3</span>&amp;&amp;w[<span class="number">1</span>]==<span class="number">3</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tr= <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tr)cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="M-Game-Theory"><a href="#M-Game-Theory" class="headerlink" title="M - Game Theory"></a><a href="https://codeforces.com/gym/103055/problem/M">M - Game Theory</a></h3><p>老师和学生互相给对方打分（需要从自己有的分数里扣），范围在[1,20]，假设老师打了x，学生打了y。如果x&gt;y学生多给老师10分，反之老师多给学生10分。<br>问如果老师随机出值，每个学生可以自己选择值，面对n个学生的情况下求老师得到的分数的期望大小。</p><p>因为这道题给了样例，发现是班上有一个同学的情况下老师的期望得分是0。<br>所以我们充分发扬人类的智慧大胆猜测这个不管来多少人都是0。<br>仔细想一想好像是对的，因为根据期望有线性性质，对于E(X1+X2+……+Xn) = E(X1)+E(X2)+……+E(Xn)<br>又因为这个是独立重复实验，学生之间的选择互不干扰。<br>所以E(X1+X2+……+Xn) = n*E(x1) = 0<br>至于为什么有一个同学的时候期望是0，这个写个程序枚举一下答案就是0，或者根据对称性乱搞一下应该也能分析出。<br>vp和队友开麦打的，当时就一个输出0敲上去发现真的对了就觉得离谱感觉被诈骗了。</p><p> <center><img src="https://s2.loli.net/2024/04/06/Qi92x3UoPKA5Ej7.png" alt="image.png" style="zoom:50%;"></center></p><h3 id="L-String-Freshman"><a href="#L-String-Freshman" class="headerlink" title="L - String Freshman"></a><a href="https://codeforces.com/gym/103055/problem/L">L - String Freshman</a></h3><p>给出一个字符匹配的假算法，和一个字符串T，要你找到一个字符串S是得T在匹配的时候使其返回值出错。<br>假算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_Answer</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] != T[j]) j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j]) j++;</span><br><span class="line"><span class="keyword">if</span> (j &gt; m) &#123;</span><br><span class="line">ans ++;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vp的时候看代码长得像kmp就往kmp上想了，因为这个在失配的时候直接跳回到原串的第一个位置，而kmp算法是跳到next数组的位置，所以只要有一个位置不是跳到第一个位置，也就是说只要有一个和第一个位置上的字符一样的，那么就是无解。赛时代码写的很乱，其实就判断是否有字符和第一个字符相等即可，有的话就输出false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> m,a[<span class="number">100001</span>];</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">kmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[len])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(len&gt;<span class="number">0</span>)len=a[len<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="built_in">kmp</span>();</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;Correct&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">kmp</span>())cout&lt;&lt;<span class="string">&quot;Wrong Answer&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Correct&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="J-Grammy-and-Jewelry"><a href="#J-Grammy-and-Jewelry" class="headerlink" title="J - Grammy and Jewelry"></a><a href="https://codeforces.com/gym/103055/problem/J">J - Grammy and Jewelry</a></h3><p>有一个连通无向图，其中有 $n$ 个顶点和 $m$ 条边。顶点的索引从 $1$ 到 $n$ 。顶点 $i$ （ $2\leq i\leq n$ ）中有无限多的珠宝，每个珠宝的价值都是 $a_i$ 。格莱美从点 $1$ 开始。经过每条边需要消耗 $1$ 个单位的时间。她可以在顶点 $i$ 拿起一件首饰，并在顶点 $1$ 放下。拿起珠宝和放下珠宝可以瞬间完成。此外，她在任何时候最多只能携带一件首饰。当她在顶点 $1$ 放下一件价值为 $x$ 的首饰时，她会得到它的价值。现在，对于 $1$ 和 $T$ （含）之间的每个 $k$ ，她想知道在 $k$ 个单位的时间内她能得到的最大价值是多少。</p><p>先跑一遍最短路然后在点与点之间dp就行。将其乘2存在<code>cost</code>数组中表示返回要花的时间。<br>由于边长都是1，可以直接跑bfs<br>令<code>dp[i]</code>表示第i个时间内能拿到的最大值。然后<code>dp[i]=max(dp[i],dp[i-cost[j]]+a[j]);</code>这样转移就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m,T;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;T;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[n+<span class="number">1</span>];</span><br><span class="line">a[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">per</span>(i,<span class="number">2</span>,n)cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[n+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">per</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">e[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">e[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cost[n+<span class="number">1</span>];<span class="comment">//到达每个节点的最短时间</span></span><br><span class="line"></span><br><span class="line">queue&lt;array&lt;<span class="type">int</span>,2&gt;&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">bitset&lt;3005&gt;vis;</span><br><span class="line">vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">array&lt;<span class="type">int</span>,2&gt;now=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> nxt:e[now[<span class="number">0</span>]])&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[nxt])&#123;</span><br><span class="line">vis[nxt]=<span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;nxt,now[<span class="number">1</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">cost[nxt]=now[<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">per</span>(i,<span class="number">2</span>,n)cost[i]=cost[i]*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义dp[T]为使用时间T可以获得的最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[T+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">per</span>(i,<span class="number">0</span>,T)dp[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拿a[i]价值需要付出 cost[i]时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显然从前面转移</span></span><br><span class="line"><span class="built_in">per</span>(i,<span class="number">1</span>,T)&#123;</span><br><span class="line"><span class="built_in">per</span>(j,<span class="number">2</span>,n)&#123;</span><br><span class="line"><span class="keyword">if</span>(i-cost[j]&gt;=<span class="number">0</span>)</span><br><span class="line">dp[i]=<span class="built_in">max</span>(dp[i],dp[i-cost[j]]+a[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">per</span>(i,<span class="number">1</span>,T)cout&lt;&lt;dp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-Fair-Distribution"><a href="#F-Fair-Distribution" class="headerlink" title="F - Fair Distribution"></a><a href="https://codeforces.com/gym/103055/problem/F">F - Fair Distribution</a></h3><p>梦幻王国里有 $n$ 个机器人和 $m$ 根能量棒。国王 DreamGrid 正试图公平分配能量棒。当且仅当能量棒的数量是机器人数量的倍数时，才存在公平分配。<br>DreamGrid 唯一的工具是一把威力强大的激光枪。每次打开激光枪，他都可以做以下两件事中的一件：</p><ul><li>创建一个新的能量条。</li><li>摧毁一个机器人。</li></ul><p>为了避免机器人灭绝，禁止摧毁所有 $n$ 机器人。打开一次激光枪需要一美元。要求你找出公平分配的最小成本。</p><p>有多个测试用例。输入的第一行包含一个整数 $T$ ( $1 \le T \le 1\,000$ )，表示测试用例的数量。对于每个测试用例<br>唯一一行包含两个整数 $n$ 和 $m$ （ $1 \le n, m \le 10^8$ ）。表示机器人和能量棒的初始数量。<br>对每个测试用例输出一行，其中包含一个整数，表示获得公平分配的最小成本。</p><p>一开始看范围想的是带根号的做法，想过根号分治但是后面想了半天没想到是整除分块，后面用扩欧解方程搓了半天结果失败了。<br>题目的大概意思是(m+x) % (n-y) == 0;x,y为正数，且n-y要求大于0，求x+y最小值</p><p>正解是整除分块。<br>分类讨论：<br>对于n&gt;m的情况，答案显然为n − m，即m%n == m,此时只能把n变到和m一样大小，或者是m变到和n一样大小。<br>对于n&lt;m的情况，考虑暴力做法，枚举n减小的次数，比如减小了y次，那么对于m而言想要被整除，需要变成</p><p><center>$$\left \lceil \frac{m}{n-y} \right \rceil *(n-y)$$</center><br>所以总代价是</p><p><center>$$y+\left \lceil \frac{m}{n-y} \right \rceil *(n-y)-m = \left \lceil \frac{m}{n-y}-1 \right \rceil *(n-y)+n-m$$</center><br>令n-y = i,枚举i所有的可能，但是暴力枚举会超时。<br>因为这个带有一个整除函数，联想到整除分块<br>可以将其转换为下取整，整理得</p><p><center>$\left \lceil \frac{m-1}{i} \right \rceil *i+n-m$</center><br>所以对其用分块算法即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">if</span>(n &gt; m)cout&lt;&lt;n-m&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> k = m<span class="number">-1</span>;</span><br><span class="line">r = <span class="built_in">min</span>(n, k/(k/l));</span><br><span class="line"><span class="type">int</span> res = k/l*l;</span><br><span class="line">ans = <span class="built_in">min</span>(ans,res);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans+n-m&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有点离谱vp前几天刚学的直接就没想到</p><h3 id="G-Wall-Game"><a href="#G-Wall-Game" class="headerlink" title="G - Wall Game"></a><a href="https://codeforces.com/gym/103055/problem/G">G - Wall Game</a></h3><p>给了一个图，蜂巢结构<img src="https://s2.loli.net/2024/04/07/Jxle1NcBrduPD8Z.png#id=or3EH&amp;originHeight=743&amp;originWidth=1155&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt><br>对于此二维的图，有n次操作：<br>每次操作有两种：<br><code>op == 1</code>，输入一个点（x，y），占领（ x , y )。<br><code>op == 2</code>，查询点（x，y）所在连通块的的外围边的数量。比如(0,0)构成的外围边是6，(0,0),(0,1)构成的外围边是10。<br>保证<code>op == 2</code>的时候的点是被占领的，<code>op == 1</code>的时候点是没有被占领的。<br>并查集求联通块即可。维护当前联通块的点数以及重边的个数，回答的时候就是联通块中点数<em>6 - 重边个数</em>2.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dx[<span class="number">6</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n,cnt = <span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="function">DSU <span class="title">comb</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">edge</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">vex</span><span class="params">(n+<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">map&lt;PII,<span class="type">int</span>&gt; h;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,x,y,op;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">h[&#123;x,y&#125;] = ++cnt;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;<span class="number">6</span>;++j)&#123;</span><br><span class="line"><span class="type">int</span> cx = x + dx[j],cy = y + dy[j];</span><br><span class="line"><span class="keyword">if</span>(h.<span class="built_in">count</span>(&#123;cx,cy&#125;))&#123;</span><br><span class="line">res++;</span><br><span class="line"><span class="type">int</span> x1 = comb.<span class="built_in">find</span>(cnt);</span><br><span class="line"><span class="type">int</span> x2 = comb.<span class="built_in">find</span>(h[&#123;cx,cy&#125;]);</span><br><span class="line"><span class="keyword">if</span>(x1 ^ x2)&#123;</span><br><span class="line">comb.par[x2] = x1;</span><br><span class="line">vex[x1] += vex[x2];</span><br><span class="line">edge[x1] += edge[x2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">edge[comb.<span class="built_in">find</span>(cnt)] += res;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> t = comb.<span class="built_in">find</span>(h[&#123;x,y&#125;]);</span><br><span class="line">cout&lt;&lt;vex[t] * <span class="number">6</span> - edge[t] * <span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="I-Grammy-and-Ropes"><a href="#I-Grammy-and-Ropes" class="headerlink" title="I - Grammy and Ropes"></a><a href="https://codeforces.com/gym/103055/problem/I">I - Grammy and Ropes</a></h3><p>给三个<del>圆绳</del>环形绳子构成的韦恩图：<br><img src="https://espresso.codeforces.com/04b1eaedc5460b79d3cb4d8b09e729305f03e778.png#id=c81KV&amp;originHeight=398&amp;originWidth=457&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt><br>如图所示，这些绳索(索引号从一到三)有六个重叠的交点，索引号分别从一到六。<br>格莱美想把这些绳子拉开，但它们似乎是绑在一起的，所以她需要用剪刀剪断这三根绳子中的一个子集。她想知道有多少种不同的方法来选择子集，以便之后这些绳子可以分开。你能告诉她答案吗？<br>注意：两个子集是不同的，当且仅当至少有一条绳子在其中一个子集中被选中，而在另一个子集中没有被选中。空集也应考虑在内。</p><p>考虑枚举子集的大小。<br>容易发现当子集的大小是3的时候，这个肯定是可以分开所有的绳子，这里只有一种情况。<br>当子集大小是2的时候，也是一定可以分开所有的绳子，一共有C(2,3) = 3种情况。<br>所以至少有4种情况是一定可以的。<br>当子集大小是1的时候，需要去枚举剩余的两根绳子是不是能够分开，两根绳子两个交点，即枚举第i个交点和第i+3个交点是不是一样的，如果不是那么这个剪法不对。<br>当子集大小是0的时候，要考虑三根绳子是不是原本就是分开的。<br>这个不太好想，用餐巾纸搓三条线之后玩了一下可以发现：<br>显然只有两个交点都是一样的才有机会。<br>在交点一样的情况下，比如第一条绳子在交点部分是全部在第二条绳子的上面时，可以理解为1-&gt;2有一条有向边，同理可以判断出1和3,2和3之间的关系，如果这个构成了一个环那么一定是错误的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">6</span>;++i)&#123;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;t&#x27;</span>) a[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//统计只剪一个的时候哪些是合法的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;++i) ans += a[i] == a[i+<span class="number">3</span>];</span><br><span class="line"><span class="comment">//用入度出度关系判环</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="comment">//1 2</span></span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>] == a[<span class="number">3</span>]) d[<span class="number">0</span>+(a[<span class="number">0</span>] == <span class="number">1</span>)]++;</span><br><span class="line"><span class="comment">//1 3</span></span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">1</span>] == a[<span class="number">4</span>]) d[<span class="number">0</span>+<span class="number">2</span>*(a[<span class="number">1</span>] == <span class="number">1</span>)]++;</span><br><span class="line"><span class="comment">//2 3</span></span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">2</span>] == a[<span class="number">5</span>]) d[<span class="number">1</span>+(a[<span class="number">2</span>] == <span class="number">1</span>)]++;</span><br><span class="line"><span class="keyword">if</span>(ans == <span class="number">7</span>) ans += !(d[<span class="number">0</span>] &amp;&amp; d[<span class="number">1</span>] &amp;&amp; d[<span class="number">2</span>]);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浙江 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17thZJCPC</title>
      <link href="/2024/04/06/17thZJCPC/"/>
      <url>/2024/04/06/17thZJCPC/</url>
      
        <content type="html"><![CDATA[<p>题面：</p><div class="row">    <embed src="en.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="K-Killing-the-Brute-force"><a href="#K-Killing-the-Brute-force" class="headerlink" title="K - Killing the Brute-force"></a><a href="https://codeforces.com/gym/102770/problem/K">K - Killing the Brute-force</a></h3><p> 给定标程和暴力在 n = 1, 2, . . . , m 时的运行时间，找到最小 的 n 使得三倍标程时限可以卡掉暴力 。<br>m很小没什么好讲的就一个遍历找到最小的即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(m)</span>,<span class="title">b</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;++i) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;++i) cin&gt;&gt;b[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;++i)</span><br><span class="line"><span class="keyword">if</span>(a[i]*<span class="number">3</span>&lt;b[i])</span><br><span class="line"><span class="keyword">return</span> cout&lt;&lt;i + <span class="number">1</span>&lt;&lt;endl,<span class="built_in">void</span>();</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-AD-2020"><a href="#A-AD-2020" class="headerlink" title="A - AD 2020"></a><a href="https://codeforces.com/gym/102770/problem/A">A - AD 2020</a></h3><p> 给一个日期的区间，问有多少个日期含有子串“202”的。<br>2000.01.01 ≤ 日期 ≤ 9999.12.31<br>参考题解给的是直接打表然后O(1)回答，vp时队友是直接先打完表给它存数组里面结果代码过长cf交不上去……然后就乱搞了一下二分给他爆了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">string pre[<span class="number">44295</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isleap</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">4</span>==<span class="number">0</span> <span class="keyword">and</span> x%<span class="number">100</span>!=<span class="number">0</span> <span class="keyword">or</span> x%<span class="number">400</span>==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> mon[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="type">int</span> lmon[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y1,m1,d1,y2,m2,d2;</span><br><span class="line">    cin&gt;&gt;y1&gt;&gt;m1&gt;&gt;d1&gt;&gt;y2&gt;&gt;m2&gt;&gt;d2;</span><br><span class="line"> </span><br><span class="line">    string sl=<span class="built_in">to_string</span>(y1);</span><br><span class="line">    <span class="keyword">if</span>(m1&lt;<span class="number">10</span>)sl+=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    sl+=<span class="built_in">to_string</span>(m1);</span><br><span class="line">    <span class="keyword">if</span>(d1&lt;<span class="number">10</span>)sl+=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    sl+=<span class="built_in">to_string</span>(d1);</span><br><span class="line"> </span><br><span class="line">    string sr=<span class="built_in">to_string</span>(y2);</span><br><span class="line">    <span class="keyword">if</span>(m2&lt;<span class="number">10</span>)sr+=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    sr+=<span class="built_in">to_string</span>(m2);</span><br><span class="line">    <span class="keyword">if</span>(d2&lt;<span class="number">10</span>)sr+=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    sr+=<span class="built_in">to_string</span>(d2);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//小 -&gt; 大</span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">44294</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//第一个大于等于sl的日期</span></span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre[mid]&lt;sl)l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ansl=r;</span><br><span class="line"> </span><br><span class="line">    l=<span class="number">1</span>,r=<span class="number">44294</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//第一个小于等于sr的日期</span></span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre[mid]&gt;sr)r=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">        <span class="keyword">if</span>(r==l+<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre[l+<span class="number">1</span>]&lt;=sr)l++;</span><br><span class="line">    <span class="type">int</span> ansr=l;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;ansr-ansl+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上直接在询问前预处理出来前缀和也不会超时的</p><h3 id="I-Invoking-the-Magic"><a href="#I-Invoking-the-Magic" class="headerlink" title="I - Invoking the Magic"></a><a href="https://codeforces.com/gym/102770/problem/I">I - Invoking the Magic</a></h3><p> 给定 n 对 pair，保证这 2n 个数一定由 n 个不同的数各出现 恰好两次构成。 将这些 pair 分成若干组，使得每组内出现的数都在该组内 出现恰好两次。 最小化最大的组包含的 pair 数。<br>n在1e5范围内。<br>如果按照关系建图就很容易发现是个连通块问题。直接离散化之后并查集即可。<br>这道题卡常居然，用stl离散化多写几个for直接t了，不知道当时比赛的测评机怎么样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],b[N],c[<span class="number">2</span>*N],d[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">        <span class="comment">//1 3 5 7 9</span></span><br><span class="line">        <span class="type">int</span> idx=(i<span class="number">-1</span>)*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        c[idx]=a[i];</span><br><span class="line">        c[idx+<span class="number">1</span>]=b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+<span class="number">2</span>*n);</span><br><span class="line">    <span class="type">int</span> dcnt=<span class="number">1</span>;</span><br><span class="line">    d[dcnt++]=c[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">2</span>,<span class="number">2</span>*n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]!=d[dcnt<span class="number">-1</span>])&#123;</span><br><span class="line">            d[dcnt++]=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1~dnct-1</span></span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;f;</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">1</span>,dcnt<span class="number">-1</span>)&#123;</span><br><span class="line">        f[d[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        a[i]=f[a[i]];</span><br><span class="line">        b[i]=f[b[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> g[dcnt];</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">1</span>,dcnt<span class="number">-1</span>)g[i]=i;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt;find=[&amp;](<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> g[x]=<span class="built_in">find</span>(g[x]);</span><br><span class="line">    &#125;;</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;unit=[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="type">int</span> g1=<span class="built_in">find</span>(g[x]),g2=<span class="built_in">find</span>(g[y]);</span><br><span class="line">        g[g1]=g2;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">unit</span>(a[i],b[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans[dcnt];</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">0</span>,dcnt<span class="number">-1</span>)ans[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">1</span>,dcnt<span class="number">-1</span>)g[i]=<span class="built_in">find</span>(g[i]);</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">1</span>,dcnt<span class="number">-1</span>)ans[g[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">1</span>,dcnt<span class="number">-1</span>)&#123;</span><br><span class="line">        ans[<span class="number">0</span>]=<span class="built_in">max</span>(ans[i],ans[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Bin-Packing-Problem"><a href="#B-Bin-Packing-Problem" class="headerlink" title="B - Bin Packing Problem"></a><a href="https://codeforces.com/gym/102770/problem/B">B - Bin Packing Problem</a></h3><p> 模拟 Bin Packing 问题的两个近似算法： (1) FF：每次找到最靠左的可以放下该物品的背包。 (2) BF：每次找到剩余容量最小的可以放下该物品的背包。<br>n小于等于1e6。</p><p>逆天歪榜题。赛后看题解发现是官方的评级是一道有金牌难度的题。vp也没想多久就给它A了。<br>第二个算法很好想，就是map里面用二分即可。<br>第一个首先是有一个单调性，因为找的是最左边的，所以存在一个边界，边界的左边的最大值一定是小于物品大小，从1号背包开始到边界的任意右边的区间的最大值一定大于物品大小，很显然的二分，由于枚举物品就要O(n)复杂度了，然后正常的二分，check里面又是线段树区间查询，O(n<em>logn</em>logn)是过不了1e6的，但是直接在线段树上做二分就没问题，能优化掉外围的一个log。<br>只能说板题学过就很简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Info</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::vector&lt;Info&gt; info;</span><br><span class="line"><span class="built_in">SegmentTree</span>() : <span class="built_in">n</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">SegmentTree</span>(<span class="type">int</span> n_, Info v_ = <span class="built_in">Info</span>()) &#123;</span><br><span class="line"><span class="built_in">init</span>(n_, v_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="title">SegmentTree</span><span class="params">(std::vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line"><span class="built_in">init</span>(init_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_, Info v_ = Info())</span> </span>&#123;</span><br><span class="line"><span class="built_in">init</span>(std::<span class="built_in">vector</span>&lt;Info&gt;(n_, v_));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line">n = init_.<span class="built_in">size</span>();</span><br><span class="line">info.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; std::__lg(n), <span class="built_in">Info</span>());</span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">info[p] = init_[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">2</span> * p, l, m);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r);</span><br><span class="line"><span class="built_in">pull</span>(p);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">info[p] = info[<span class="number">2</span> * p] + info[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">info[p] = v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">2</span> * p, l, m, x, v);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pull</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line"><span class="keyword">return</span> info[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p, l, m, x, y) + <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= y || r &lt;= x || !<span class="built_in">pred</span>(info[p])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">findFirst</span>(<span class="number">2</span> * p, l, m, x, y, pred);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">res = <span class="built_in">findFirst</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">findFirst</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line"><span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Info <span class="keyword">operator</span>+(Info a, Info b) &#123;</span><br><span class="line">a.maxn = <span class="built_in">max</span>(a.maxn,b.maxn);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">SegmentTree&lt;Info&gt; <span class="title">seg</span><span class="params">(n+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">seg.<span class="built_in">modify</span>(<span class="number">0</span>,Info&#123;c&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i: a)&#123;</span><br><span class="line"><span class="type">int</span> l = seg.<span class="built_in">findFirst</span>(<span class="number">0</span>,cnt,[&amp;](Info a)&#123;</span><br><span class="line"><span class="keyword">return</span> a.maxn &gt;= i;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span>(l == <span class="number">-1</span>)&#123;</span><br><span class="line">cnt++;</span><br><span class="line">seg.<span class="built_in">modify</span>(cnt<span class="number">-1</span>,Info&#123;c - i&#125;);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> maxn = seg.<span class="built_in">rangeQuery</span>(<span class="number">0</span>,l+<span class="number">1</span>).maxn;</span><br><span class="line">seg.<span class="built_in">modify</span>(l,Info&#123;maxn - i&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[c] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : a)&#123;</span><br><span class="line"><span class="keyword">auto</span> t = mp.<span class="built_in">lower_bound</span>(i);</span><br><span class="line"><span class="keyword">if</span>(t == mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">mp[c-i]++;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> [x,y] = *t;</span><br><span class="line"><span class="keyword">if</span>(--mp[x] == <span class="number">0</span>) mp.<span class="built_in">erase</span>(x);</span><br><span class="line">mp[x-i]++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; fixed;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K-Killing-the-Brute-force-1"><a href="#K-Killing-the-Brute-force-1" class="headerlink" title="K - Killing the Brute-force"></a><a href="https://codeforces.com/gym/102770/problem/K">K - Killing the Brute-force</a></h3><p>给这个dp转移方程<br>$dp[i][j]=\left\{\begin{array}{ll}<br>0 &amp; (i=0) \\<br>i^{2}+d p[i-1][j] &amp; (i&gt;0, j=0) \\<br>i^{2}+\max (d p[i-1][j], d p[i-1][j-1]+b[i]) &amp; (i&gt;0, j&gt;0)<br>\end{array}\right.$<br> 给定一个序列 a1, a2, . . . , an，q 次询问，每次询问在 a 的某 个区间跑 DP 时某个状态的 DP 值<br>打表之后可以发现是a数组中[l,r]的最大个k个数字之和再加上 1² + 2² + · · · + (r − l + 1)²<br>就是主席树板子题。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> rt[N],idx;</span><br><span class="line">ll pre[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    ll sum;</span><br><span class="line">    ll d;</span><br><span class="line">&#125;tr[N*<span class="number">40</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pre[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=<span class="number">100005</span>;i++)</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+i*i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    p=++idx;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(tr[p].l,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(tr[p].r,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>(),x)-num.<span class="built_in">begin</span>()+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">    p=++idx,tr[p]=tr[q];</span><br><span class="line">    tr[p].cnt+=<span class="number">1</span>,tr[p].sum+=cnt;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[p].d=cnt;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)</span><br><span class="line">        <span class="built_in">insert</span>(tr[p].l,tr[q].l,l,mid,pos,cnt);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">insert</span>(tr[p].r,tr[q].r,mid+<span class="number">1</span>,r,pos,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tr[p].d*k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=tr[tr[p].r].cnt-tr[tr[q].r].cnt;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=cnt)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tr[p].r,tr[q].r,mid+<span class="number">1</span>,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  tr[tr[p].r].sum-tr[tr[q].r].sum+<span class="built_in">query</span>(tr[p].l,tr[q].l,l,mid,k-cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        num.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            num.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            rt[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(rt[<span class="number">0</span>],<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>());</span><br><span class="line">        num.<span class="built_in">erase</span>(<span class="built_in">unique</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>()),num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">insert</span>(rt[i],rt[i<span class="number">-1</span>],<span class="number">1</span>,n,<span class="built_in">find</span>(a[i]),a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l,r,k;</span><br><span class="line">        <span class="type">int</span> q;</span><br><span class="line">        cin&gt;&gt;q;</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,pre[(r-l+<span class="number">1</span>)]+<span class="built_in">query</span>(rt[r],rt[l<span class="number">-1</span>],<span class="number">1</span>,n,k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中54行原先板子求第k大是返回询问，这里改成求和即可。<br>出板题真的离大谱……既然B题已经是RMQ问题了为什么又出一道RMQ。<del>虽然没学过主席树但是算法书上有区间第k大和前k个之和的例题，正式比赛两三个小时学一个算法和一道板题应该容易得吧</del></p><h3 id="C-Crossword-Validation"><a href="#C-Crossword-Validation" class="headerlink" title="C - Crossword Validation"></a><a href="https://codeforces.com/gym/102770/problem/C">C - Crossword Validation</a></h3><p>你得到了一个在N×N网格上完成的填字游戏。每个单元格要么是填有字母的白色单元格，要么是黑色单元格。你还会得到一本包含M个不同单词的字典，其中每个单词都有一个与之相关的分数。网格中的一个横向候选词是在网格的同一行上的一串连续的字母，不能被扩展。从形式上看，这意味着候选词最左边的单元格要么不存在，要么是一个黑色单元格，最右边的单元格也是如此。垂直候选词的定义与此类似，只是字母在同一列。候选词对于水平词来说是从左到右阅读，对于垂直词来说是从上到下阅读。当且仅当每个候选词都出现在给定的词典中时，该填字游戏才是有效的。一个有效的字谜的分数是字典中与每个候选词相关的分数之和。请注意，两个或多个候选词可能是相同的。在这种情况下，该词的分数会相应地被多次加分。你的程序必须确定谜题的分数，否则就报告说它无效。</p><p>输入包含多个案例。输入的第一行包含一个正整数 $T$ ，即样例数。<br>对于每个案例，输入的第一行包含两个整数 $N, M \ (1 \le N \le 1\,000, 1 \le M \le 4\times 10^6)$ ，即网格大小和字典中的字数。接下来的 $N$ 行分别包含长度为 $N$ 的字符串，其中每个字符都是小写英文字母或 “#”。如果$i$-th字符串中的 $j$-th 字符是 “#”，那么位于$i$-th 行和$j$-th 列交叉处的单元格为黑色单元格。否则，该字符表示该单元格中填写的字母。下面的 $M$ 行分别包含一个仅由小写英文字母组成的非空字符串，以及一个正整数，表示字典中的一个单词及其得分。保证这些 $M$ 个单词是成对不同的，每个单词的长度不超过 $N$ ，每个单词的得分不超过 $10^9$ 。<br>保证所有情况下 $N^2$ 的总和不超过 $4\times 10^6$ ，所有情况下字典中所有单词的长度总和不超过 $4\times 10^6$ 。<br>输出<br>对于每个案例，在单行中打印一个整数，即输入中给出的字谜解决方案的分数，如果它是有效的。如果解决方案无效，则打印-1。</p><p>评价为阅读理解题，读懂了就是一个字典树问题。<br>对字典中的单词建树。每个单词的末尾都改为对应的分数大小，即代码中的<code>tot[now] = v</code>。然后枚举所有的网格中的字符串，横着枚举一遍，竖着枚举一遍，如果有不匹配或者是一个单词的前缀（即结束时<code>tot[now] == 0</code>）那么就是无解输出-1，否则加上分数输出总分即可。<br>几个细节：<br>1.字典树的空间复杂度很高，对于习惯不好的人比如我直接<code>#define int long long</code>那么容易爆空间，最好还是算一下哪些变量会爆int，做这道题最终的总分会爆，不开long long会wa<br>2.字典树模板是求前缀，但是这道题如果是前缀（子串）也应该是返回非法，所以要判断<code>!tot[now]</code>。<br>其他就套模板即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 4000006</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, nxt[N][<span class="number">30</span>], cnt;</span><br><span class="line"><span class="type">int</span> tot[N];</span><br><span class="line"><span class="type">char</span> str[<span class="number">1003</span>];</span><br><span class="line"><span class="type">char</span> mp[<span class="number">1003</span>][<span class="number">10004</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNum</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len = (<span class="type">int</span>) <span class="built_in">strlen</span>(s), now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x; i &lt; len; ++i) &#123;</span><br><span class="line">x = <span class="built_in">getNum</span>(s[i]);</span><br><span class="line"><span class="keyword">if</span> (!nxt[now][x]) nxt[now][x] = ++cnt;</span><br><span class="line">now = nxt[now][x];</span><br><span class="line"><span class="comment">//++tot[now];</span></span><br><span class="line">&#125;</span><br><span class="line">tot[now] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len = (<span class="type">int</span>) <span class="built_in">strlen</span>(s), now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x; i &lt; len; ++i) &#123;</span><br><span class="line">x = <span class="built_in">getNum</span>(s[i]);</span><br><span class="line"><span class="keyword">if</span> (!nxt[now][x]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> now = nxt[now][x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!tot[now]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> tot[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(nxt[i], <span class="number">0</span>, <span class="keyword">sizeof</span> nxt[i]);</span><br><span class="line">tot[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">cin &gt;&gt; mp[i] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">cin &gt;&gt; str &gt;&gt; v;</span><br><span class="line"><span class="built_in">insert</span>(str, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (mp[i][j] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; j &lt;= n)</span><br><span class="line">str[k++] = mp[i][j++];</span><br><span class="line">str[k] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">find</span>(str);</span><br><span class="line"><span class="keyword">if</span> (~res) ans += res;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> cout &lt;&lt; res &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (mp[i][j] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; i &lt;= n)</span><br><span class="line">str[k++] = mp[i++][j];</span><br><span class="line">str[k] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">find</span>(str);</span><br><span class="line"><span class="keyword">if</span> (~res) ans += res;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> cout &lt;&lt; res &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; fixed;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="G-Gliding"><a href="#G-Gliding" class="headerlink" title="G - Gliding"></a><a href="https://codeforces.com/gym/102770/problem/G">G - Gliding</a></h3><p>林克喜欢酷炫的挑战，比如从小孔射箭、从 3000 米高的雪山上滑下来，以及用一片巨大的树叶演奏音乐。现在他正在尝试一项新的挑战，在湖中滑行而不沉入湖中。<br>Link的世界是一个三维空间，我们定义一个笛卡尔坐标系 $(x,y,z)$ ，其中 $z$ 是高度。水面是平面 $z=0$ 。链接从位置 $(s_x,s_y,0)$ 开始，目标位于 $(t_x,t_y,0)$ 。如果在任何时候他的高度 $z$ 严格小于 $0 \ (z<0)$ ，则他挑战失败，这意味着他掉进了水里。 在林克的世界里，与地球不同，空气中的物体以 $v_f$ 的恒定速度自由落体。在如此快的坠落速度下，林克无法控制自己的身体，会以零水平速度垂直坠落。幸运的是，林克有滑翔伞来减缓坠落的速度。一旦他打开滑翔伞，下落速度就会变成 $v_p$ ，且 $v_p < v_f$ 。林克能够以最多 $v_h$ 的速度向任何方向水平移动。形式上，link 在 $x$ 方向 $v_x$ ， $y$ 方向上的$v_y$ 速度应满足 $\sqrt{v_x^2+v_y^2} \leq v_h$ 。林克可以多次关闭和打开滑翔伞，而且他可以随时这样做。 对林克来说更好的是，湖里有 $n+1$ 奇怪的风洞，产生向上吹的风，帮助林克飞得更高。这些风穴的编号从 $0$ 到 $n$ ，并由元组$(x_i,y_i,v_i),i="0,1,\dots,n$描述。第" $i$ 个风洞的位置是 $(x_i,y_i,0)$ ，其向上风的速度是 $v_i$ 。林克必须位于垂直线$[ x="x_i,y=y_i]$上，并且他的滑翔伞必须打开才能受到第" 个洞穴的影响。如果林克的滑翔伞在第 个风穴顶部打开，如果 $v_i>v_p$ ，他将以速度 $v_i-v_p$ 上升，如果 $v_p&gt;v_i$ ，他将以速度 $v_p-v_i$ 下降，或者垂直速度为零如果 $v_p=v_i$ 。 Link开始的位置是第 $0$ 个风洞，意思是 $s_x=x_0, s_y=y_0$ 。林克仔细地选择了这个位置，使得 $v_0&gt;v_p$ ，这意味着他最初可以升到他想要的高度。因此，可以证明，只要有足够的时间，林克总能到达目的地而不会掉进湖里。<br>林克打开和关闭滑翔伞所需的时间以及改变速度所需的时间可以忽略不计。 Link 想知道到达目的地所需的最短时间。</0)$></p><p>玩塞尔达玩的。<br>一个简单的dp问题，令<code>dp[i]</code>表示最终在第i个风洞的位置所需要的最短时间，那么可以枚举上一个风洞的位置，从上一个位置转移过来，然后发现好像和在这之前的速度最大的风洞上面多停几秒肯定优于在比它速度小的风洞上停留的时间短。<br>那么这样就和之前的选择有关联，无法dp。<br>但是题目对于先去哪个风洞并没有要求，所以直接对风洞的速度大小进行从小到大排序即可，那么从小到大枚举当前风洞，此时的风洞速度一定是目前去过的所有风洞中最大的那个，然后再枚举要去的风洞，因为显然飞到想去的点的位置时林克刚好位于水平面是最不浪费时间的，所以<code>dp[J] = min(dp[J],dp[I] + t + h/v);</code>转移，其中<code>t</code>是过去要花的时间，<code>h/v</code>是最少需要上升h的高度所需要的时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> s1, s2, t1, t2;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line"><span class="type">int</span> vf, vp, vh;</span><br><span class="line">cin &gt;&gt; vf &gt;&gt; vp &gt;&gt; vh;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; <span class="built_in">cave</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="type">int</span> x, y, v;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;</span><br><span class="line">cave[i] = &#123;x, y, v&#125;;</span><br><span class="line">&#125;</span><br><span class="line">cave.<span class="built_in">push_back</span>(&#123;t1, t2, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> getDis = [&amp;](<span class="type">double</span> x1, <span class="type">double</span> y, <span class="type">double</span> x2, <span class="type">double</span> y2) -&gt; <span class="type">double</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((x1 - x2) * (x1 - x2) + (y - y2) * (y - y2));</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; dist = <span class="built_in">vector</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>(n + <span class="number">2</span>, (<span class="type">double</span>)<span class="number">0</span>));</span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">3</span>, (<span class="type">double</span>)<span class="number">1e14</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n + <span class="number">1</span>; ++j)</span><br><span class="line">dist[i][j] = dist[j][i] = <span class="built_in">getDis</span>(cave[i][<span class="number">0</span>], cave[i][<span class="number">1</span>], cave[j][<span class="number">0</span>], cave[j][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; ++i) p.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(p.<span class="built_in">begin</span>() + <span class="number">1</span>,p.<span class="built_in">end</span>() - <span class="number">1</span>,[&amp;](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line"><span class="keyword">return</span> cave[a][<span class="number">2</span>] &lt;= cave[b][<span class="number">2</span>];</span><br><span class="line">&#125;);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j) &#123; <span class="comment">//这里枚举的时候j从0开始也没问题反正不影响结果</span></span><br><span class="line"><span class="type">int</span> I = p[i],J = p[j];</span><br><span class="line"><span class="type">double</span> v = cave[I][<span class="number">2</span>] - vp;</span><br><span class="line"><span class="keyword">if</span>(v &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">double</span> t = dist[I][J]/vh;</span><br><span class="line"><span class="type">double</span> h = t*vp;</span><br><span class="line">dp[J] = <span class="built_in">min</span>(dp[J],dp[I] + t + h/v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[n+<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浙江 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年度第五届全国大学生算法设计与编程挑战赛（春季赛）</title>
      <link href="/2024/03/31/2024%E5%B9%B4%E5%BA%A6%E7%AC%AC%E4%BA%94%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98%E8%B5%9B%EF%BC%88%E6%98%A5%E5%AD%A3%E8%B5%9B%EF%BC%89/"/>
      <url>/2024/03/31/2024%E5%B9%B4%E5%BA%A6%E7%AC%AC%E4%BA%94%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98%E8%B5%9B%EF%BC%88%E6%98%A5%E5%AD%A3%E8%B5%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="H-密码是多少？"><a href="#H-密码是多少？" class="headerlink" title="H 密码是多少？"></a>H 密码是多少？</h3><p><img src="https://s2.loli.net/2024/03/31/8FSYsa9meEoTDuO.png#id=Ar6Tr&amp;originHeight=651&amp;originWidth=940&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt><br>注意字符串长度都是7<br>样例1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asdfghj</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10210310410697115100</span></span><br></pre></td></tr></table></figure><p>样例2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qazxcdf</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1209910010211397122</span></span><br></pre></td></tr></table></figure><p>按题意模拟即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">string t = s.<span class="built_in">substr</span>(<span class="number">3</span>) + s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c : t)</span><br><span class="line">cout&lt;&lt;(<span class="type">int</span>)c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-送个分吧"><a href="#A-送个分吧" class="headerlink" title="A 送个分吧"></a>A 送个分吧</h3><p><img src="https://s2.loli.net/2024/03/31/RWn1sGQ7Uha9Al5.png#id=wqZ2N&amp;originHeight=924&amp;originWidth=925&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt><br>样例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aba</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b</span><br></pre></td></tr></table></figure><p>对于给定的样例，前 4 简单的套题分别为：a、ab、aba、b，故答案为 b。<br>对于 100%的数据，1≤∣_s_∣≤5000,1≤_k_≤5，保证答案存在。</p><p>就是在问你字典序第k小的子串<br>s的范围决定了这道题最多只能是$O(n^2)$的复杂度。<br>可以这样考虑，比如对于样例而言，前几个子串一定是a开头的，可以是a,ab,aba。那么猜想前面几个一定是字符串中出现的字典序最小的那个字符的某个后缀，比如最小的是a,第二小的是ab(第一个a后面长度为2的后缀),第三小的是aba（第一个a后面长度为3的后缀）。且是长度越小的后缀就一定字典序越小<br>那么因为出现的字典序最小的那个字符会有很多个，比如样例就是a出现在了第一个和第三个位置。<br>那么所有以a为开头的后缀有a,ab,aba(第一个a能得到的后缀),a（第二个a得到的后缀），发现有重复的情况。所以可以开set去重。</p><p>比如有一个字符串abcaac.先用平方复杂度求出每个位置的后缀:<br>1:abcaac<br>2:bcaac<br>3:caac<br>4:aac<br>5:ac<br>6:c<br>然后对这些字符串按字典序排序。<br>4:aac<br>1:abcaac<br>5:ac<br>2:bcaac<br>6:c<br>3:caac<br>那么字典序第1小的子串就是a,第二小的是aa，第三小的是aac……<br>排序可以用map自动排序，然后找第k小的时候用set去重</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="comment">//#define N 1003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si(x) (int)(x.size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug cout&lt;&lt;<span class="string">&quot;*******\n&quot;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">cin&gt;&gt;s&gt;&gt;k;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line">set&lt;string&gt; st;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">si</span>(s);++i)&#123;</span><br><span class="line">mp[s.<span class="built_in">substr</span>(i)] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [str,v]:mp)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="built_in">si</span>(str);++i)&#123;</span><br><span class="line">string t = str.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line"><span class="keyword">if</span>(st.<span class="built_in">count</span>(t))<span class="keyword">continue</span>;</span><br><span class="line">cnt++;</span><br><span class="line">st.<span class="built_in">insert</span>(t);</span><br><span class="line"><span class="keyword">if</span>(cnt == k) <span class="keyword">return</span> cout&lt;&lt;t&lt;&lt;endl,<span class="built_in">void</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-语言学习中"><a href="#E-语言学习中" class="headerlink" title="E 语言学习中"></a>E 语言学习中</h3><p><img src="https://s2.loli.net/2024/03/31/BfKLgsRpVimIlYM.png#id=gNfqR&amp;originHeight=1146&amp;originWidth=932&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt><br>对于 100%100% 的数据，1≤∣S∣,∣T∣≤10^5,1≤q≤10^6.<br>样例一</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">H</span><br><span class="line">X</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><p>样例二</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XXXHHHHXH</span><br><span class="line">XXXXH</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">7</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">7</span> <span class="number">9</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p>一开始看这范围还以为要什么数据结构。其实就是一个前缀和问题。<br>因为一个X能变成两个H，不妨将所有的X都变成H最后只要判断区间内有多少个H就行，如果s和t之间H相差的位数能够被3整除，那么就一定是合法的因为题目说了可以在任意的地方删掉三个H。</p><p>令sum1[i]表示s的i位之前有多少个H，sum2[i]表示t的i位之前有多少个H，跑一遍前缀和然后判断即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s, t;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum1</span><span class="params">(<span class="number">100001</span>)</span>, <span class="title">sum2</span><span class="params">(<span class="number">100001</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">sum1[i] = sum1[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;H&#x27;</span>)sum1[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">sum2[i] = sum2[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (t[i - <span class="number">1</span>] == <span class="string">&#x27;H&#x27;</span>)sum2[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="type">int</span> l1, r1, l2, r2, len1, len2, h1, h2;</span><br><span class="line">cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;</span><br><span class="line">len1 = r1 - l1 + <span class="number">1</span>, len2 = r2 - l2 + <span class="number">1</span>;</span><br><span class="line">h1 = sum1[r1] - sum2[l1 - <span class="number">1</span>];</span><br><span class="line">h2 = sum2[r2] - sum2[l2 - <span class="number">1</span>];</span><br><span class="line">len1 -= h1, len2 -= h2;</span><br><span class="line">h1 += len1 * <span class="number">2</span>;</span><br><span class="line">h2 += len2 * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(h1 - h2) % <span class="number">3</span> == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="G-随机汉堡店"><a href="#G-随机汉堡店" class="headerlink" title="G 随机汉堡店"></a>G 随机汉堡店</h3><p><img src="https://s2.loli.net/2024/03/31/ZXjtgbI7rdLJ4Qi.png#id=igIZV&amp;originHeight=906&amp;originWidth=918&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt><br>样例一</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">5</span> <span class="number">5</span> <span class="number">2</span> </span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">10</span> <span class="number">9</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31</span></span><br></pre></td></tr></table></figure><p>样例二</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">4</span> </span><br><span class="line"><span class="number">7</span> <span class="number">9</span> <span class="number">8</span> <span class="number">5</span> <span class="number">6</span> </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><p>对于所有的数据，$2≤p≤n≤10^6,1≤k≤10^6,1≤t_x≤k,1≤d_x≤10^9$。</p><p>一个很简单的dp。不知道为啥B题的博弈论要过的人多感觉B难多了。</p><p><code>dp[i]</code>表示当前第i个食材以及前面所有的食材能够达到的最大值。那么第i号点只能由前面的和i号位置的这个食材种类相同的食材转移过来，也就是<br>$dp[i] = max(dp[i],dp[j-1] + \sum_{k = j}^id[k])$<br>其中j是在i之前的所有和i种类相同的食材所在的位置，也就是说在位置是j-1的以及所有在j-1前面的位置能达到的最大值加上j-i都作为一个汉堡的食材能达到的最大值，一步一步dp过去即可。<br>转移方程里面的求和可以用前缀和优化。<br>需要注意的是题目有个条件是食材数量不能小于p，所以枚举的j要满足i-j+1&gt;=p。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k, p;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; p;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">t</span><span class="params">(n+<span class="number">5</span>)</span>,<span class="title">d</span><span class="params">(n+<span class="number">5</span>)</span>,<span class="title">dp</span><span class="params">(n+<span class="number">5</span>)</span>,<span class="title">sum</span><span class="params">(n+<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="comment">// num记录t[i]的位置</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">num</span>(n+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; t[i],num[t[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; d[i],sum[i] = sum[i - <span class="number">1</span>] + d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j: num[t[i]]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == i)<span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> len = i - j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(len&lt;p)<span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i], dp[j - <span class="number">1</span>] + sum[i] - sum[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-客气小孩哥"><a href="#B-客气小孩哥" class="headerlink" title="B 客气小孩哥"></a>B 客气小孩哥</h3><p><img src="https://s2.loli.net/2024/03/31/ur3W1niV7Q9s2Ly.png#id=Zp0sx&amp;originHeight=750&amp;originWidth=935&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt><br>样例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alice</span><br></pre></td></tr></table></figure><p>为什么不好好出题面呢。</p><p>比赛一直以为样例里面Alice是哭的那个，后来评论说是Alice没哭……只能说这个题面不好评价<br><img src="https://s2.loli.net/2024/03/31/bTuwZDSBvo8nGli.png#id=rRDxt&amp;originHeight=177&amp;originWidth=330&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt><br>有空再补吧</p>]]></content>
      
      
      <categories>
          
          <category> 小比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cdpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023JSCPC</title>
      <link href="/2024/03/26/2023JSCPC/"/>
      <url>/2024/03/26/2023JSCPC/</url>
      
        <content type="html"><![CDATA[<p>这个也是当年的湖南全国邀请赛</p><h3 id="I-Elevator"><a href="#I-Elevator" class="headerlink" title="I Elevator"></a>I <a href="https://codeforces.com/gym/104396/problem/I">Elevator</a></h3><p> 电梯里有 n 个人（你是其中一个），这些人想去 m 个楼层， 每个人只想去一个楼层。到达一个楼层，所有想去这个楼层 的人都会下电梯。问在你想去的楼层最多有多少人下电梯。  </p><p>vp的时候题目根本没读懂，感觉就是输出 n − (m − 1) ， 交了一发就过了……</p><h3 id="J-Similarity-Easy-Version"><a href="#J-Similarity-Easy-Version" class="headerlink" title="J Similarity (Easy Version)"></a>J <a href="https://codeforces.com/gym/104396/problem/J">Similarity (Easy Version)</a></h3><p> 给定 n 个串，求两两之间最长公共子串的最大值。<br>多测T不超过15，字符串长度不超过50，个数也不超过50。并保证n的总和不会超过300。<br>直接暴力匹配即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt;f;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        map&lt;string,<span class="type">bool</span>&gt;vis;</span><br><span class="line">        <span class="built_in">per</span>(j,<span class="number">0</span>,s.<span class="built_in">length</span>()<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">per</span>(len,<span class="number">1</span>,s.<span class="built_in">length</span>())</span><br><span class="line">                <span class="keyword">if</span>(j+len&lt;=s.<span class="built_in">length</span>())</span><br><span class="line">                    <span class="keyword">if</span>(!vis[s.<span class="built_in">substr</span>(j,len)])&#123;</span><br><span class="line">                        vis[s.<span class="built_in">substr</span>(j,len)]=<span class="literal">true</span>;</span><br><span class="line">                        f[s.<span class="built_in">substr</span>(j,len)]++;</span><br><span class="line">                    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:f)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,(<span class="type">int</span>)x.<span class="built_in">length</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    f.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H-Neil’s-Machine"><a href="#H-Neil’s-Machine" class="headerlink" title="H Neil’s Machine"></a>H <a href="https://codeforces.com/gym/104396/problem/H">Neil’s Machine</a></h3><p> 有两个长度为 n, 数值为 0 − 25 的数组 S, T。每次操作可 以选择一个正数 k (1 ≤ k ≤ 25), 并选择 S 的一个后缀加 k 模 26，问至少几次操作可以令 S = T。<br>直接贪心因为迟早是要变掉的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s1,s2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">    <span class="type">int</span> ti=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        ti%=<span class="number">26</span>;</span><br><span class="line">        <span class="type">int</span> x=s1[i]-<span class="string">&#x27;a&#x27;</span>,y=s2[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        x+=ti;</span><br><span class="line">        x%=<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;x)ti+=y-x,sum++;</span><br><span class="line">        <span class="keyword">else</span> ti+=(<span class="number">26</span>+y-x),sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-Today’s-Word"><a href="#A-Today’s-Word" class="headerlink" title="A Today’s Word"></a>A <a href="https://codeforces.com/gym/104396/problem/A">Today’s Word</a></h3><p>你接受了 VortaroEnMano 公司的聘用，这是一家致力于创建最全面的世界语词典的公司。世界语是一种非常难学的语言，所以你非常努力地工作—主要是为了在就业低迷的情况下保住工作。<br>今天，你的任务是重构名为 “Hodiaŭa Vorto “的函数，即英文中的 “Today’s Word”。这个单词由一个字符串生成，用 $S_k$ 表示。<br>下面是 $S_k$ 的生成过程：</p><ol><li>生成过程从给定的初始字符串 $S_0$ 开始。该字符串只包含小写英文字母，长度为偶数。</li><li>对于 $n \ge 1$ ， $S_n$ 的生成方式如下： $S_n=S_{n-1}[0\ldots \frac{l}{2}-1]+S_{n-1}+\text{next}(S_{n-1}[\frac{l}{2}\ldots l-1])$ ，其中 $l$ 是 $S_{n-1}$ 的长度， $+$ 用于连接字符串。注意，字符串的索引从 $0$ 开始。</li></ol><p>函数 $\text{next}(S)$ 将字符串 $S$ 中的每个字符递增到字母表中的下一个字母，即 $\texttt{a}$ 变为 $\texttt{b}$ ， $\texttt{b}$ 变为 $\texttt{c}$ ，以此类推， $\texttt{z}$ 变为 $\texttt{a}$ 。例如， $\text{next}(\texttt{abz})=\texttt{bca}$ 。<br>您的任务是确定长度为 $m$ 的 $S_{10^{100}}$ 的后缀。<br>10的100次这个数字显然是模拟不了的，很容易就发现长度到达2*m之后是按照26次进行一次循环，所以直接预处理出10的100次幂是多少，得在模26下答案是16，所以加上之前变成长度为2m要用到的次数最多进行16次即可，由于有可能超过16次，不妨取大一些的16的倍数，比如224这个就绝对没有问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">string <span class="title">next</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">per</span>(i,<span class="number">0</span>,s.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;z&#x27;</span>)s[i]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> s[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> used;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"> </span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">length</span>()&lt;<span class="number">2</span>*m)&#123;<span class="comment">//确定了后面m个</span></span><br><span class="line">        string l=s.<span class="built_in">substr</span>(<span class="number">0</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        string r=<span class="built_in">next</span>(s.<span class="built_in">substr</span>(s.<span class="built_in">length</span>()/<span class="number">2</span>));</span><br><span class="line"> </span><br><span class="line">        s=l+s+r;</span><br><span class="line"> </span><br><span class="line">        used++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    s=s.<span class="built_in">substr</span>(s.<span class="built_in">length</span>()-m);<span class="comment">//后m个,已经变换used次</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(used&lt;<span class="number">224</span>)s=<span class="built_in">next</span>(s),used++;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K-Similarity-Hard-Version"><a href="#K-Similarity-Hard-Version" class="headerlink" title="K Similarity (Hard Version)"></a>K <a href="https://codeforces.com/gym/104396/problem/K">Similarity (Hard Version)</a></h3><p>交给队友自己去写F了结果没调出来，有空补</p><h3 id="F-Timaeus"><a href="#F-Timaeus" class="headerlink" title="F Timaeus"></a>F <a href="https://codeforces.com/gym/104396/problem/F">Timaeus</a></h3><p>蒂迈厄斯是蒙德施塔特的一名初露头角的炼金术士，他的导师阿尔贝多给他布置了一项任务。合成一种特殊的炼金术产品：大甜花。然而，由于他的技能有限，蒂迈厄斯只能通过在一次合成中组合 B 个小甜花来创造一朵大甜花。因此，他得到了两个帮手的帮助：佐藤和莫娜。<br>佐藤有一种提高生产率的诀窍，在一次合成中有P%可能产生两倍的产量。这意味着通过在单个合成中组合 B 个小甜花来产生两个大的甜花。<br>另一方面，莫纳有保护资源的诀窍。在该过程中以概率 Q% 取回一朵正常的香花，其意味着通过将 B 规则的香花组合在一起，生产一朵大的香花，同时回收一朵规则的香花单合成。<br>然而，蒂迈厄斯每次合成只能选择一个助手。从总共 A个常规甜花开始，蒂迈厄斯的目标是最大限度地增加他所能生产的大型甜花的期望数量。<br>因此，他必须为每个合成在助手佐藤和莫娜之间做出最佳选择。请计算他能生产的大香花的最大预期数量。</p><p>一道简单的期望dp。<br>简化一下题意，其实就是每次选一个助手，助手一有P%的概率在消耗B单位个代价产生的贡献变成2（注意是变成2不是加上2）；助手二可以有Q%的概率在消耗B单位个代价的时候减少1的代价产生1的贡献。<br>否则就是产生1的贡献。<br>首先由于每次必须要选一个人作为助手，那么对于这一道题，只有消耗的原料数量是需要保存的状态。<br>用dp[i]表示当前用了几朵花，那么可以由转移方程：<br><code>dp[i] = max( P * (dp[i - b] + 2) + (1 - P) * (dp[i - b] + 1),Q * (dp[i - b + 1] + 1) + (1 - Q) * (dp[i - b] + 1));</code><br>得到，dp[n]即是答案。<br>需要注意的是，如果b等于1，那么转移方程就有问题，max中的第二个元素变成了:<br><code>Q * (dp[i] + 1) + (1 - Q) * (dp[i - 1] + 1));</code><br>由于dp[i]是要求的，这显然是不合法的，那么对这个转移方程移项变形得：<br><code>dp[i] = Q * (dp[i] + 1) + (1 - Q) * (dp[i - 1] + 1));</code> -&gt; <code>dp[i] = dp[i-1] + 1/(1-Q)</code><br>如果对第一个式子也进行化简，那么原式可以转化为：<br><code>dp[i] = max(dp[i - 1] + P + 1,dp[i-1] + 1/(1-Q));</code><br>然后就可以递推了。<br>实际上观察这个式子可以发现通项是一个过零点的一条直线，那么可以证明最重的答案一定是斜率较大（即max(p+1,1/(1-Q)）的那一条线对应的通项。所以判断一下大小就可以做到O(1)回答。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, p, q;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; p &gt;&gt; q;</span><br><span class="line"><span class="type">double</span> P = p / <span class="number">100.0</span>, Q = q / <span class="number">100.0</span>;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">double</span> diff1 = P + <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> diff2 = <span class="number">1.0</span> / (<span class="number">1.0</span> - Q);</span><br><span class="line"><span class="comment">//for (int i = b; i &lt;= a; ++i)</span></span><br><span class="line"><span class="comment">//dp[i] = max(dp[i - 1] + diff1, dp[i-1]+diff2);</span></span><br><span class="line"><span class="type">double</span> maxn = <span class="built_in">max</span>(diff1, diff2);</span><br><span class="line">cout &lt;&lt; maxn*(a - b + <span class="number">1.0</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dp</span><span class="params">(a + b + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = b; i &lt;= a; ++i) </span><br><span class="line">dp[i] = <span class="built_in">max</span>( P * (dp[i - b] + <span class="number">2</span>) + (<span class="number">1</span> - P) * (dp[i - b] + <span class="number">1</span>),</span><br><span class="line">             Q * (dp[i - b + <span class="number">1</span>] + <span class="number">1</span>) + (<span class="number">1</span> - Q) * (dp[i - b] + <span class="number">1</span>));</span><br><span class="line">cout &lt;&lt; dp[a] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6题全开出来还是有机会银牌的</p>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 江苏 </tag>
            
            <tag> 湖南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022SHCPC</title>
      <link href="/2024/03/26/2022SHCPC/"/>
      <url>/2024/03/26/2022SHCPC/</url>
      
        <content type="html"><![CDATA[<h3 id="N-Nine-Is-Greater-Than-Ten"><a href="#N-Nine-Is-Greater-Than-Ten" class="headerlink" title="N Nine Is Greater Than Ten"></a>N <a href="https://codeforces.com/gym/103931/problem/N">Nine Is Greater Than Ten</a></h3><p>按字典序比较字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">string a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="type">int</span> res = a.<span class="built_in">compare</span>(b);</span><br><span class="line"><span class="keyword">if</span>(res == <span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(res &lt; <span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;<span class="string">&#x27;&lt;&#x27;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">else</span> cout&lt;&lt;a&lt;&lt;<span class="string">&#x27;&gt;&#x27;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="G-Gua"><a href="#G-Gua" class="headerlink" title="G Gua!"></a>G <a href="https://codeforces.com/gym/103931/problem/G">Gua!</a></h3><p>题意：<br>给你四个参数B R D S,表示枪的一发子弹造成的最大伤害，射速为每分钟射击R次，玩家一共造成了D点伤害，用时S秒，问你这个人是不是挂。<br>不是很懂为什么签到题出这么细节的模拟……vp爆wa心态都炸了<br>三个细节，<br>第一个是由于时间是从0开始算的，打出去的子弹数还要在加上1。<br>第二个是如果这把武器的射速是0，那么玩家造成伤害了就一定是挂。<br>第三个是如果武器要对射出去的子弹数向下取整，那么就是<code>R*S/60</code>，注意在这里<code>R/60*S</code>是错的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b, r, d, s;</span><br><span class="line">cin &gt;&gt; b &gt;&gt; r &gt;&gt; d &gt;&gt; s;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span> || b == <span class="number">0</span>) </span><br><span class="line"><span class="keyword">if</span> (d) <span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;gua!&quot;</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line"><span class="keyword">if</span> ((r * s / <span class="number">60</span> + <span class="number">1</span>) * b &lt; d) cout &lt;&lt; <span class="string">&quot;gua!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H-Heirloom-Painting"><a href="#H-Heirloom-Painting" class="headerlink" title="H Heirloom Painting"></a>H <a href="https://codeforces.com/gym/103931/problem/H">Heirloom Painting</a></h3><p> 艺术大师咖波有一个绘画机器人，用来帮助他制作一些精美的艺术品。 这天，咖波画了一个圆环，并将其分割成了 n 个格子。咖波总共调制了 m 种颜色，他希望用这些颜色 给圆环涂上色，从而画成一件新的艺术品。然而，当初出于成本的考虑，他的绘画机器人有很多技术上 的限制，比如的喷嘴是一个年久失修的传家宝，这导致他的机器人每次只能给连续的恰好 k 个格子涂上 颜色。幸好机器人使用的颜料并不会因为重复覆盖同一个格子而混合——后面涂上的颜色将取代此前的 颜色。 现在，咖波想知道他的机器人最少需要涂多少次颜色才能将这个圆环画成他想要的样子。当然，也有可 能他的笨笨机器人其实没法完成任务。<br> 对于每组数据，输出一行包含一个整数，表示机器人最少涂色次数。如果机器人无法完成任务，输出 −1。  </p><p>大概就是一个模拟，首先考虑什么时候无解：<br>显然，最终序列如果没有长度为k个的连续的颜色，那么一定是无解的<br>否则，就把相同颜色的连续位置合并成一个元素，记录连续的块数，然后就贪心的去染色，令连续的数量是cnt，那么喷的次数就是cnt/k + (cnt%k != 0)。<br>注意因为是一个环，所以要判断最后一个色块的颜色和第一个是不是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;c[i];</span><br><span class="line"></span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>,2&gt;&gt;v;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i]!=c[i<span class="number">-1</span>])&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(&#123;c[i<span class="number">-1</span>],cnt&#125;);</span><br><span class="line">cnt=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(&#123;c[n],cnt&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断最后一个色块的颜色和第一个是不是一样</span></span><br><span class="line"><span class="keyword">if</span>(v.<span class="built_in">size</span>()&gt;=<span class="number">2</span> <span class="keyword">and</span> v[v.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>]==v[<span class="number">0</span>][<span class="number">0</span>])&#123;</span><br><span class="line">v[<span class="number">0</span>][<span class="number">1</span>]+=v[v.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> havans=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [color,cnt]:v)</span><br><span class="line"><span class="keyword">if</span>(cnt&gt;=k)</span><br><span class="line">havans=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(havans==<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl,<span class="built_in">void</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [color,cnt]:v)</span><br><span class="line">ans += cnt/k + (cnt%k != <span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-Another-A-B-Problem"><a href="#A-Another-A-B-Problem" class="headerlink" title="A Another A+B Problem"></a>A <a href="https://codeforces.com/gym/103931/problem/A">Another A+B Problem</a></h3><p>逆天枚举模拟，队友代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> per(i, j, k) for(int (i)=(j);(i)&lt;=(k);++(i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, j, k) for(int (i)=(j);(i)&gt;=(k);--(i))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[<span class="number">7</span>];<span class="comment">//1~6位置上必须是哪些数,-1为不固定</span></span><br><span class="line"><span class="type">int</span> canot[<span class="number">7</span>];<span class="comment">//1~6位置上,不能放</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> purple[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> black[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> leave[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string E, C;</span><br><span class="line">    cin &gt;&gt; E &gt;&gt; C;</span><br><span class="line"></span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    s += <span class="string">&quot;O&quot;</span>, s += C[<span class="number">0</span>], s += C[<span class="number">1</span>], s += C[<span class="number">3</span>], s += C[<span class="number">4</span>], s += C[<span class="number">6</span>], s += C[<span class="number">7</span>];</span><br><span class="line">    C = s;</span><br><span class="line">    s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    s += <span class="string">&quot;O&quot;</span>, s += E[<span class="number">0</span>], s += E[<span class="number">1</span>], s += E[<span class="number">3</span>], s += E[<span class="number">4</span>], s += E[<span class="number">6</span>], s += E[<span class="number">7</span>];</span><br><span class="line">    E = s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">per</span>(i, <span class="number">1</span>, <span class="number">6</span>) num[i] = canot[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">per</span>(i, <span class="number">1</span>, <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (C[i] == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">            num[i] = E[i] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//当前等式确定</span></span><br><span class="line">            leave[E[i] - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (C[i] == <span class="string">&#x27;P&#x27;</span>) &#123;</span><br><span class="line">            canot[i] = E[i] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//i位置不能是</span></span><br><span class="line">            leave[E[i] - <span class="string">&#x27;0&#x27;</span>]++;<span class="comment">//等式中一定要有</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//B,当前位置不能是,如果没有leave,则等式中不能有</span></span><br><span class="line">            canot[i] = E[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            black[E[i] - <span class="string">&#x27;0&#x27;</span>] = <span class="literal">true</span>;<span class="comment">//标记为黑色</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 6&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">per</span>(i, <span class="number">0</span>, <span class="number">9</span>)<span class="built_in">per</span>(j, <span class="number">0</span>, <span class="number">9</span>)<span class="built_in">per</span>(k, <span class="number">0</span>, <span class="number">9</span>)<span class="built_in">per</span>(l, <span class="number">0</span>, <span class="number">9</span>)<span class="built_in">per</span>(m, <span class="number">0</span>, <span class="number">9</span>)<span class="built_in">per</span>(n, <span class="number">0</span>, <span class="number">9</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (i * <span class="number">10</span> + j + k * <span class="number">10</span> + l == m * <span class="number">10</span> + n) &#123;<span class="comment">//是否满足题目要求</span></span><br><span class="line">                                <span class="keyword">if</span> (i == canot[<span class="number">1</span>])<span class="keyword">goto</span> nxt;</span><br><span class="line">                                <span class="keyword">if</span> (j == canot[<span class="number">2</span>])<span class="keyword">goto</span> nxt;</span><br><span class="line">                                <span class="keyword">if</span> (k == canot[<span class="number">3</span>])<span class="keyword">goto</span> nxt;</span><br><span class="line">                                <span class="keyword">if</span> (l == canot[<span class="number">4</span>])<span class="keyword">goto</span> nxt;</span><br><span class="line">                                <span class="keyword">if</span> (m == canot[<span class="number">5</span>])<span class="keyword">goto</span> nxt;</span><br><span class="line">                                <span class="keyword">if</span> (n == canot[<span class="number">6</span>])<span class="keyword">goto</span> nxt;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (num[<span class="number">1</span>] != <span class="number">-1</span> <span class="keyword">and</span> num[<span class="number">1</span>] != i)<span class="keyword">goto</span> nxt;</span><br><span class="line">                                <span class="keyword">if</span> (num[<span class="number">2</span>] != <span class="number">-1</span> <span class="keyword">and</span> num[<span class="number">2</span>] != j)<span class="keyword">goto</span> nxt;</span><br><span class="line">                                <span class="keyword">if</span> (num[<span class="number">3</span>] != <span class="number">-1</span> <span class="keyword">and</span> num[<span class="number">3</span>] != k)<span class="keyword">goto</span> nxt;</span><br><span class="line">                                <span class="keyword">if</span> (num[<span class="number">4</span>] != <span class="number">-1</span> <span class="keyword">and</span> num[<span class="number">4</span>] != l)<span class="keyword">goto</span> nxt;</span><br><span class="line">                                <span class="keyword">if</span> (num[<span class="number">5</span>] != <span class="number">-1</span> <span class="keyword">and</span> num[<span class="number">5</span>] != m)<span class="keyword">goto</span> nxt;</span><br><span class="line">                                <span class="keyword">if</span> (num[<span class="number">6</span>] != <span class="number">-1</span> <span class="keyword">and</span> num[<span class="number">6</span>] != n)<span class="keyword">goto</span> nxt;</span><br><span class="line"></span><br><span class="line">                                <span class="type">int</span> now[<span class="number">10</span>];</span><br><span class="line">                                <span class="built_in">per</span>(o, <span class="number">0</span>, <span class="number">9</span>)now[o] = <span class="number">0</span>;</span><br><span class="line">                                now[i]++, now[j]++, now[k]++, now[l]++, now[m]++, now[n]++;</span><br><span class="line"></span><br><span class="line">                                <span class="built_in">per</span>(o, <span class="number">0</span>, <span class="number">9</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (black[o] <span class="keyword">and</span> !leave[o]) &#123;<span class="comment">//等式中不能有</span></span><br><span class="line">                                        <span class="keyword">if</span> (now[o])<span class="keyword">goto</span> nxt;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="built_in">per</span>(o, <span class="number">0</span>, <span class="number">9</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (black[o] <span class="keyword">and</span> leave[o]) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (now[o] != leave[o])<span class="keyword">goto</span> nxt;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="built_in">per</span>(o, <span class="number">0</span>, <span class="number">9</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (!black[o] <span class="keyword">and</span> leave[o]) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (now[o] &lt; leave[o])<span class="keyword">goto</span> nxt;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                ans.<span class="built_in">push_back</span>(&#123;i, j, k, l, m, n&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                            nxt:</span><br><span class="line">                            &#123;&#125;;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">per</span>(i, <span class="number">0</span>, ans.<span class="built_in">size</span>() - <span class="number">1</span>)cout &lt;&lt; ans[i][<span class="number">0</span>] &lt;&lt; ans[i][<span class="number">1</span>] &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; ans[i][<span class="number">2</span>] &lt;&lt; ans[i][<span class="number">3</span>] &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; ans[i][<span class="number">4</span>]</span><br><span class="line">                                  &lt;&lt; ans[i][<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//11+22=33</span></span><br><span class="line">    <span class="comment">//PBGPPGGP</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1只能有一个, 2一定有两个, 3有一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Expenditure-Reduction"><a href="#E-Expenditure-Reduction" class="headerlink" title="E Expenditure Reduction"></a>E <a href="https://codeforces.com/gym/103931/problem/E">Expenditure Reduction</a></h3><p>为了让你的钱更充裕，与其赚更多的钱，不如减少支出。<br>顺平是一家会员制餐厅的经理。由于受到大流行病的影响，餐厅无法负担过多的美味佳肴。于是，如何在保留特色菜的同时减少菜单就成了一个问题。<br>菜单可以看作是一个只包含小写英文字母和数字的字符串 $S$ ，而顺平认为餐厅的核心特色是一个字符串 $F$ ，它目前是 $S$ 的子串。为了减少菜单，您可以将 $S$ 减少到其子串 $S’$ 中的一个，同时保留 $F$ 作为 $S’$ 的子串。Junpei 要求你从 $S$ 中找出满足要求的最短子串 $S’$ 。<br>对于那些可能对子序列和子串的定义感到好奇的人，请考虑两个非空字符串 $A, B$ ：</p><ul><li>如果我们说 $A$ 是 $B$ 的子串，那么我们可以找到一组 $|A|$ 指数 $\{i_k\}$ ，其中 $1 \leq i_1 &lt; i_2 &lt; \dots &lt; i_{|A|} \leq |B|$ ，这样就有 $A = B_{i_1}B_{i_2}\dots B_{i_{|A|}}$ 。</li><li>如果我们说 $A$ 是 $B$ 的子串，那么我们可以从 $B$ 中删除一个（可能为空）前缀和一个（可能为空）后缀，从而得到 $A$ 。</li></ul><p>显然可以开一个数组存储当前位置以后的字符c的最早出现的位置，然后枚举起始位置即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s, t;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line"><span class="type">int</span> lens = <span class="built_in">si</span>(s), lent = <span class="built_in">si</span>(t);</span><br><span class="line">s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">t = <span class="string">&#x27; &#x27;</span> + t;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; nxtchar = <span class="built_in">vector</span>(lens + <span class="number">5</span>, <span class="built_in">vector</span>(<span class="number">26</span>, lens + <span class="number">1</span>));</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; nxtnum = <span class="built_in">vector</span>(lens + <span class="number">5</span>, <span class="built_in">vector</span>(<span class="number">10</span>, lens + <span class="number">1</span>));</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; h;</span><br><span class="line"><span class="keyword">auto</span> isnum = [&amp;](<span class="type">char</span> c)-&gt;<span class="type">bool</span>&#123;<span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;&#125;;</span><br><span class="line"><span class="keyword">auto</span> ischar = [&amp;](<span class="type">char</span> c)-&gt;<span class="type">bool</span>&#123; <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>;&#125;;</span><br><span class="line">    <span class="comment">// 预处理每个位置的下一个位置上出现字符j的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = lens; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == t[<span class="number">1</span>]) h.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) </span><br><span class="line">nxtnum[i][j] = nxtnum[i + <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) </span><br><span class="line">nxtchar[i][j] = nxtchar[i + <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ischar</span>(s[i])) nxtchar[i][s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line"><span class="keyword">else</span> nxtnum[i][s[i] - <span class="string">&#x27;0&#x27;</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1e18</span>, le = <span class="number">0</span>, ri = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lens; ++i) &#123;</span><br><span class="line">        <span class="comment">// 如果当前位置是和t字符串的第一个位置一样</span></span><br><span class="line"><span class="keyword">if</span> (s[i] == t[<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="type">int</span> k, l = i, cur = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= lent; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isnum</span>(t[j])) &#123;</span><br><span class="line">k = t[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">cur = nxtnum[cur + <span class="number">1</span>][k];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">k = t[j] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cur = nxtchar[cur + <span class="number">1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur == lens + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> r = cur;</span><br><span class="line"><span class="keyword">if</span> (r != lens + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span> res = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (ans &gt; res) &#123;</span><br><span class="line">le = l, ri = r;</span><br><span class="line">ans = res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">substr</span>(le, ri - le + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="M-My-University-Is-Better-Than-Yours"><a href="#M-My-University-Is-Better-Than-Yours" class="headerlink" title="M My University Is Better Than Yours"></a>M <a href="https://codeforces.com/gym/103931/problem/M">My University Is Better Than Yours</a></h3><p>假设总共有 $n$ 所大学，他收集了 $m$ 个大学排名。为简单起见，所有大学都用一个从 $1$ 到 $n$ 的数字表示。定义，当且仅当存在一个大学排名，使得大学 $x$ 的排名高于大学 $y$ 时，大学 $x$ <strong>直接优于大学 </strong>$y$<strong> 。</strong>此外，当且仅当存在一个序列 $\{s_1,\ s_2,\ …,\ s_k\}$ ( $k\ge 2$ )，使得大学 $x$ 排名高于大学 $y$ 时，大学 $x$ 就<strong>优于</strong>大学 $y$ ：</p><ul><li>$s_1=x,\ s_k=y$</li><li>$\forall i\in \{1, 2, \dots, k - 1\}$ ，大学 $s_i$ <strong>直接优于</strong>大学 $s_{i+1}$ 。</li></ul><p>对于每所大学，需要回答这所大学比其他多少所大学好。</p><p>可以发现对于这个直接优于是一种有向关系，并且题目的范围保证了n<em>m不会超过1e6，那么这个是一个很明显的提示了，对于每一个排名，都按照直接优于的关系建边，边数是n</em>m，能够存的下。<br>那么比如第一个样例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><p>表示1-&gt;2,2-&gt;3,3-&gt;4,1-&gt;3,3-&gt;2,2-&gt;4。画出图形之后再和答案比较，按照图的关系简化一下优于的定义，就是表示如果X优于Y，那么存在一条路径使得X可以到达Y，所以应该和图的连通性有关。</p><p>所以只要知道这个有向图中X这个点能够到达哪些点即可。很容易就想到按照强联通分量缩点，并且可以证明的是缩点后的DAG一定是一条链，所以按反图的拓扑序遍历就是答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Tarjan</span> &#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> n&#123;&#125;, m&#123;&#125;, idx&#123;&#125;, cnt&#123;&#125;;</span><br><span class="line"><span class="type">int</span> dfn[N] &#123;&#125;, low[N] &#123;&#125;, bel[N] &#123;&#125;;</span><br><span class="line">bitset&lt;N&gt; ins&#123;&#125;;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; scc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++idx;</span><br><span class="line">ins[u] = <span class="literal">true</span>;</span><br><span class="line">stk.<span class="built_in">push</span>(u);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!dfn[v]) <span class="built_in">dfs</span>(v);</span><br><span class="line"><span class="keyword">if</span> (ins[v]) low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">++cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">int</span> v = stk.<span class="built_in">top</span>();</span><br><span class="line">c.<span class="built_in">push_back</span>(v);</span><br><span class="line">ins[v] = <span class="literal">false</span>;</span><br><span class="line">bel[v] = cnt;</span><br><span class="line">stk.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (v == u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">scc.<span class="built_in">push_back</span>(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tarjan tarjan;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">tarjan.n = n, tarjan.m = m*n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="type">int</span> pre;</span><br><span class="line">cin&gt;&gt;pre;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j&lt;=n;++j)&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">tarjan.e[pre].<span class="built_in">push_back</span>(t);</span><br><span class="line">pre = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (!tarjan.dfn[i]) tarjan.<span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : tarjan.scc)&#123;</span><br><span class="line"><span class="type">int</span> tot = <span class="built_in">si</span>(it);</span><br><span class="line">ans += tot - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : it) res[i] = ans;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; \n&quot;</span>[i == n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常板子的题，去掉tarjan板子只有10行左右是自己写的</p>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 上海 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整除分块</title>
      <link href="/2024/03/16/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/"/>
      <url>/2024/03/16/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>好像只能用来解决一个类似于$\sum^n_{i = 1}\left \lfloor \frac{n}{i}  \right \rfloor$这样的整数求和问题，只要是带这个的，那么复杂度最低就能降到根号级别的。<br>可以发现，比如n =  8这个求和的每一项是这样的</p><div class="table-container"><table><thead><tr><th>i</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>8/i</td><td>8</td><td>4</td><td>2</td><td>2</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>那么就可以优化，把结果一样的放在一起分块处理。<br>分的块大概有$2\sqrt{n}$个，因为当i小于等于$\sqrt{n}$时，取值一共有$\sqrt{n}$种，大于也是一样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; ++l) &#123;</span><br><span class="line"><span class="type">int</span> d = n / l, r = n/d;</span><br><span class="line">ans += (r-l+<span class="number">1</span>)*d;</span><br><span class="line">l = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>l和r表示这个区间内的数x除n都是d，即<code>n/x = d</code>，累加即可，复杂度是根号的。</p><h3 id="CQOI2007-余数求和"><a href="#CQOI2007-余数求和" class="headerlink" title="[CQOI2007] 余数求和"></a><a href="https://www.luogu.com.cn/problem/P2261">[CQOI2007] 余数求和</a></h3><p>给出正整数 $n$ 和 $k$，请计算<br>$G(n, k) = \sum_{i = 1}^n k \bmod i$<br>其中 $k\bmod i$ 表示 $k$ 除以 $i$ 的余数。<br>因为<code>k mod i = k - (k/i)*i</code>,考虑整除分块。因为(k/i)是等于d的，所以在l和r之间是一个等差数列，然后对着等差数列求和即可。<br>分两种情况，第一种n小于等于k，那就直接做就行。注意r不能大于n，所以还要和n取min。<br>第二种是n大于k，那么推一下式子：</p><script type="math/tex; mode=display">G(n, k) = \sum_{i = 1}^n k \bmod i = \sum_{i = 1}^n k-\left \lfloor \frac{k}{i}  \right \rfloor *i=nk - \sum_{i = 1}^n\left \lfloor \frac{k}{i}  \right \rfloor *i=nk-\sum_{i = 1}^k\left \lfloor \frac{k}{i}  \right \rfloor *i - \sum_{i = k+1}^n\left \lfloor \frac{k}{i}  \right \rfloor *i  = nk - \sum_{i = 1}^k\left \lfloor \frac{k}{i}  \right \rfloor *i-0= nk - \sum_{i = 1}^k\left \lfloor \frac{k}{i}  \right \rfloor *i</script><p>做法和第一种类似，或者分开看利用最后一个式子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, k, ans = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= k) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; ++l) &#123;</span><br><span class="line"><span class="type">int</span> d = k / l, r = <span class="built_in">min</span>(n, k / d);</span><br><span class="line">ans += (k - d * l + k - d * r) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">l = r;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= k; ++l) &#123;</span><br><span class="line"><span class="type">int</span> d = k / l, r = k / d;</span><br><span class="line">cnt += (k - d * l + k - d * r) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">l = r;</span><br><span class="line">&#125;</span><br><span class="line">ans = cnt + (n - k) * k;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能以后学积性函数要用到这个</p>]]></content>
      
      
      <categories>
          
          <category> 一些小算法和算法思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整除分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13thSDCPC</title>
      <link href="/2024/03/16/13thSDCPC/"/>
      <url>/2024/03/16/13thSDCPC/</url>
      
        <content type="html"><![CDATA[<p>vp打到后面打不动了，好在压线银牌。</p><h3 id="SDCPC2023-Matching"><a href="#SDCPC2023-Matching" class="headerlink" title="[SDCPC2023] Matching"></a><a href="https://www.luogu.com.cn/problem/P9562?contestId=126525">[SDCPC2023] Matching</a></h3><p>给定长度为 $n$ 的整数序列 $a_1, a_2, \cdots, a_n$，我们将从该序列中构造出一张无向图 $G$。具体来说，对于所有 $1 \le i &lt; j \le n$，若 $i - j = a_i - a_j$，则 $G$ 中将存在一条连接节点 $i$ 与 $j$ 的无向边，其边权为 $(a_i + a_j)$。<br>求 $G$ 的一个匹配，使得该匹配中所有边的边权之和最大，并输出最大边权之和。<br>请回忆：无向图的匹配，指的是从该无向图中选出一些边，使得任意两条边都没有公共的节点。特别地，不选任何边也是一个匹配。</p><p>考了个常见的转化：$i - j = a_i - a_j$改为$i - a_i = j - a_j$然后把权值一样的放在一起就行。<br>可以开一个<code>map&lt;int,vector&lt;int&gt;&gt;</code>来存储，并且注意到后面压进去的一定是a比较大的，所以从后往前遍历如果两两配对就能找到最大的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; a[i], m[i - a[i]].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [x, v] : m)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = v.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i -= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="type">int</span> k = v[i] + v[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (k &lt;= <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">ans += k;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SDCPC2023-Fast-and-Fat"><a href="#SDCPC2023-Fast-and-Fat" class="headerlink" title="[SDCPC2023] Fast and Fat"></a><a href="https://www.luogu.com.cn/problem/P9559?contestId=126525">[SDCPC2023] Fast and Fat</a></h3><p>您正在参加一场团体越野比赛。您的队伍共有 $n$ 名队员，其中第 $i$ 名队员的速度为 $v_i$，体重为 $w_i$。<br>比赛允许每名队员独立行动，也允许一名队员背着另一名队员一起行动。当队员 $i$ 背着队员 $j$ 时，如果队员 $i$ 的体重大于等于队员 $j$，则队员 $i$ 的移动速度不会变化，仍然为 $v_i$；如果队员 $i$ 的体重小于队员 $j$，则队员 $i$ 的移动速度会减去两者的体重差值，即变为 $v_i - (w_j - w_i)$。如果队员 $i$ 的移动速度将变为负数，则队员 $i$ 无法背起队员 $j$。每名队员最多只能背负另一名队员，被背负的队员无法同时背负其他队员。<br>所有未被背负的队员中，最慢的队员的速度，即为整个队伍的速度。求整个队伍能达到的最大速度。</p><p>经典二分作为铜牌题。<br>这个范围(1≤_n_≤10^5)就已经在提示要用O(nlogn)的复杂度过。<br> 最大化最小值，那么考虑二分。<br>首先二分答案，那么速度这个维度就已经定下来了，考虑把速度v作为已知条件，check函数要求在O(n)时间内判断。<br>那么考虑将队员分为两类，第一类是速度达到要求的，那么他们可以背起最重为$w_i+(v_i-v)$的，速度不达标的队员。先记录$w_i+(v_i-v)$，<br>第二类是速度不达标的，需要达标的队员背。考虑贪心的去背，不达标的最重的交给能背起的重量最大的队员背，那就是一个很明显的排序，排完之后再判断一下是不是合法即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, maxn = <span class="number">-1</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span>, <span class="title">w</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">cin &gt;&gt; v[i] &gt;&gt; w[i],maxn = <span class="built_in">max</span>(maxn, v[i]);</span><br><span class="line"><span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; can, cant;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line"><span class="keyword">if</span> (v[i] &gt;= x) can.<span class="built_in">push_back</span>(w[i] + (v[i] - x));</span><br><span class="line"><span class="keyword">else</span> cant.<span class="built_in">push_back</span>(w[i]);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">si</span>(can) &lt; <span class="built_in">si</span>(cant))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(can), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(cant), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="comment">//debug</span></span><br><span class="line"><span class="comment">//cerr&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//for(auto i: can) cerr&lt;&lt;i&lt;&lt;&quot; \n&quot;[i == can.back()];</span></span><br><span class="line"><span class="comment">//for(auto i: cant) cerr&lt;&lt;i&lt;&lt;&quot; \n&quot;[i == cant.back()];</span></span><br><span class="line"><span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p1&lt;<span class="built_in">si</span>(can) &amp;&amp; p2&lt;<span class="built_in">si</span>(cant))&#123;</span><br><span class="line"><span class="keyword">if</span>(can[p1] &gt;= cant[p2])&#123;</span><br><span class="line">p1++,p2++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p2 == <span class="built_in">si</span>(cant);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = maxn + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;maxn&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>心态崩了：vp的时候思路确实很快就想到了，没想到二分答案写挂了。。右边界一开始定的maxn，后来wa了之后跑了对拍发现是maxn是可以被取到的，所以边界应该是maxn+1，还有没开longlong喜提两次罚时。</p><h3 id="SDCPC2023-Puzzle-Sashigane"><a href="#SDCPC2023-Puzzle-Sashigane" class="headerlink" title="[SDCPC2023] Puzzle: Sashigane"></a><a href="https://www.luogu.com.cn/problem/P9567?contestId=126525">[SDCPC2023] Puzzle: Sashigane</a></h3><p>给定一个 $n$ 行 $n$ 列的网格，网格中包含恰好一个黑色方格，其余方格均为白色。令 $(i, j)$ 表示位于第 $i$ 行第 $j$ 列的格子，这个黑色方格位于 $(b_i, b_j)$。<br>您需要用若干 L 形覆盖所有白色格子，使得每个白色格子都恰好被一个 L 形所覆盖，同时唯一的黑色方格不能被任何 L 形覆盖。L 形不能超过网格的边界。<br>更正式地，网格中的一个 L 形由四个整数 $(r, c, h, w)$ 唯一确定，其中 $(r, c)$ 确定了 L 形的转折点，$h$ 和 $w$ 确定了 L 形两臂的方向和长度。四个整数满足 $1 \le r, c \le n$，$1 \le r + h \le n$，$1 \le c + w \le n$，$h \ne 0$，$w \ne 0$。</p><ul><li>若 $h &lt; 0$，则所有满足 $r + h \le i \le r$ 的格子 $(i, c)$ 均属于该 L 形；否则若 $h &gt; 0$，则所有满足 $r \le i \le r + h$ 的格子 $(i, c)$ 均属于该 L 形。</li><li>若 $w &lt; 0$，则所有满足 $c + w \le j \le c$ 的格子 $(r, j)$ 均属于该 L 形；否则若 $w &gt; 0$，则所有满足 $c \le j \le c + w$ 的格子 $(r, j)$ 均属于该 L 形。</li></ul><p>下图展示了几种 L 形。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/s4jgji61.png#id=HrWNS&amp;originHeight=324&amp;originWidth=532&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt><br>构造模拟题，思路也是很好想的，因为一开始有一个方块已经被填了不能填，所以考虑将它周围的也填上，使填上的位置是一个2*2的方块，然后可以将2*2的周围接着填变成3*3的……所以这样就可以了。可以证明这个一定是有解的。<br>实现的时候可以从外往里去填。<br>队伍里有模拟仙人，讲了思路就扔给队友写了，队友的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,j,k) for(int (i)=(j);(i)&lt;=(k);++(i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,j,k) for(int (i)=(j);(i)&gt;=(k);--(i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EX exit(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,bi,bj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;a,b,c,d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.x&gt;=<span class="number">1</span> <span class="keyword">and</span> x.x&lt;=n <span class="keyword">and</span> x.y&gt;=<span class="number">1</span> <span class="keyword">and</span> x.y&lt;=n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;bi&gt;&gt;bj;</span><br><span class="line">    a=b=c=d=&#123;bi,bj&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>,4&gt;&gt;ans;</span><br><span class="line">    <span class="type">int</span> anscnt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//往右上角填</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        Node nxt=&#123;b.x<span class="number">-1</span>,b.y+<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ok</span>(nxt))&#123;</span><br><span class="line">            b.x--,b.y++;</span><br><span class="line">            d.y++;</span><br><span class="line">            a.x--;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> len=d.x-b.x;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;b.x,b.y,len,-len&#125;);</span><br><span class="line">            anscnt++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//往右下角填</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        Node nxt=&#123;d.x+<span class="number">1</span>,d.y+<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ok</span>(nxt))&#123;</span><br><span class="line">            d.x++,d.y++;</span><br><span class="line">            c.x++;</span><br><span class="line">            b.y++;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> len=d.x-b.x;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;d.x,d.y,-len,-len&#125;);</span><br><span class="line">            anscnt++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//往左上角填</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        Node nxt=&#123;a.x<span class="number">-1</span>,a.y<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ok</span>(nxt))&#123;</span><br><span class="line">            a.x--,a.y--;</span><br><span class="line">            c.y--;</span><br><span class="line">            b.x--;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> len=c.x-a.x;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;a.x,a.y,len,len&#125;);</span><br><span class="line">            anscnt++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//往左下角填</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        Node nxt=&#123;c.x+<span class="number">1</span>,c.y<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ok</span>(nxt))&#123;</span><br><span class="line">            c.x++,c.y--;</span><br><span class="line">            a.y--;</span><br><span class="line">            d.x++;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> len=c.x-a.x;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;c.x,c.y,-len,len&#125;);</span><br><span class="line">            anscnt++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;anscnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:ans)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:i)cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SDCPC2023-Math-Problem"><a href="#SDCPC2023-Math-Problem" class="headerlink" title="[SDCPC2023] Math Problem"></a><a href="https://www.luogu.com.cn/problem/P9560?contestId=126525">[SDCPC2023] Math Problem</a></h3><p>给定两个正整数 $n$ 和 $k$，您可以进行以下两种操作任意次（包括零次）：</p><ul><li>选择一个整数 $x$ 满足 $0 \leq x &lt; k$，将 $n$ 变为 $k\cdot n+x$。该操作每次花费 $a$ 枚金币。每次选择的整数 $x$ 可以不同。</li><li>将 $n$ 变为 $\lfloor \frac{n}{k} \rfloor$。该操作每次花费 $b$ 枚金币。其中 $\lfloor \frac{n}{k} \rfloor$ 表示小于等于 $\frac{n}{k}$ 的最大整数。</li></ul><p>给定正整数 $m$，求将 $n$ 变为 $m$ 的倍数最少需要花费几枚金币，无解输出-1。请注意：$0$ 是任何正整数的倍数。</p><p>比赛没切，有点累剩一个小时吃饭去了。<br>可以发现一定是先除后乘，不然会浪费掉乘法的操作。<br>当时也没细想后来一看这个除法和乘法都是log级别的，那直接枚举就行<br>设除完之后的数是n，那么在经过m次乘法之后，能取到的值是一个区间：$[n^m,n^m+k^m-1]$然后只要判断这个范围内有没有m的倍数即可，做完了。<br>还有就是要开__int128不然会爆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n,k,m,a,b;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k&gt;&gt;m&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(n%m==<span class="number">0</span>) <span class="keyword">return</span> cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl,<span class="built_in">void</span>();</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl,<span class="built_in">void</span>();</span><br><span class="line"><span class="type">int</span> division = <span class="number">1</span>,ans = INT64_MAX,cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!n)&#123;</span><br><span class="line">ans = <span class="built_in">min</span>(ans , cost);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">__int128 l = n , r = n;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l % m &amp;&amp; l / m == r / m)&#123;</span><br><span class="line">r = r*k + k<span class="number">-1</span>;</span><br><span class="line">l *= k;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">min</span>(ans , cost + cnt*a);</span><br><span class="line">n /= k;</span><br><span class="line">cost += b;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先这样吧有空再把GDCPC还有剩下几道金银牌题补了。</p><p>还要加训不然很危险，还剩一个月ZJCPC再炸真就考虑退役了。</p>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 山东 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LGR-174-Div.2】T2、T3</title>
      <link href="/2024/03/04/%E3%80%90LGR-174-Div-2%E3%80%91T2%E3%80%81T3/"/>
      <url>/2024/03/04/%E3%80%90LGR-174-Div-2%E3%80%91T2%E3%80%81T3/</url>
      
        <content type="html"><![CDATA[<h4 id="T2-陌路寻诗礼"><a href="#T2-陌路寻诗礼" class="headerlink" title="T2 陌路寻诗礼"></a>T2 <a href="https://www.luogu.com.cn/problem/P10178?contestId=157909">陌路寻诗礼</a></h4><p>题目描述<br>帆巨所在的家乡的地图是一张有 $n$ 个节点 $m$ 条有向道路的有向图，每个节点都是一个城市，而帆巨所在的城市是 $1$ 号城市，并且 $1$ 号城市总是可以通过若干道路到达其他任何城市。<br>第 $i$ 条道路从 $x_i$ 号城市出发到达 $y_i$ 号城市，长度为 $z_i$。<br>帆帆现在要从他的 $1$ 号城市前往各个城市面基。<br>精通 spfa 算法的帆帆在面基的过程中自然会按照长度和最短的路径去其他城市。<br>但是帆帆有选择困难症，他希望从 $1$ 号城市到达每一座城市的最短路径都是唯一的，所以他决定施加魔法，改变所有道路的长度，具体地：<br>帆巨施加魔法后，对于每一条道路的长度，都可以 <strong>独立地</strong> 将其变成一个 $[1,k]$ 范围内的整数，其中 $k$ 是帆巨的魔法等级。<br>但帆巨所在的世界的地图和他的魔法等级一直在变，总共会变 $T$ 次，所以他希望你对 $T$ 次询问都给出一种构造方法使得帆巨不会纠结或者报告无解。</p><p>输入格式<br>第一行一个整数 $T$ 表示数据组数。<br>接下来 $T$ 组，每组先是三个整数 $n,m,k$，接着 $m$ 行描述有向道路 $(x_i,y_i)$。<br><strong>不保证无自环无重边。</strong><br>输出格式<br>对于每组数据，如果有解，第一行输出 <code>Yes</code>，第二行 $m$ 个数依次输出每条边的权值；如果没有解，一行输出 <code>No</code>。<br>本题采用 <code>special judge</code> 评测，也就是说，如果有多种可能的答案，你可以输出任意一种。<br>样例输入 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 2 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 2 1</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p>样例输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">1 2</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p>【样例解释】<br>对于第一组数据，$1$ 号点到达每个点的路径都是唯一，自然无论怎么设置边权，最短路都是唯一的。<br>对于第二组数据，因为 $k=1$，所以两条边的边权都只能设置为 $1$。$1$ 号点到 $2$ 号点的最短路长度为 $1$，走两条边都可以，所以不是唯一的。<br>【数据范围】<br>对于 $100\%$ 的数据，$n\ge 1$，$m\ge 0$，$1\le \sum n,\sum m\leq 3\times 10^5$，$1\leq k \leq 10^9$，$1\le x_i,y_i\le n$。</p><p>比赛一堆人说是随机乱搞ac的，留个坑等题解出了看看随机化怎么瞎搞做对的。<br>先考虑假设图是一颗树的情况，由于k必定大于1，可以发现一定是有解的，因为根（1号点）到其他点任意点的最短路径都只有一条。<br>考虑k等于1的时候，那么也就是说这个图边长只能是1，对于边长度固定的图，那么BFS找到的从起点结点到任意节点的路径都是最短路（也就是说边长固定的时候bfs可以直接代替优先队列跑dij）。所以可以直接bfs求最短路，并且由于最先出队的一定是最小的，然后发现如果1号点有从其他点到i的路径长度等于dist[i]那么一定是无解的。因为<strong>长度固定后能保证了跟i有关的结点路径长度越小的越先出队</strong>，所以如果想要更新dist[i]的唯一可能就是相等的时候所以一定是无解的。<br>k如果不是1那么显然之前k是1的时候有解那么k大于1也一定有解。关于k等于1时无解的情况，如果将与dist[i]相等的路径修改一下权值让他变成不是最短路即可，所以只要将他的路径变成2即可满足。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="type">int</span> e[m + <span class="number">5</span>] &#123;&#125;;</span><br><span class="line">vector&lt;vector&lt;PII&gt;&gt; <span class="built_in">edge</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">edge[u].<span class="built_in">push_back</span>(&#123;v, i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dist[n + <span class="number">5</span>] &#123;&#125;;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dist[i] = <span class="number">2e9</span>;</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">e[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [v, p] : edge[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (dist[u] + <span class="number">1</span> == dist[v])e[p] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (dist[v] == <span class="number">2e9</span>) &#123;</span><br><span class="line">dist[v] = dist[u] + <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line"><span class="keyword">if</span> (e[i] &gt; k) <span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>(e[i], <span class="number">1ll</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3-水影若深蓝"><a href="#T3-水影若深蓝" class="headerlink" title="T3 水影若深蓝"></a>T3 <a href="https://www.luogu.com.cn/problem/P10179?contestId=157909">水影若深蓝</a></h4><p>题目描述<br>当一切梦沉寂，他却遗忘了所有，只记得树上有 $n$ 个结点。<br>真的吗？似乎并没有，有 $m$ 件事情他一直牢记着，第 $i$ 件事情是：节点 $u_i$ 和 $v_i$ 在这棵深蓝之树上唯一的不重复经过某个点的路径恰好有两条边。<br>那么，你能否帮助帆帆想起来这棵深蓝之树的样子呢，如果有多个可能的，你只需要输出任意一种。<br>当然，帆帆也是会磨损的，因此当你发现无论如何都找不到满足帆帆这 $m$ 件事情的深蓝之树时，你需要报告无解。<br>大致意思就是给你树上的一些点对表示简单路径，并且给出的路径的长度都是2，构造一棵符合条件的树否则报告无解·。<br>输入格式<br>第一行一个正整数 $T$ 表示数据组数。<br>对于每组数据：<br>第一行两个非负整数 $n,m$ 表示树上的点数和帆帆记忆中事件个数。<br>接下来 $m$ 行，每行两个正整数 $u_i,v_i$ 表示一个事件。<br>输出格式<br>对于每组数据：</p><ul><li>若不存在符合条件的树，输出 <code>No</code>。</li><li>否则，第一行输出 <code>Yes</code>，接下来 $n-1$ 行输出 $n-1$ 对正整数 $(u,v)$，表示你给出的树上的 $n-1$ 条边。</li></ul><p>样例输入 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br></pre></td></tr></table></figure><p>样例输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">2 3</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p>对于 $100\%$ 的数据，$1\le T\le 10^5$，$n\ge 1$，$m\ge 0$，$1\le \sum n\le 3\times 10^5$，$0\le \sum m\le 3\times 10^5$，$1\le u_i,v_i\le n$，$u_i\neq v_i$。<br>说是比T2简单……<br>一般来说图论的题目中含有距离是2的问题，奇偶性的问题往往要联想到二分图染色法之类的解法。<br>先根据点对建图，得到一些连通块，因为一个连通块之间相邻的边一定是不能相邻的，那么假设有多个连通块，只需要在不同连通块之间连边就可以保证每个点对都是距离为2。比如有连通块A和B，A中有点x，B中有点y，那么将A中所有除x的点都和y连边，将B中除y的所有点都和x连边，最后x和y连边。因为一共连了O(A)+O(B)-1条边且没有重边，所以这样就能保证构造出来的图一定是一棵树。<br>那么猜想一个连通块只在内部连边一定是不存在的，因为题目要求的是一棵树，树上距离是二的一定是二分染色后同色的部分的一些边。原树怎么都不可能形成两个以内的连通块，所以只有一个连通块的时候一定是不存在的情况。<br>所以建完图之后统计连通块的个数，如果大于1那么一定是有解的。输出的时候只需要找任意两个连通块将其他连通块中的点与他们相连即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; par, h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DSU</span><span class="params">(<span class="type">int</span> _n)</span> : n(_n + <span class="number">1</span>), par(_n + <span class="number">1</span>), h(_n + <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= _n; ++i) par[i] = i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> par[x] != x ? par[x] = <span class="built_in">find</span>(par[x]) : par[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span> (x == y)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (h[x] == h[y]) &#123;</span><br><span class="line">h[x]++;</span><br><span class="line">par[y] = x;</span><br><span class="line">&#125; <span class="keyword">else</span> h[x] &lt; h[y] ? par[x] = y : par[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edge</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i) &#123;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line"><span class="comment">//edge[u].push_back(v),edge[v].push_back(u);</span></span><br><span class="line">dsu.<span class="built_in">unite</span>(u, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dsu.par[i] = dsu.<span class="built_in">find</span>(i);</span><br><span class="line"><span class="comment">//int cnt = 0;</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (dsu.par[i] == i) root.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">si</span>(root) == <span class="number">1</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; root[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; root[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == root[<span class="number">0</span>] || i == root[<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (dsu.par[i] ^ root[<span class="number">0</span>]) cout &lt;&lt; root[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; root[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷月赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC2023 HangZhou R 签到+铜牌题</title>
      <link href="/2024/02/15/ICPC2023-HangZhou-R-%E7%AD%BE%E5%88%B0-%E9%93%9C%E7%89%8C%E9%A2%98/"/>
      <url>/2024/02/15/ICPC2023-HangZhou-R-%E7%AD%BE%E5%88%B0-%E9%93%9C%E7%89%8C%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>The 2nd Universal Cup. Stage 22: Hangzhou结束了，所以可以把题解扔出来了。</p><p>题面：</p><div class="row">    <embed src="statements.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="V-Diagram"><a href="#V-Diagram" class="headerlink" title="V-Diagram"></a>V-Diagram</h4><p>长度为 $n$ 的 $1$ -索引整数序列 $a$ 是V-图，如果 $n \ge 3$ 且存在满足以下条件的索引 $i$ （ $1&lt; i &lt; n$ ）：</p><ul><li>$a_j &gt; a_{j + 1}$ 用于 $1 \le j &lt; i$ </li><li>$a_j &gt; a_{j - 1}$ 为 $i &lt;j \le n$ 。 </li></ul><p>给定V-图 $a$ ，找出具有最大可能平均值的V-图 $b$ ，使得 $b$ 是 $a$ 的连续子序列。<br>序列的连续子序列可以通过从序列的开头和结尾移除一些（可能为零）元素来获得。<br>签到题，题解说二分答案也行，但我做的时候用的是贪心。因为对于一个V图来讲，首先一定要包含最小的那个点，然后就是向左右两边扩展取最大。要求在现行复杂度内通过，所以不能直接暴力解，那么观察性质，由于保证是V图所以这个序列对应的图像的每一段的斜率都大于1，换句话说就是i每次改变1（增加一个数），纵坐标ai变化量至少大于1（加上ai），即$\frac{S+a_i}{len+1}$,S表示选中的ai的总和，len表示选的个数，所以不管怎么样选的ai越大越好,并且在选取的时候试单增的，即每多选一个数，对于平均值一定是有贡献的（糖水不等式）。所以假设一开始只有V图的极小值，S = $a_{minn}$,len = 1，要考虑怎么选增幅最大，由于序列a是V图，那么也就是形如8,6,5,3,1,2,4,5,6,7,10这样的，最好的情况一定是包含了10或8，并且在取10或8的时候一定是取了之前的数，那么就要考虑三种情况：选只包含10的最大V图，也就是选3,1,2,4,5,6,7,10；选只包含8的最大V图，也就是8,6,5,3,1,2；全选,8,6,5,3,1,2,4,5,6,7,10。三者取最大即可。<br>记得开long long以及使用cout时设置精度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 300005</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> pos, minn = <span class="number">1e9</span> + <span class="number">7</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">sum += a[i];</span><br><span class="line"><span class="keyword">if</span> (minn &gt; a[i]) pos = i, minn = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> ans = (<span class="type">double</span>)sum / n;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = pos - <span class="number">1</span>; i &lt;= n; ++i) sum += a[i];</span><br><span class="line">ans = <span class="built_in">max</span>((<span class="type">double</span>)sum / (n - pos + <span class="number">2</span>), ans);</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= pos + <span class="number">1</span>; ++i) sum += a[i];</span><br><span class="line">ans = <span class="built_in">max</span>((<span class="type">double</span>)sum / (pos + <span class="number">1</span>), ans);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mysterious-Tree"><a href="#Mysterious-Tree" class="headerlink" title="Mysterious Tree"></a>Mysterious Tree</h4><p><strong>这是一个交互问题。</strong></p><p>Randias有一个具有 $n$ 个顶点的未知隐藏树。树要么是<strong>链</strong>要么是<strong>星</strong>。</p><p>兰迪亚斯现在需要确定树是链还是星。他可以提出以下形式的问题，但不得超过 $\lceil \frac{n}{2} \rceil + 3$ 次：</p><p>-顶点 $u$ 和顶点 $v$ （ $1 \le u, v \le n$ ， $u \neq v$ ）之间是否有边？</p><p>兰迪亚斯需要确定这棵树是两种中的哪一种。帮助他提出问题并确定答案。</p><p>一棵树称为<strong>链</strong>，当且仅当存在一个置换 $p_{1}, p_{2}, \ldots, p_{n}$ ，使得对于每个 $i$ （ $1 \le i &lt; n$ ），树中都有一条边 $(p_{i}, p_{i + 1})$ 。</p><p>这里，长度为 $n$ 的排列是一个数组，其中从 $1$ 到 $n$ 的每个整数恰好出现一次。一棵树称为<strong>星</strong>当且仅当存在一个顶点 $u$ ，使得每隔一个顶点 $v$ ，树中就有一条边 $(u, v)$ 。</p><p>在这个问题中，交互者是<strong>自适应</strong>的，这意味着秘密树不是事先固定的。</p><p>相反，交互者可以在交互期间任意改变树。尽管如此，在每一个时刻，这棵树都会与你得到的所有答案保持一致。</p><p>注意只能问$\lceil \frac{n}{2} \rceil + 3$次，研究一下链和菊花图的性质，发现菊花图只有一个点是和所有点全部相连，那么首先需要想办法询问到一条存在的边，不妨询问(1, 2),(3, 4),(5, 6), . . . ,(n − 1, n)，这里还要注意如果n是奇数的话还要再问一次(n,1)是不是存在边才能完全保证问完全。如果全都不存在，则必然不是菊花。<br>现在假设存在的边是 (u, v)，我们需要在至多三次询问内确定是链还是菊花。<br>因为我们找到了一条已经确定存在的边，假设这个图是菊花图，那么可以找两个不同的点，设为p1,p2。<br>先问一遍p1和u。<br>如果有，说明如果是菊花图只有u才有可能是菊花中心，再问p2和u，如果也有那么一定是菊花图，如果没有，那么说明只能是链图因为u已经度是2了如果是菊花图u结点是不可能度为2的。<br>如果没有，那只能说明u不可能是菊花图的中心。<br>然后问p1和v，同问p1和u的处理方式判断是菊花图还是链图。这种情况是问的次数最多的，刚好用完。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line"><span class="keyword">auto</span> output = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">void</span>&#123;cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl &lt;&lt; endl;&#125;;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, input; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">output</span>(i - <span class="number">1</span>, i);</span><br><span class="line">cin &gt;&gt; input;</span><br><span class="line"><span class="keyword">if</span> (input) &#123;</span><br><span class="line">u = i - <span class="number">1</span>, v = i;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">output</span>(<span class="number">1</span>, n);</span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line">cin &gt;&gt; input;</span><br><span class="line"><span class="keyword">if</span> (input) &#123;</span><br><span class="line">u  = <span class="number">1</span>, v = n;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == u || i == v) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (p1) &#123;</span><br><span class="line">p2 = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> p1 = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">output</span>(p1, u);</span><br><span class="line"><span class="type">int</span> st;</span><br><span class="line">cin &gt;&gt; st;</span><br><span class="line"><span class="keyword">if</span> (st) &#123;</span><br><span class="line"><span class="built_in">output</span>(p2, u);</span><br><span class="line">cin &gt;&gt; st;</span><br><span class="line"><span class="keyword">if</span> (st) cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; <span class="number">2</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">output</span>(p1, v);</span><br><span class="line">cin &gt;&gt; st;</span><br><span class="line"><span class="keyword">if</span> (st) &#123;</span><br><span class="line"><span class="built_in">output</span>(p2, v);</span><br><span class="line">cin &gt;&gt; st;</span><br><span class="line"><span class="keyword">if</span> (st) cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; <span class="number">2</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Operator-Precedence"><a href="#Operator-Precedence" class="headerlink" title="Operator Precedence"></a>Operator Precedence</h4><p>构造满足等式$\sum_{i=1}^{n} a_{2 i-1} a_{2 i}=a_{1} a_{2 n} \prod_{i=2}^{n}\left(a_{2 i-2}+a_{2 i-1}\right) \neq 0 .$的序列。<br>被样例误导了，没想明白怎么构造，但是打完表之后就找到了规律，打表代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res1 = <span class="number">0</span>,res2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">res1 += a[i]*a[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;<span class="number">2</span>*n;i+=<span class="number">2</span>)&#123;<span class="comment">//1 2 3 4 5 6</span></span><br><span class="line">res2 *= (a[i]+a[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res1 == res2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a[<span class="number">1</span>] = a[n * <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i) &#123;</span><br><span class="line">a[<span class="number">2</span>] = a[<span class="number">2</span> * n - <span class="number">1</span>] = -i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">30</span>; ++j) &#123;</span><br><span class="line">a[<span class="number">3</span>] = a[<span class="number">2</span> * n - <span class="number">2</span>] = j;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">30</span>; ++k) &#123;</span><br><span class="line">a[<span class="number">4</span>] = a[<span class="number">2</span> * n - <span class="number">3</span>] = -k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">30</span>; ++l) &#123;</span><br><span class="line">a[<span class="number">5</span>] = a[<span class="number">2</span> * n - <span class="number">4</span>] = l;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> o = <span class="number">1</span>; o &lt;= <span class="number">30</span>; ++o) &#123;</span><br><span class="line">a[<span class="number">6</span>] = a[<span class="number">2</span> * n - <span class="number">5</span>] = -o;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt;= <span class="number">30</span>; ++p) &#123;</span><br><span class="line">a[<span class="number">7</span>] = a[n * <span class="number">2</span> - <span class="number">6</span>] = p;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>())&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i1 = <span class="number">1</span>;i1&lt;=<span class="number">2</span>*n;++i1)&#123;</span><br><span class="line">cout&lt;&lt;a[i1]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>n = 7的大概长这样，然后把前几位的拉出来看了下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>: <span class="number">1</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">5</span> <span class="number">5</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">1</span></span><br><span class="line"><span class="number">7</span>: <span class="number">1</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">4</span> <span class="number">4</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">5</span>: <span class="number">1</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">3</span>: <span class="number">1</span> <span class="number">-2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">-2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>: <span class="number">1</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">3</span> <span class="number">-7</span> <span class="number">-7</span> <span class="number">3</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">1</span></span><br><span class="line"><span class="number">8</span>: <span class="number">1</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">3</span> <span class="number">-5</span> <span class="number">-5</span> <span class="number">3</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span>: <span class="number">1</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">3</span> <span class="number">-3</span> <span class="number">-3</span> <span class="number">3</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span>: <span class="number">1</span> <span class="number">-1</span> <span class="number">3</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">3</span> <span class="number">-1</span> <span class="number">1</span> </span><br><span class="line"><span class="number">2</span>: <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后规律就比较明显了。其实还是复杂了，按照官方题解的构造方法是 考虑到乘法不能乘得太大，那么可以构造类似 x, 2, −1, 2, −1, · · · , 2, −1, y 的序列, 令 y = 1 解出 x 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;1 -10 6 6 -10 1&quot;</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i += <span class="number">2</span>) cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; (<span class="number">2</span> - <span class="number">2</span> * (n - <span class="number">2</span>)) / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Snake-Move"><a href="#Snake-Move" class="headerlink" title="Snake Move"></a>Snake Move</h4><p>Putata 正在他的笔记本电脑上玩一个著名的蛇形游戏，一条蛇在大小为 $n \times m$ 的网格上移动。网格的某些单元格中可能有障碍物。蛇可以用一串坐标对来表示，这些坐标对决定了蛇身体的位置： $(x_1, y_1), (x_2, y_2), \ldots, (x_k, y_k)$ .这里， $k$ 表示蛇的长度。蛇头位于 $(x_1, y_1)$ ，蛇尾位于 $(x_k, y_k)$ ，蛇身的相邻部分位于共用一条边的单元格中。<br>在这个游戏中，蛇被编程为一系列以字符串表示的命令。您可以使用 5 种命令：</p><ul><li>‘L’:命令小蛇向左移动一步。蛇头将移动到 $(x_1, y_1 - 1)$ 。</li><li>‘R’:命令蛇向右移动一步。蛇头将移动到 $(x_1, y_1 + 1)$ 处。</li><li>‘U’:命令蛇向上移动一步。蛇头将移动到 $(x_1 - 1, y_1)$ 处。</li><li>‘D’:命令蛇向下移动一步。蛇头将移动到 $(x_1 + 1, y_1)$ 处。</li><li>‘S’:将蛇的长度缩短一步。蛇身的尾部将被删除。长度将变为 $k - 1$ 。注意，当 $k = 1$ 时无法执行此操作。</li></ul><p>当蛇头移动时，蛇身的每个部分也会相应移动。具体来说，身体的第 $i$ 部分（ $2 \leq i \leq k$ ）会移动到 第$(i - 1)$ 部分在命令之前的位置。蛇不能移动到有障碍物的单元格中，也不能移动到网格外。此外，蛇也不能与自己碰撞。因此你应该保证蛇身的任何两个部分都不会共用同一个位置。<br>考虑下面的角情况：蛇头位于 $(x_1, y_1)$ ，蛇尾位于 $(x_k, y_k)$ 。如果头部移动到 $(x_1’, y_1’)$ ，那么就<strong>允许</strong>移动到 $(x_1’, y_1’) = (x_k, y_k)$ ：如果我们考虑现实世界中的情况，头部移动到单元格时，尾部正好移动到单元格外。类似地，在 $k = 2$ 处使用一条命令就可以交换头部和尾部。<br>您将得到网格的地图和蛇的身体序列。让 $f(i, j)$ 表示普塔塔为使蛇头到达 $(i, j)$ 所需的最少指令数，如果不可能，则为 $0$ 。你必须计算<br>$\left(\sum_{i = 1}^n\sum_{j = 1}^m f(i, j)^2\right) \bmod 2^{64}\text{.}$</p><p>输入</p><p>输入的第一行包含三个整数 $n$ 、 $m$ 和 $k$ （ $1 \leq n, m \leq 3000$ 、 $1 \leq k \leq \min\{nm, 10^5\}$ ），分别表示网格的大小和蛇的长度。</p><p>在接下来的 $k$ 行中， $i$ /th行包含两个整数 $x_i$ 和 $y_i$ （ $1 \leq x_i \leq n$ , $1 \leq y_i \leq m$ , $|x_i - x_{i+1}| + |y_i - y_{i+1}| = 1$ ），分别表示蛇身 $i$ /th部分的位置。保证所有 $k$ 对 $(x_i, y_i)$ 都是成对不同的。同时保证每个部分都位于一个没有障碍物的单元格中。</p><p>在接下来的 $n$ 行中， $i$ /th行包含一个长度为 $m$ 的字符串。如果 $(i, j)$ 单元格为空，那么这些行中 $i$ /th的 $j$ 个字符就是”.”。如果单元格 $(i, j)$ 被障碍物占据，则该字符为 “#”。<br>输出</p><p>打印一行，其中包含一个整数：问题答案。</p><p>嘴硬一下其实不是很难。<br>一开始没想明白是怎么回事，以为是走完全部的能到达的格子之后再计算$\left(\sum_{i = 1}^n\sum_{j = 1}^m f(i, j)^2\right) \bmod 2^{64}\text{.}$实际上是问你从起点开始走到(i,j)要多少步，那么就很套路的网格图建图求最短单源路径。<br>可以用dij，有一个比较难处理的地方是如果当前格子上有蛇的身体占着那么想要移动到这个格子就必须要等蛇身移走。<br>由于每个操作都可以等价看作初始蛇身必然缩短 1，并且同时控制蛇头移动一步或者不移动。<br>所以等蛇身移走就等于当前这个位置必须操作 k − i 次后才能访问该点。<br>这样的话就要先记录初始状态下第 i (2 ≤ i ≤ k) 节蛇身所处的位置，这里用map储存。<br>如果当前队列的队头移动到是蛇身，那么需要将队头所在位置的最短路长度与k − i 取最大值，然后再+1表示从队头所在位移动到蛇身的位置，松弛蛇身的位置的最短路。<br>如果当前队列的队头移动到的不是蛇身，那就直接普通的dij松弛即可。<br>但是注意题目的范围可以发现实际上堆优化的dij过不了，多带了一个log，这里用到了一个小trick：对于边长度固定的图（如等于1），那么BFS找到的从起点结点到任意节点的路径都是最短路。那么其实就可以直接用队列代替优先队列加速。<br>然后发现如果只用一个队列储存状态会有问题，因为这个边长并不全是1，因为蛇身有一个取max的操作。也就是说从不同情况下（蛇身位置与非蛇身位置）走到蛇身位置无法保证先进队列的一定就是最短路径。<br>实现的时候可以这样处理：一个队列存不是蛇身的位置，另一个存是蛇身的位置，每次先比较两个队列的队首，谁小就优先出队处理，这样就能保证队列的贪心是正确的。<br>题目中不太能理解的是取模和平方，取模的问题，其实C++没有哪一个类型能表示2的64次方(当然什么__int128就不算了)，合理怀疑是不需要取模的，取最坏的大概估算一下发现根本到不了2的64次方。对最短路平方还想了好久是不是有什么几何意义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dist[N][N], m, n, k;</span><br><span class="line">map&lt;array&lt;<span class="type">int</span>, 2&gt;, <span class="type">int</span>&gt; isBody;</span><br><span class="line"></span><br><span class="line">vector&lt;array&lt;<span class="type">signed</span>, 2&gt;&gt; d&#123;&#123;<span class="number">1</span>,  <span class="number">0</span>&#125;,&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">0</span>,  <span class="number">1</span>&#125;,&#123;<span class="number">0</span>,  <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    auto debugSt = [&amp;]() -&gt; void &#123;for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) cout &lt;&lt; st[i][j] &lt;&lt; &quot; \n&quot;[j == m];&#125;;</span></span><br><span class="line"><span class="comment">//    auto debugDist = [&amp;]() -&gt; void &#123;for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) cout &lt;&lt; dist[i][j] &lt;&lt; &quot; \n&quot;[j == m];&#125;;</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> headX, headY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) headX = x, headY = y;</span><br><span class="line">        isBody[array&lt;<span class="type">int</span>, 2&gt;&#123;x, y&#125;] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            cin &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) dist[i][j] = <span class="number">1ll</span> &lt;&lt; <span class="number">62</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; body, q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> judge = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> isBody.<span class="built_in">count</span>(array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;&#123;x, y&#125;); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bfs = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [dx, dy]: d) &#123;</span><br><span class="line">            <span class="type">int</span> w = dist[x][y];</span><br><span class="line">            <span class="type">int</span> _x = x + dx, _y = y + dy;</span><br><span class="line">            <span class="keyword">if</span> (_x &lt; <span class="number">1</span> || _x &gt; n || _y &lt; <span class="number">1</span> || _y &gt; m) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(_x, _y)) &#123;</span><br><span class="line">                w = <span class="built_in">max</span>(w, k - isBody[array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;&#123;_x, _y&#125;]);</span><br><span class="line">                <span class="keyword">if</span> (w + <span class="number">1</span> &lt; dist[_x][_y]) &#123;</span><br><span class="line">                    dist[_x][_y] = w + <span class="number">1</span>;</span><br><span class="line">                    body.<span class="built_in">push</span>(array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;&#123;_x, _y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (w + <span class="number">1</span> &lt; dist[_x][_y]) &#123;</span><br><span class="line">                    dist[_x][_y] = w + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;&#123;_x, _y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    body.<span class="built_in">push</span>(array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;&#123;headX, headY&#125;);</span><br><span class="line">    dist[headX][headY] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!body.<span class="built_in">empty</span>() || !q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!body.<span class="built_in">empty</span>() &amp;&amp; !q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [qx, qy] = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">auto</span> [bx, by] = body.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (dist[qx][qy] &lt; dist[bx][by]) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> x = qx, y = qy;</span><br><span class="line">                <span class="built_in">bfs</span>(x, y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                body.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> x = bx, y = by;</span><br><span class="line">                <span class="built_in">bfs</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!body.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [bx, by] = body.<span class="built_in">front</span>();</span><br><span class="line">            body.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> x = bx, y = by;</span><br><span class="line">            <span class="built_in">bfs</span>(x, y);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [qx, qy] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> x = qx, y = qy;</span><br><span class="line">            <span class="built_in">bfs</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            ans += dist[i][j] * dist[i][j];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个小细节就是dist取1&lt;&lt;62就能保证如果这个点到达不了那么在第87行就不需要判断<code>dist[i][j]&lt;(1&lt;&lt;62)</code>因为相乘之后一定是溢出的，最后会被直接截断成0。<br><del>堆优化过不了但可能直接跑朴素dij能过没试过不知道行不行。</del></p>]]></content>
      
      
      <categories>
          
          <category> ICPC区域赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杭州 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01字典树</title>
      <link href="/2024/02/13/01%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2024/02/13/01%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>用于接近线性的查询异或相关的问题，如异或前缀和，和别的数的最大异或和等。<br>01字典树是按照二进制下每一位是0还是1将一些数进行分类，每一个结点的左孩子表示当前这一位是0的所有数，右孩子表示当前这一位是1的所有数，这样递归的分下去总可以把所有的数分类完。</p><p>如要求每次线性的回答一个数和一个数组中的所有元素的最大异或值，数组范围是2e5：<br>将数组中的所有数类似于哈夫曼树一样·按位建成一棵树，如3(0011)，8(1000)，5(0101)那么就可以画出一个这样的树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">       root</span><br><span class="line">    /        \</span><br><span class="line">   0          1</span><br><span class="line"> /   \        /</span><br><span class="line">0     1      0</span><br><span class="line"> \  /      /</span><br><span class="line">  1  0     0</span><br><span class="line">   \  \   /</span><br><span class="line">    11  0</span><br><span class="line">   (3)(5)(8)</span><br></pre></td></tr></table></figure><p>那么比如查询这些数和6(0110)异或后的最大值，想要异或完最大，那么就要求每一位都不一样，因为位数越高那么占得权值就越大，所以从前往后贪心，如果树在这个位上有不一样的分支那就往这条分支上走。6的第一位是0，那么要找第一位是1的，查询的时候要选右边的节点，所以确定了答案的第一位是1，然后发现6的第二位是1并且有是0的分支，那么往这条边上走，所以答案的第二位也是1，类似的答案的第三位也是1，但是在第四位的时候没有没有对应的1的分支，也就是说3、5、8中首位是1，第二第三的数字是0的数字中没有第四位是1的那么只能往0这条边上走，所以答案的第四位是0。然后结束查询，答案就是14(1110)。<br>同样的也可以快速地求出一个数组中最大的连续异或和：<br><a href="https://www.luogu.com.cn/problem/CF1847C">Vampiric Powers, anyone?</a><br>大致意思就是一个整数数组长度为m，可以进行任意次下面的操作：<br>选择一个索引i，然后在这个数组的末端插入一个元素使得数组长度+1,并且这个元素的值是从i到末尾的所有元素的异或之和。<br>这道题最后分析出来就是求最大连续子段异或和。<br>证明：假设不要求连续的子段组成的异或和，比如<code>8 2 4 12 1</code>那么显然最大的就是15(8,2,4,1)而不是14。考虑这中情况为什么不合法，非连续的含义可以转化成跳过一些数所得到的异或和，因为异或有归零律，那么只需要证明有三个数的数组<code>c a b</code>按照上述规则能产生跳过a后异或和中带b（即b不被抵消，a被抵消，也就是所有i小于2的异或和中，b的个数是奇数，a的个数是偶数）就能推出这个操作能跳过一些数得到的异或和。那么假设：一开始i选择3，得到<code>c a b b</code>那么就比如i=1的时候想要异或和中带b是不可能的因为只要i小于3那么每次操作得到的异或和中必定带有偶数个b相互抵消(i大于等于3时对于下一步i小于3时，情况和初始或者和i = 3效果是一样的，比如 i = 3<code>c a b b b^b =&gt; c a b b 0 =&gt; c a b b</code>,i = 4<code>c a b b b =&gt; c a b</code>)，所以不可能；一开始i选择2，得到<code>c a b a^b</code>同理以后不管怎么操作也是a和b都是偶数一起被抵消了。所以不要求连续的子段这在这种规则下是不能产生的。<br>最大连续子段异或和一定是可以被构造出来的，和假设中的第二个构造法类似，比如[l,r]之间的异或和，可以先产生[r+1,m]的所有异或和放到m+1的位置，那么下次只需要选i= l即可把r后面的所有数抵消。<br>如何快速求出最大连续子段异或和？这道题的范围要求在线性的复杂度内求出。可以先求出异或后缀和sum[i]，注意到[l,r]可以看成sum[l]^sum[r+1]（归零律）就是直接抵消了r后面的数所以对后缀和进行建01字典树，枚举l，找到一个最大的r即可，并且异或有交换律所以就算找到的r小于l也没事。<br>需要注意的是不一定要找一r有可能l后面的所有数要比找到的r要更小，所以最大值要考虑自己sum[l]本身.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="type">int</span> nxt[N][<span class="number">2</span>],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">8</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="type">int</span> y = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nxt[u][y]) u = nxt[u][y];</span><br><span class="line">        <span class="keyword">else</span> nxt[u][y] = ++cnt,u = nxt[u][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">8</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="type">int</span> y = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nxt[u][y^<span class="number">1</span>]) sum += (<span class="number">1</span>&lt;&lt;i),u = nxt[u][y^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> u = nxt[u][y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=cnt;++i) nxt[i][<span class="number">1</span>] = nxt[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i],a[i] ^= a[i<span class="number">-1</span>],<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i) ans = <span class="built_in">max</span>(&#123;ans,<span class="built_in">find</span>(a[i]),a[i]&#125;);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上最大连续异或和实际上也可以用dp。</p>]]></content>
      
      
      <categories>
          
          <category> 一些小算法和算法思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根号分治</title>
      <link href="/2024/02/09/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"/>
      <url>/2024/02/09/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<p>用来处理一些根号范围以内复杂度高（打表），根号范围以外复杂度低（枚举）的一种暴力思想，一般能做到$O(n\sqrt n)$的复杂度，大多数都是多组数据询问。</p><h4 id="P3396-哈希冲突"><a href="#P3396-哈希冲突" class="headerlink" title="P3396 哈希冲突"></a><a href="https://www.luogu.com.cn/problem/P3396">P3396 哈希冲突</a></h4><p>一个长度为n 的序列和m个操作，每次操作可以以下二选一：<br>1 询问下标模x后为y的所有数之和<br>2 修改第x个数<br>n≤150000，m≤150000，元素范围是[1,1000]的整数<br>暴力做法是直接枚举，比如模2后为1的有1,3,5,7…，模10后为1的有11,21,31,41,51…可以发现对于长度为n的，模x后为y的数大概有$\left \lfloor \frac{n}{x} \right \rfloor$个，当x越大那么这个数越小，所以模数越大的可以考虑直接暴力枚举而不会超时，那么问题在于如何处理模数小的询问，当模数小的时候因为余数的范围变小了所以考虑直接先打表预处理出所有的情况，令sum[i][j]表示n个数中下标模i后为j的所有的数的总和，那么可以在O(np)的复杂度内预处理出所有情况，其中p为指定的最大的模数，同时修改也很简单，单次修改的复杂度是O(p)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i)</span><br><span class="line">        sum[i][j % i] += a[j];</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) sum[i][x % i] += y - a[x];</span><br><span class="line">a[x] = y;</span><br></pre></td></tr></table></figure><p>所以在模数小于p的情况下直接O(1)查询，模数大于p的情况下最坏大概是$O(\left \lfloor m\frac{n}{p} \right \rfloor )$计算，并且预处理和修改的最坏情况（全是修改）下复杂度都是O(np)，后两者的复杂度是较高的，那么由均值定理得当他们两个相等的时候总体的复杂度是最低的即$m\frac{n}{p} = n\frac{n}{p} = np$,得$p = \sqrt n$,此时是最小的,所以p大概取390左右。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">390</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="type">int</span> sum[p+<span class="number">1</span>][p+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i)</span><br><span class="line">            sum[i][j % i] += a[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> cmd;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; cmd &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (cmd == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; p) <span class="keyword">for</span> (<span class="type">int</span> i = y; i &lt;= n; i += x) ans += a[i];</span><br><span class="line">        <span class="keyword">else</span> ans = sum[x][y];</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) sum[i][x % i] += y - a[x];</span><br><span class="line">        a[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Sum-of-Progression"><a href="#Sum-of-Progression" class="headerlink" title="Sum of Progression"></a><a href="https://www.luogu.com.cn/problem/CF1921F">Sum of Progression</a></h4><p>给你一个长度为 $n$ 的数列 $a$。有 $q$ 次询问，每次询问给出 $s,d,k$，你需要回答 $\displaystyle\sum_{i=1}^ka_{s+(i-1)d}\times i$ 的值。<br>$s,d,k\leq n\leq 10^5,q\leq 2\times 10^5,s+d(k-1)\leq n,|a_i|\leq 10^8$。<br>看出这是等差数列，可以发现d越大增长的越快p的取值与上一题的证明类似，都是对形如一次函数和反比例函数之和求最小值，这道题p大概可以取320。<br>预处理要比上一道要复杂些，这里用后缀和处理更简单一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">320</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q, s, d, k, a[N];</span><br><span class="line"><span class="type">int</span> sum[N + p][p + <span class="number">5</span>], f[N + p][p + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+p;i++) </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=p;j++) </span><br><span class="line">sum[i][j]=<span class="number">0</span>,f[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">sum[j][i] = sum[j + i][i] + a[j],</span><br><span class="line">f[j][i] = f[j + i][i] + sum[j + i][i] + a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; d &gt;&gt; k;</span><br><span class="line"><span class="keyword">if</span> (d &lt;= p) &#123;</span><br><span class="line"><span class="type">int</span> last = s + d * k;</span><br><span class="line"><span class="keyword">if</span> (last &gt; n)cout &lt;&lt; f[s][d] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; f[s][d] - f[last][d] - sum[last][d]*k &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= s+d*(k<span class="number">-1</span>); i += d)</span><br><span class="line">ans += a[i] * cnt, cnt++;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根号分治只是一种思想，只要是对于一次循环内的复杂度呈单调增或单调减都可以用这种思想，并且不一定是在根号处划分枚举与打表的界限，具体怎么判断要对复杂度分析后才可以。</p>]]></content>
      
      
      <categories>
          
          <category> 一些小算法和算法思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 根号分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github个人网站开发</title>
      <link href="/2024/02/07/hexo-github%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"/>
      <url>/2024/02/07/hexo-github%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>23年暑假看这个视频<a href="https://www.bilibili.com/video/BV1st411r7Sj">BV1st411r7Sj</a>学git的时候偶然发现github可以托管像hexo这种无后端的博客框架，参考一些教程（比如<a href="https://www.bilibili.com/video/BV1NY4y1C7Ng/?spm_id_from=333.788.top_right_bar_window_history.content.click&amp;vd_source=d8e94394d339be4a8b0e2b575781e097">BV1NY4y1C7Ng</a>）自己用hexo+github搓了个博客。<br>有些东西长久不用就忘记了，写个文档记录一些常用的操作和踩过的坑。</p><h3 id="博客主题的选择"><a href="#博客主题的选择" class="headerlink" title="博客主题的选择"></a>博客主题的选择</h3><p>用的Butterfly：<a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a> </p><h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><p>像语雀这种存在防盗链机制的文章即使导出的是Markdown格式图片在博客上也是不能显示的，一种简单的方法是在语雀端插入图片的时候不要直接插入，这样图片是放在语雀图床里面的，可以放在别的图床比如<a href="https://sm.ms/home/">https://sm.ms/home/</a>等并将其用图床外链放到语雀写作端就没有问题因为图片并没有存在语雀图床里面。还有一种就是开超级会员获取token，这样就可以不用将语雀上的内容导出就可以在博客上显示。</p><h3 id="将博客托管至GitHub"><a href="#将博客托管至GitHub" class="headerlink" title="将博客托管至GitHub"></a>将博客托管至GitHub</h3><p>参考<a href="https://xtzyj.top/2023/08/21/0%E6%88%90%E6%9C%AC%E4%BD%BF%E7%94%A8Hexo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E6%89%98%E7%AE%A1%E8%87%B3Github-Pages/#%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%89%98%E7%AE%A1%E8%87%B3GitHub">0成本使用Hexo框架搭建个人博客并托管至Github-Pages/#将博客托管至GitHub</a> (2025/02/25upd:这个博客地址好像换了，安装环境和配置可以参考这篇<a href="https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo + github搭建个人博客教程.md">这篇</a> 和上面的视频 )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd xxxx.github.io</span><br><span class="line">git add --all</span><br><span class="line">git commit -m &quot;message&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><a name="H5qxk"></a></p><h3 id="pdf文件的插入"><a href="#pdf文件的插入" class="headerlink" title="pdf文件的插入"></a>pdf文件的插入</h3><p>参考<a href="https://blog.csdn.net/weixin_37726222/article/details/123071678">hexo post中pdf文件的插入</a>，下载依赖的时候如果网络原因报错可以加镜像源，参考<a href="https://blog.csdn.net/weixin_44523860/article/details/104167020">解决npm下载慢慢慢慢的问题</a></p><p><a name="HNZO7"></a></p><h3 id="文章中latex公式的渲染问题"><a href="#文章中latex公式的渲染问题" class="headerlink" title="文章中latex公式的渲染问题"></a>文章中latex公式的渲染问题</h3><p>好像hexo更新之后一些依赖也跟着更了然后之前改好了的latex就炸了，参考<a href="https://www.jianshu.com/p/7ab21c7f0674">在Hexo中渲染MathJax数学公式</a>解决数学公式的渲染问题</p><p><a name="SQyBg"></a></p><h3 id="添加文章置顶功能"><a href="#添加文章置顶功能" class="headerlink" title="添加文章置顶功能"></a>添加文章置顶功能</h3><p><a href="https://blog.csdn.net/weixin_43372529/article/details/114176470">https://blog.csdn.net/weixin_43372529/article/details/114176470</a><br>卸载<a href="https://so.csdn.net/so/search?q=hexo&amp;spm=1001.2101.3001.7020">hexo</a>-generator-index，然后安装hexo-generator-index-pin-top，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure><br>然后在文章的头文件中加上top:true即可</p>]]></content>
      
      
      <categories>
          
          <category> 博客开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Linux(Ubuntu)</title>
      <link href="/2024/01/06/%E5%85%B3%E4%BA%8ELinux(Ubuntu)/"/>
      <url>/2024/01/06/%E5%85%B3%E4%BA%8ELinux(Ubuntu)/</url>
      
        <content type="html"><![CDATA[<p><a name="WJjdK"></a></p><p>之前打ICPC用的wf镜像，不适应ubuntu系统的各种操作，<del>其实队伍里面只有我不会。</del>本文记录一些日常使用ubuntu中遇到的一些问题，以后如果上相关的选修课也可以用用</p><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>一些软件给linux系统提供了好几种版本，比如X86,ARM,LoogArch、MIPS等，这四种版本的区别：<br>X86（或x86_64）： 适用于大多数个人计算机和服务器的标准桌面和服务器硬件，通常是Intel或AMD处理器。<br>ARM： 适用于基于ARM架构的设备，如某些嵌入式系统、智能手机、平板电脑等。<br>loongArch（龙芯架构）： 龙芯是中国的一个处理器架构，适用于支持龙芯架构的硬件。<br>MIPS： 适用于MIPS架构的硬件，这种架构在嵌入式系统和某些网络设备中较为常见。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看ubuntu系统的版本信息</span><br><span class="line">lsb_release -a</span><br><span class="line">查看硬件架构</span><br><span class="line">uname -m</span><br></pre></td></tr></table></figure><p>选了架构之后，下载的软件包又分为三种：<br>三个不同的包格式（.rpm、.deb、AppImage）在Linux中用于软件管理，它们有一些基本的区别：<br>.rpm（Red Hat Package Manager）： 主要用于基于Red Hat的发行版，如Fedora、openSUSE、CentOS等。这种包格式是通过Red Hat开发的，用于简化软件的安装、升级和卸载。<br>.deb（Debian Package）： 用于Debian及其衍生发行版，如Ubuntu。Debian包管理系统使用.deb格式，也是一种用于简化软件管理的包格式。<br>AppImage： 是一种独立的可执行软件包格式，不依赖于特定的包管理系统。AppImage封装了应用程序及其依赖项，可以在多个不同的Linux发行版上运行，而无需安装。这使得AppImage更具有可移植性。<br>关于.deb:<br>1.找到.deb文件所在的目录，打开终端<br>2.输入命令$ sudo dpkg -i xxx.deb<br>*如果出现依赖向错误，可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1、更新源</span><br><span class="line">sudo apt-get update</span><br><span class="line"> </span><br><span class="line"># 2、fix解决依赖关系</span><br><span class="line">sudo apt-get -f install</span><br><span class="line"> </span><br><span class="line"># 3、再次安装xxx.deb</span><br><span class="line">sudo dpkg -i xxx.deb</span><br></pre></td></tr></table></figure><p>关于.AppImage:<br>需要先给这个加权限</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x example.AppImage  # 赋予可执行权限</span><br><span class="line">./example.AppImage         # 运行应用程序</span><br></pre></td></tr></table></figure><p><code>+x</code> 是 <code>chmod</code> 命令的一个选项，用于赋予文件可执行权限。在 Unix 和 Linux 系统中，文件权限包括读取 (read, <code>r</code>)、写入 (write, <code>w</code>) 和执行 (execute, <code>x</code>)。这些权限可以分别应用于文件的所有者、所在组和其他用户。<br>具体来说，<code>chmod +x &lt;filename&gt;</code> 命令用于将文件 <code>&lt;filename&gt;</code> 标记为可执行文件，这样用户就可以运行这个文件。</p><ul><li><code>r</code>(read) - 读取权限</li><li><code>w</code>(write) - 写入权限</li><li><code>x</code>(execute) - 执行权限</li></ul><p>然后就会发现双击打不开，在命令行中显示要FUSE<br>安装FUSE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository universe</span><br><span class="line">sudo apt install libfuse2</span><br></pre></td></tr></table></figure><p>然后就行了</p><h3 id="扩展磁盘"><a href="#扩展磁盘" class="headerlink" title="扩展磁盘"></a>扩展磁盘</h3><p>扩展之前要先把快照删掉，扩展完之后还要在操作系统中设置才能真正的使用，不然是属于未分配的空间（扩展完最好先保存快照防止意外）。<br>方法也很简单，Ubuntu自带一个disk工具，打开之后就可以选择一个分区扩容，直接拉到最大即可</p><h3 id="配置clash"><a href="#配置clash" class="headerlink" title="配置clash"></a>配置clash</h3><p>参考<a href="https://zhuanlan.zhihu.com/p/692414049">Linux（ubuntu）系统安装和使用clash</a>。<br>下载压缩包，解压文件，在终端中打开使用命令<code>sudo vim .env</code>。<br>编辑文件，将其改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export CLASH_URL=&#x27;URL&#x27;</span><br><span class="line">export CLASH_SECRET=&#x27;1111&#x27;</span><br></pre></td></tr></table></figure><p><code>CLASH_SECRET=&#39;1111&#39;</code>将其设置为1111是方便输入密码，不填的话默认是随即字符串。<br>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash start.sh</span><br></pre></td></tr></table></figure><p>然后和教程里的步骤不一样，直接用默认的就行不用改什么ip地址。<br>直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile.d/clash.sh</span><br></pre></td></tr></table></figure><p>即可。<br>然后<code>proxy_on</code>打开代理。<br>要进入图形化界面对代理进行设置。<br>输入<code>ip a</code>查看地址。<br>其中有一行的前面是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inet xxx.xxx.xxx.xxx/xxx brd xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure><p>这里inet后面的<code>xxx.xxx.xxx.xxx</code>就是ip地址。<br>将<code>http://xxx.xxx.xxx.xxx:9090/ui/</code>中的xxx.xxx.xxx.xxx替换为自己的ip地址，打开这个链接，然后在API Base URL后填上<code>http://127.0.0.1:9090</code>(默认的那个)，就是网址去掉/ui后的内容，在Secret这一栏填上设置的密码（1111），然后点击add，下方就会多出一个选项,点进去就行。<br>成功的话长这样：<br><img src="https://s2.loli.net/2024/06/29/2foCygdGkLte9Nn.png#id=zrcOg&amp;originHeight=714&amp;originWidth=1606&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none" alt><br>因为clash对7890端口开放，<br><img src="https://s2.loli.net/2024/06/29/1L5qH4zbiyTaCVn.png#id=dIKK7&amp;originHeight=679&amp;originWidth=1565&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none" alt><br>所以还要手动设置，按照知乎里面那篇文章设置<br><img src="https://s2.loli.net/2024/06/29/fScnYZq6RboEjKw.png#id=SkPq4&amp;originHeight=541&amp;originWidth=695&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none" alt><br>然后就没问题了，关闭代理只要在终端输入<code>sudo bash shutdown.sh</code>和<code>proxy_off</code>。<br>有点麻烦的是每次开机要重新设置，sudo bash start，proxy_on，切到手动网络配置。有时间写个.sh<br>upd:问chat要了个脚本<br>开启代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一行命令：使用sudo权限执行start.sh脚本</span></span><br><span class="line">sudo bash start.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二行命令：载入/etc/profile.d/clash.sh文件</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/clash.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三行命令：执行proxy_on命令</span></span><br><span class="line">proxy_on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置网络代理为手动配置</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy mode <span class="string">&#x27;manual&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置HTTP代理</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.http host <span class="string">&#x27;ip&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.http port xxxx  <span class="comment"># 设置HTTP代理端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置HTTPS代理</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.https host <span class="string">&#x27;ip&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.https port xxxx <span class="comment"># 设置HTTPS代理端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置FTP代理</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.ftp host <span class="string">&#x27;ip&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.ftp port xxxx <span class="comment"># 设置FTP代理端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置SOCKS代理</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.socks host <span class="string">&#x27;ip&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.socks port xxxx  <span class="comment"># 设置SOCKS代理端口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>暂时关闭代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy mode <span class="string">&#x27;auto&#x27;</span></span><br></pre></td></tr></table></figure><p>重新开启代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置网络代理为手动配置</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy mode <span class="string">&#x27;manual&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置HTTP代理</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.http host <span class="string">&#x27;ip&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.http port xxxx  <span class="comment"># 设置HTTP代理端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置HTTPS代理</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.https host <span class="string">&#x27;ip&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.https port xxxx <span class="comment"># 设置HTTPS代理端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置FTP代理</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.ftp host <span class="string">&#x27;ip&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.ftp port xxxx <span class="comment"># 设置FTP代理端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置SOCKS代理</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.socks host <span class="string">&#x27;ip&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.socks port xxxx  <span class="comment"># 设置SOCKS代理端口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="c-c-环境的搭建"><a href="#c-c-环境的搭建" class="headerlink" title="c/c++环境的搭建"></a>c/c++环境的搭建</h3><h4 id="配置vim"><a href="#配置vim" class="headerlink" title="配置vim"></a>配置vim</h4><p>参考：<a href="https://www.bilibili.com/video/BV16P4y1X7xQ/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=d8e94394d339be4a8b0e2b575781e097">https://www.bilibili.com/video/BV16P4y1X7xQ/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=d8e94394d339be4a8b0e2b575781e097</a><br>下载c/c++插件<a href="https://www.bilibili.com/video/BV16P4y1X7xQ/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=d8e94394d339be4a8b0e2b575781e097">https://www.bilibili.com/video/BV16P4y1X7xQ/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=d8e94394d339be4a8b0e2b575781e097</a><br>如果装vim-plug报错：<a href="https://www.cnblogs.com/yutian-blogs/p/12904221.html">https://www.cnblogs.com/yutian-blogs/p/12904221.html</a><br>升级nodejs版本<a href="https://blog.csdn.net/fuhanghang/article/details/133853433">https://blog.csdn.net/fuhanghang/article/details/133853433</a><br>安装coc<a href="https://github.com/neoclide/coc.nvim">https://github.com/neoclide/coc.nvim</a><br>coc json的设置 <a href="https://github.com/godotc/toys/blob/main/coc-settings.json">https://github.com/godotc/toys/blob/main/coc-settings.json</a></p><h4 id="配置clion"><a href="#配置clion" class="headerlink" title="配置clion"></a>配置clion</h4><p>直接用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo snap install clion --classic</span><br><span class="line">可以加上制定版本</span><br><span class="line">sudo snap install clion --channel=2021.1 --classic</span><br></pre></td></tr></table></figure><p>还要安装make，gcc，g++这些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install make</span><br><span class="line">sudo apt install gcc</span><br><span class="line">sudo apt install g++</span><br></pre></td></tr></table></figure><p>然后就可以运行了<br>关于apt：<br><a href="https://www.runoob.com/linux/linux-comm-apt.html">Linux apt 命令</a></p><h4 id="配置cpeditor"><a href="#配置cpeditor" class="headerlink" title="配置cpeditor"></a>配置cpeditor</h4><p>cpeditor与clion相比较为轻量级，占用的资源也很少<del>比较适合在虚拟机这可怜的内存里面运行</del>。<br><a href="https://cpeditor.org/download/">下载地址</a><br>没有代码补全功能是真的很难受，对于我这样的唐氏选手很不友好……就当练练手速了。<br>安装clang-format用于格式化代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install clang-format</span><br></pre></td></tr></table></figure><h4 id="配置redpanda"><a href="#配置redpanda" class="headerlink" title="配置redpanda"></a>配置redpanda</h4><p>有代码补全，算是一个折中的方案了，平时训练可以用用cpeditor，一些比赛就还是带上代码补全会好一些。<br><a href="http://royqh.net/redpandacpp/download/">下载链接</a><br>居然感觉比win端的体验要舒服一些。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023ICPC杭州站打铁游记</title>
      <link href="/2023/12/11/2023ICPC%E6%9D%AD%E5%B7%9E%E7%AB%99%E6%89%93%E9%93%81%E6%B8%B8%E8%AE%B0/"/>
      <url>/2023/12/11/2023ICPC%E6%9D%AD%E5%B7%9E%E7%AB%99%E6%89%93%E9%93%81%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>由于杭州站题目将用作UCup Stage Hangzhou，博客会在24年2月之后再发题解<br>本身就是蒟蒻，本来也没想能有多好的成绩就看能不能拿到铜牌，结果不出意外的打铁了。只能说菜就多练确实技不如人，不过也正常没打过铁都不好意思说自己参加过ICPC。<br>day-1<br>周五下午出发，相比回家而言杭州很快就到了唯一难受的是东站离杭师大太远了乘地铁站了半天才到定的公寓，中途还发现因为比赛用的是Ubuntu系统win下的对拍程序还用不了，晚上临时整了个简陋的linux对拍器，手抄代码准备明天热身赛测试。<br>day0<br>早上七点多起床，去杭师大吃早饭结果精准踩雷吃到了逆天菜包，馅是豆腐+辣椒而且馅还少吃一半实在咽不下去就倒掉了，然后感觉自己又饿又想吐。走到叔同剧场签完到领了队服拍了合照，顺便吐槽了这队服颜色感觉像送外卖的(一黄一蓝的简称美团大战饿了么)。下午2.30开热身赛，开了两题看了眼排名感觉还可以过了铜牌线（当然很多大佬熟悉比赛环境了就懒得打所以排名会靠前一些）。自我感觉明天可以手速铜因为看很多人也是第一次参赛。测试完对拍代码然后润回公寓睡觉了。<br>回到公寓看见群里在发热身赛直播录像，然后发现自己正对着摄像头，有点炸裂明天准备直播丢脸了。<br>有意思的是我那天晚上做梦梦到了自己正式赛过了铜牌线。<br>day1<br>晚上做梦了明显睡得不是很舒服没怎么清醒。8点多过去存放行李然后等到九点左右进场。<br>没想到一打就打成牢大了。<br>开局zzc去敲缺省源，我和cfl去看题，随便翻了翻发现好像没有特别签到的题，去看榜单发现M题有人过了就三人一起看M，然后我和zzc想了个假做法先敲了上去后来cfl想了个正解，zzc就把原来的代码全删了敲这个，拿我造的数据拍了一下发现不对我看了下代码发现是除法没开double寄了，改了之后提交一发就过。此时已经过了40多分钟，有点小炸但还好排在中游。<br>再去看榜单发现D和L都有不少人做，决定先看D，发现是类似于找规律的构造题，找了半天没找出来，cfl去看L，我和zzc继续看D。想了好久cfl说L好像跟简单一些顺便讲了下思路，我们讨论了一下感觉是对的（实际上有个特判没找出来），留下我和zzc敲代码。结果zzc理解错了思路又因为这个思路不是我想出来的我也不知道加这个询问有没有问题就没去反驳他然后wa两次喜提两次罚时。<br>错了两次心态已经有点炸了，关键是是个图论的交互题对拍还不怎么好写，自己手搓的数据又没有问题，我想着自己对这道题没啥贡献了就去看D题让cfl和zzc接着找bug，再错了两次之后找出了bug加了个特判才过。<br>连吃四次罚时心态直接爆炸。然后一起集中看D。D题的规律看了半天也没看出来是什么，我决定把暴力枚举把所有正解都输出看看，然后想着有没有可能样例是误导，枚举出来所有的正解发现每个输入都对应有100多个合法构造。看着过的队伍越来越多彻底慌了，开始毫无章法的随便找数据看看有没有规律，找过序列值等于输入的，等于输入平方的，正负1交替循环的看了两小时愣是没找到规律，又开始直接看式子试试能不能推结论。也没弄出来，这下真的成饭桶了写不出来题把发下来的午饭全吃了，最后一路挂机到比赛结束带着胸牌题目板子溜出机房连晚饭餐券都不要了直接回公寓自闭了。<br>然后回到公寓我感觉不服躺床上断断续续的想了两三个小时结果真就爆出了一个合法构造。我直接把暴力枚举的第一个构造序列单独打出来找了一下规律，自己测试了一下大数据结果没错。这下真的投湖的心都有了。<br>研究了一下发现正负交替是必须的，然后只要1 -2循环就能满足题目的要求。有点无语，都感觉出来样例是误导了，样例输入2，3，4的时候序列第二个是-3，-10，-15，打表输入5的数据很明显不存在第二个是-26 开头的序列，为什么比赛就没想到直接把第一个合法构造拉出来试试。。。。。<br>然后明天回来的时候群里发了补题链接改了改D交了之后真就过了，彻底玉玉了。</p><p>这次比赛总给我一种三个人打出了1+1+1<1的操作，写出来D题后怎么也没想出来自己为啥当时就是没想到。正常发挥应该能在铜尾铁首的水平，三题就有手速铜，至少不会这么难看。结果配合寄自己状态也寄，队伍排名有点难看差点掉到400名。<br>银牌爷刷两三千题从打铁打到银牌，队伍里三个人加起来也没有两千题。只能多刷刷题好好准备明年网络赛省赛啥的，要是我400多题也能摸到铜牌估计真就成天赋怪了。<br>明年再战吧。</1的操作，写出来D题后怎么也没想出来自己为啥当时就是没想到。正常发挥应该能在铜尾铁首的水平，三题就有手速铜，至少不会这么难看。结果配合寄自己状态也寄，队伍排名有点难看差点掉到400名。<br></p><p>upd:2024-2-15</p><p>补题的时候发现回旋镖打自己身上了。比赛前让别人看看博客上的<a href="https://z01prime.github.io/2023/10/05/trick/">trick</a>队友还在问“对于边长度固定的图（如等于1），那么BFS找到的从起点结点到任意节点的路径都是最短路”这不显然的有啥用，然后G题就考了这个……当然当时连D都没写出来也不敢去看G</p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC2021 Nanjing R 签到+铜牌题</title>
      <link href="/2023/11/15/ICPC2021-Nanjing-R-%E7%AD%BE%E5%88%B0-%E9%93%9C%E7%89%8C%E9%A2%98/"/>
      <url>/2023/11/15/ICPC2021-Nanjing-R-%E7%AD%BE%E5%88%B0-%E9%93%9C%E7%89%8C%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>补题链接：<a href="https://codeforces.com/gym/103470">https://codeforces.com/gym/103470</a>或<a href="https://www.luogu.com.cn/contest/143839">https://www.luogu.com.cn/contest/143839</a><br><a name="bwVhK"></a></p><h2 id="A-Oops-It’s-Yesterday-Twice-More"><a href="#A-Oops-It’s-Yesterday-Twice-More" class="headerlink" title="A.Oops, It’s Yesterday Twice More"></a>A.Oops, It’s Yesterday Twice More</h2><p>n*m的矩阵里面每个格子都有一个袋鼠你可以通过在键盘上按下U、D、L、R按钮来控制袋鼠。袋鼠将根据您按下的按钮同时移动。具体而言，对于位于第i行和第j列的单元格，用（i，j）表示：</p><ol><li>按钮U：如果i &gt; 1，则它将移动到（i - 1，j）。否则，它将保持在相同的网格中。</li><li>按钮D：如果i &lt; n，则它将移动到（i + 1，j）。否则，它将保持在相同的网格中。</li><li>按钮L：如果j &gt; 1，则它将移动到（i，j - 1）。否则，它将保持在相同的网格中。</li><li>按钮R：如果j &lt; n，则它将移动到（i，j + 1）。否则，它将保持在相同的网格中。</li></ol><p>您需要构建一个仅由字符‘U’、‘D’、‘L’和‘R’组成的操作序列。应用该序列后，您必须确保每只袋鼠都聚集在特定的单元格（a，b）。操作序列的长度不能超过3(n - 1)。</p><p>签到题，想到可以在等于2(n-1)的步数将袋鼠全部聚集到四个角落中的任意一个角落，那么问题就转换成在n-1步数之内移到（a,b）点，只要贪心的选择到（a,b）点曼哈顿距离最小的那个角落就一定能保证在n-1步之内到达，可以假设最坏情况（中心点）来验证一下<br><a name="28e5daa8"></a></p><h2 id="M-Windblume-Festival"><a href="#M-Windblume-Festival" class="headerlink" title="M.Windblume Festival"></a>M.Windblume Festival</h2><p>给一个长度为n环形整数序列a,每次操作可以选择两个相邻的数，左边的数减去右边的数，删除右边的数，最后会剩下一个元素，要求最大化这个元素<br>有正有负或者有0的情况下一定无损，只需要对绝对值求和即可，如果全是正或者全是负数那么就要考虑将亏损降到最小，因为最后必定会剩下两个数，左边的数用于减去右边的数，对于全是正数而言，剩的一定是左边一个正数和右边一个负数，那么原本右边位置的数（设为k）就是亏损的数，要最小化亏损就需要右边原来的数最小，这样在最后就亏损了2<em>k;对于负数而言也是类似（其实正负并没有关系），找出绝对值最小的负数（k），亏损的就是2</em>abs（k））,注意特判n==1的情况<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000006</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, min1 = <span class="number">1e18</span>, max1 = <span class="number">-1e18</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">bool</span> flagP = <span class="literal">false</span>, flag0 = <span class="literal">false</span>, flagN = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">if</span> (min1 &gt; a[i]) min1 = a[i];</span><br><span class="line"><span class="keyword">if</span> (max1 &lt; a[i]) max1 = a[i];</span><br><span class="line">sum += <span class="built_in">abs</span>(a[i]);</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>)flagP = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (a[i] == <span class="number">0</span>) flag0 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>) flagN = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;min1&lt;&lt;&#x27; &#x27;&lt;&lt;min2&lt;&lt;&#x27; &#x27;&lt;&lt;max1&lt;&lt;&#x27; &#x27;&lt;&lt;max2&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> cout&lt;&lt;a[<span class="number">1</span>]&lt;&lt;endl,<span class="built_in">void</span>();</span><br><span class="line"><span class="keyword">if</span> ((flagN &amp;&amp; flagP) || flag0) &#123;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flagP) &#123;</span><br><span class="line">cout &lt;&lt; sum - <span class="built_in">abs</span>(min1)*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; sum - <span class="built_in">abs</span>(max1)*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a name="GefcE"></a></p><h2 id="C-Klee-in-Solitary-Confinement"><a href="#C-Klee-in-Solitary-Confinement" class="headerlink" title="C.Klee in Solitary Confinement"></a>C.Klee in Solitary Confinement</h2><p>给定一个整数序列和一个可添加的数字，最多可以选择一个区间执行一次添加操作（可以不执行），求在执行或不执行操作的情况下，整个序列中众数的最大出现次数。<br>对于一个数a来说，他只能影响到a的个数以及a+k的个数，所以先记录下不执行操作情况下的最大众数，然后对于每个a+k，都需要找一个区间，对于一个区间+k那么原先的a的数量就减去一个，那么可以做一次从前往后的遍历，用一个数组cnt2记录下减去每一个位置上的数（a），再把a+k加上一，如果cnt2[a]变成了负数，那么就将它变成0，就相当于这前面的数都不进行+k的操作。其实有点像双指针<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4000006</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], n, k, ans;</span><br><span class="line"><span class="type">int</span> cnt1[N], cnt2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">a[i] += <span class="number">2000000</span>;</span><br><span class="line">++cnt1[a[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">--cnt2[a[i]];</span><br><span class="line">++cnt2[a[i] + k];</span><br><span class="line">cnt2[a[i]] = <span class="built_in">max</span>(cnt2[a[i]], <span class="number">0</span>);</span><br><span class="line">ans = <span class="built_in">max</span>(ans, cnt2[a[i] + k] + cnt1[a[i] + k]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//cin&gt;&gt;T;</span></span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="ej67c"></a></p><h2 id="H-Crystalfly"><a href="#H-Crystalfly" class="headerlink" title="H.Crystalfly"></a>H.Crystalfly</h2><p>在一棵树状结构中，每个顶点上有一定的权值，从1号点开始移动，到达一个顶点时，加上该点的权值。但是当移动到一个顶点时，它的相邻节点，相邻顶点上的权值会在t时间（1≤t≤3）过后变成0。求最大的权值之和。<br>很明显的树形dp。由于t很小，可以想象一下如果走到一个节点他的相邻节点就变成0那么就变成了<a href="https://www.luogu.com.cn/problem/P1352">最大独立集问题</a>，可以发现当t≤2时其实是一样的，再考虑到只有一个节点p的儿子结点s1中t==3的节点才可以先去找另一个结点s2获取s2的权值并且不选他的儿子结点然后再返回来取s1结点和以它为根的子树的最大权值。<br>和最大独立集问题类似。<code>dp[x][1]</code> 记录子树 x 得到的最大值;dp[x][0]记录不取x的孩子所得到的最大值，<code>dp[x][0] += dp[y][1] - a[y]</code>，y属于x的儿子，<br>首先先求出<code>dp[x][1] = max(dp[x][1],dp[x][0]+a[y])</code>,然后若有一个儿子结点y的<code>t[y] = 3</code>,可以先走到另一个孩子节点y1去取再返回y取,这样就y1的孩子的权值就变成了0，即<code>dp[y1][0]</code>,这种情况下的值就变成了不取x节点的最大值加上取这个y这个点的权值加上<code>dp[y1][0]</code>再减去多算的公共部分（<code>dp[y1][1]-a[y1]</code>），即<br><code>dp[x][1]=max(dp[x][1],dp[x][0]+a[y]+dp[z][0]-(dp[z][1]-a[z]))</code><br>那么需要记录dp[z][0]-(dp[z][1]-a[z])的最大值，如果z==y那么需要用次大值进行比较<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans, dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[N], t[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> par)</span> </span>&#123;</span><br><span class="line"><span class="comment">//dp[u][0] = a[u];</span></span><br><span class="line"><span class="comment">//if(t[u] == 2) dp[]</span></span><br><span class="line"><span class="comment">//int maxn11 = 0, maxn12 = 0, maxn21 = 0, maxn22 = 0;</span></span><br><span class="line">dp[u][<span class="number">0</span>] = a[u];</span><br><span class="line"><span class="type">int</span> pos1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> maxn1 = <span class="number">-1</span>, maxn2 = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : edge[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (v == par)<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v, u);</span><br><span class="line">dp[u][<span class="number">0</span>] += dp[v][<span class="number">1</span>] - a[v];</span><br><span class="line"><span class="type">int</span> temp = dp[v][<span class="number">0</span>] - (dp[v][<span class="number">1</span>] - a[v]);</span><br><span class="line"><span class="keyword">if</span> (temp &gt; maxn1) maxn2 = maxn1, maxn1 = temp, pos1 = v;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (maxn2 &lt; temp) maxn2 = temp;</span><br><span class="line">&#125;</span><br><span class="line">dp[u][<span class="number">1</span>] = dp[u][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : edge[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (v == par) <span class="keyword">continue</span>;</span><br><span class="line">dp[u][<span class="number">1</span>] = <span class="built_in">max</span>(dp[u][<span class="number">1</span>], dp[u][<span class="number">0</span>] + a[v]);</span><br><span class="line"><span class="keyword">if</span> (t[v] == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (pos1 ^ v)dp[u][<span class="number">1</span>] = <span class="built_in">max</span>(dp[u][<span class="number">1</span>], dp[u][<span class="number">0</span>] + a[v] + maxn1);</span><br><span class="line"><span class="keyword">else</span> dp[u][<span class="number">1</span>] = <span class="built_in">max</span>(dp[u][<span class="number">1</span>], dp[u][<span class="number">0</span>] + a[v] + maxn2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) edge[i].<span class="built_in">clear</span>(), dp[i][<span class="number">1</span>] = dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; t[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">edge[u].<span class="built_in">push_back</span>(v), edge[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; dp[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a name="yHH03"></a></p><h2 id="D-Paimon-Sorting"><a href="#D-Paimon-Sorting" class="headerlink" title="D.Paimon Sorting"></a>D.Paimon Sorting</h2><p>给出一个排序算法（用伪代码表示）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序算法</span></span><br><span class="line"><span class="built_in">SORT</span>(A)</span><br><span class="line">  <span class="keyword">for</span> i from <span class="number">1</span> to n <span class="comment">// n 是序列 A 的元素个数</span></span><br><span class="line">    <span class="keyword">for</span> j from <span class="number">1</span> to n</span><br><span class="line">      <span class="keyword">if</span> a[i] &lt; a[j] <span class="comment">// a[i] 是序列 A 的第 i 个元素</span></span><br><span class="line">        Swap a[i] <span class="keyword">and</span> a[j]</span><br></pre></td></tr></table></figure></p><p>请你算出对于一个序列 $A=a_1,a_2,\cdots,a_n$ 的所有前缀 $A_k=a_1,a_2,\cdots,a_k$($1\le k\le n$)， $\operatorname{SORT}(A_k)$中的交换（Swap）操作将会被执行几次。</p><p>感觉比第四道好想一些。<br>因为程序都给你了，打表找规律就好了。<br>打表代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> random(a, b) ((a)+rand()%((b)-(a)+1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; ++i) b[i] = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= x; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] &lt; b[j]) &#123;</span><br><span class="line"><span class="built_in">swap</span>(b[i], b[j]);</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//cin &gt;&gt; n;</span></span><br><span class="line"><span class="comment">//for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i];</span></span><br><span class="line">n = <span class="built_in">random</span>(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, t; i &lt;= n; ++i) t = <span class="built_in">random</span>(<span class="number">1</span>,n),a[i] = t;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cout &lt;&lt; <span class="built_in">Sort</span>(i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>规律倒不是很好找，具体来说：<br>设 maxn 为前 n−1 个数中的最大值<br>首先当 a[i] &lt; maxn , ans += 前 n−1 个数中, 比当前数小的数的个数<br>当 a[i] = maxn时，答案不变<br>当 a[i] &gt; maxn ans += 2 + maxn第二次出现后的数的个数<br>所以可以用树状数组等查询前面比当前数小的数的个数，ac代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; (-x))</span></span><br><span class="line"><span class="type">int</span> n&#123;&#125;;</span><br><span class="line"><span class="type">int</span> a[N]&#123;&#125;, tr[N]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = u; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line">bitset&lt;N&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">st.<span class="built_in">reset</span>();</span><br><span class="line">BIT bit;</span><br><span class="line">bit.n = n;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>, maxn;</span><br><span class="line">bit.<span class="built_in">add</span>(a[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">maxn = a[<span class="number">1</span>];</span><br><span class="line">st[a[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; maxn) &#123;</span><br><span class="line">maxn = a[i];</span><br><span class="line"><span class="comment">//            int k = !st[a[i]];</span></span><br><span class="line"><span class="comment">//            ans += 2 + st.count()-k;</span></span><br><span class="line">ans += <span class="number">2</span> + cnt;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == maxn) &#123;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">cnt += flag;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans += bit.<span class="built_in">query</span>(maxn) - bit.<span class="built_in">query</span>(a[i]);</span><br><span class="line">cnt += flag;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; ans ;</span><br><span class="line"><span class="keyword">if</span> (!st[a[i]]) st[a[i]] = <span class="literal">true</span>, bit.<span class="built_in">add</span>(a[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">// freopen(&quot;my.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hack:</span></span><br><span class="line"><span class="comment">input</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 2 2 1 3</span></span><br><span class="line"><span class="comment">stand:</span></span><br><span class="line"><span class="comment">0 2 2 3 7</span></span><br><span class="line"><span class="comment">input</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">3 3 1 7 8 3 6 1</span></span><br><span class="line"><span class="comment">stand:</span></span><br><span class="line"><span class="comment">0 0 1 5 7 9 11 15</span></span><br><span class="line"><span class="comment">input</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">4 6 6 4 2 7 3</span></span><br><span class="line"><span class="comment">stand</span></span><br><span class="line"><span class="comment">0 2 2 3 5 10 13</span></span><br><span class="line"><span class="comment">input</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">6 2 6 6 2 7 6</span></span><br><span class="line"><span class="comment">stand</span></span><br><span class="line"><span class="comment">0 1 1 1 2 7 8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>如果不重复那么规律还是比较好找的</p>]]></content>
      
      
      <categories>
          
          <category> ICPC区域赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 南京 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19thZJCPC</title>
      <link href="/2023/10/26/19thZJCPC/"/>
      <url>/2023/10/26/19thZJCPC/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/103687">补题链接</a><br><a name="t28tw"></a></p><h2 id="B-JB-Loves-Comma"><a href="#B-JB-Loves-Comma" class="headerlink" title="B. JB Loves Comma"></a>B. JB Loves Comma</h2><p> 给定字符串 S，在每个 “cjb” 子串后面添加一个逗号 ,就一签到题没什么难度<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="comment">//#define N 105</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s ;</span><br><span class="line">cin &gt;&gt; s ;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; (<span class="type">int</span>)s.<span class="built_in">size</span>() ; i++) &#123;</span><br><span class="line">cout &lt;&lt; s[i] ;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; s.<span class="built_in">substr</span>(i - <span class="number">2</span>, <span class="number">3</span>) == <span class="string">&quot;cjb&quot;</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;,&quot;</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="lIZp8"></a></p><h2 id="C-JB-Wants-to-Earn-Big-Money"><a href="#C-JB-Wants-to-Earn-Big-Money" class="headerlink" title="C. JB Wants to Earn Big Money"></a>C. JB Wants to Earn Big Money</h2><p> 给定 n 个人的预期价格和股票交易价格，统计参与交易的人数。每次读入判断一下就好了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, z, ans = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; z;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, t; i &lt;= n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">ans += t &gt;= z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, t; i &lt;= m; ++i) &#123;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">ans += t &lt;= z;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a name="nhd2I"></a></p><h2 id="A-JB-Loves-Math"><a href="#A-JB-Loves-Math" class="headerlink" title="A. JB Loves Math"></a>A. JB Loves Math</h2><p>给定两个正整数 a, b，你需要选定一个正奇数 x 和一个正偶 数 y。 之后的每一步操作中，你可以将 a 增大 x 或者将 a 减小 y。 求把 a 变成 b 的最少操作次数。<br>稍微有点头疼的模拟题，要考虑一些细节<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="comment">//#define N 105</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="type">int</span> diff = <span class="built_in">abs</span>(a - b);</span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line"><span class="keyword">return</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line"><span class="keyword">if</span> (diff &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line"><span class="keyword">if</span> ((diff &gt;&gt; <span class="number">1</span>) &amp; <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((diff &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="ZuvAL"></a></p><h2 id="L-Candy-Machine"><a href="#L-Candy-Machine" class="headerlink" title="L. Candy Machine"></a>L. Candy Machine</h2><p> 给定 N 个正整数，从中选择一个子集使得严格大于该集合平均数的数字个数尽可能多。  <br>注意选的是子集，所以选的和顺序无关，不难发现从小到大添加数据是最优的，感性理解一下这样能保证每次对于平均值不会增加太多导致不行。可以用反证法证明：<br>假设不按照这样添加更优，那么必存在a&gt;b，a和b按照a,b的顺序依次进入平均值是average2，原先按照b,a顺序进入时平均值为average1，显然有average1&lt;average2,那么当有：</p><script type="math/tex; mode=display">c\in[a,b],average1</script><p>时，显然原先的排序更优于假设的排序，与假设矛盾故从小到大添加数据是最优的。<br>那么从小到大添加数据后，可以发现存在一个最小元素，在他之后的元素都是满足条件的，由于存在单调性所以考虑二分优化，使用自带的upper_bound函数找到严格大于的前一位，总复杂度O(nlogn)可以通过1e6的规模</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000006</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, l; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="type">double</span> k = sum[i] / (<span class="type">double</span>)i;</span><br><span class="line">l = <span class="built_in">upper_bound</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + i, k) - a - <span class="number">1</span>;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, i - l);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="M4MMq"></a></p><h2 id="G-Easy-Glide"><a href="#G-Easy-Glide" class="headerlink" title="G. Easy Glide"></a>G. Easy Glide</h2><p> 给定平面上 n 个滑行点以及起点 S 和终点 T。 行走速度为 V1，每次经过某个滑行点后可以按 V2 速度滑 行 3 秒。 求从 S 滑行到 T 所需的最少时间。  <br>显然可以建图，每个点之间连一条边，边权是时间，跑一遍最短路即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> walk, glid;</span><br><span class="line">PII gpos[N], s, t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">double</span>  w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> a, <span class="type">double</span> b) &#123;</span><br><span class="line">        to = a;</span><br><span class="line">        w = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;edge&gt; edge[N];</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line">bitset&lt;N&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i: edge) i.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dist, dist + N + <span class="number">1</span>, <span class="number">1e9</span>);</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> ver = heap.<span class="built_in">top</span>().second;</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i: edge[ver]) &#123;</span><br><span class="line">            <span class="type">int</span> j = i.to;</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + i.w) &#123;</span><br><span class="line">                dist[j] = dist[ver] + i.w;</span><br><span class="line">                heap.<span class="built_in">emplace</span>(dist[j], j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getT</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2, <span class="type">int</span> y1, <span class="type">int</span> y2, <span class="type">bool</span> ok)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;&#x27;(&#x27;&lt;&lt;x1&lt;&lt;&#x27;,&#x27;&lt;&lt;y1&lt;&lt;&#x27;)&#x27;&lt;&lt;&#x27;(&#x27;&lt;&lt;x2&lt;&lt;&#x27;,&#x27;&lt;&lt;y2&lt;&lt;&#x27;)&#x27;&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">    <span class="type">double</span> res, d = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x1 - x2, <span class="number">2</span>) + <span class="built_in">pow</span>(y1 - y2, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        res = d / glid;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; <span class="number">3</span>)</span><br><span class="line">            res = <span class="number">3</span> + (d - glid * <span class="number">3.0</span>) / walk;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = d / walk;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;d&lt;&lt;&#x27; &#x27;&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; gpos[i].fi &gt;&gt; gpos[i].se;</span><br><span class="line">    cin &gt;&gt; s.fi &gt;&gt; s.se &gt;&gt; t.fi &gt;&gt; t.se;</span><br><span class="line">    cin &gt;&gt; walk &gt;&gt; glid;</span><br><span class="line">    <span class="type">double</span> c = <span class="built_in">getT</span>(s.fi, t.fi, s.se, t.se, <span class="literal">false</span>);</span><br><span class="line">    edge[<span class="number">0</span>].<span class="built_in">emplace_back</span>(n + <span class="number">1</span>, c), edge[n + <span class="number">1</span>].<span class="built_in">emplace_back</span>(<span class="number">0</span>, c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        c = <span class="built_in">getT</span>(s.fi, gpos[i].fi, s.se, gpos[i].se, <span class="literal">false</span>);</span><br><span class="line">        edge[<span class="number">0</span>].<span class="built_in">emplace_back</span>(i, c), edge[i].<span class="built_in">emplace_back</span>(<span class="number">0</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        c = <span class="built_in">getT</span>(gpos[i].fi, t.fi, gpos[i].se, t.se, <span class="literal">true</span>);</span><br><span class="line">        edge[i].<span class="built_in">emplace_back</span>(n + <span class="number">1</span>, c), edge[n + <span class="number">1</span>].<span class="built_in">emplace_back</span>(i, c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            c = <span class="built_in">getT</span>(gpos[i].fi, gpos[j].fi, gpos[i].se, gpos[j].se, <span class="literal">true</span>);</span><br><span class="line">            edge[i].<span class="built_in">emplace_back</span>(j, c), edge[j].<span class="built_in">emplace_back</span>(i, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int ver = 0; ver &lt;= n + 1; ++ver) &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; ver &lt;&lt; &#x27;(&#x27; &lt;&lt; gpos[ver].fi &lt;&lt; &#x27;,&#x27; &lt;&lt; gpos[ver].se &lt;&lt; &#x27;)&#x27; &lt;&lt; &#x27;:&#x27; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//        for (auto i:edge[ver]) &#123;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; i.to &lt;&lt; &#x27;(&#x27; &lt;&lt; gpos[i.to].fi &lt;&lt; &#x27;,&#x27; &lt;&lt; gpos[i.to].se &lt;&lt; &#x27;)&#x27; &lt;&lt; &#x27;:&#x27; &lt;&lt; i.w &lt;&lt; &#x27;;&#x27;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; dijkstra();</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span> , <span class="built_in">dijkstra</span>()) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cin.tie(nullptr), cout.tie(nullptr);</span></span><br><span class="line"><span class="comment">//    ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>主要难在实现，感觉要比L题要容易想一些，需要注意的是最后一定要写<code>printf()</code>，不能直接写<code>cout</code>不加精度的控制，因为题目要求精度不低于1e-6，而cout默认是输出六位有效数字。</p><p><a name="Xp9xb"></a></p><h2 id="M-BpbBppbpBB"><a href="#M-BpbBppbpBB" class="headerlink" title="M. BpbBppbpBB"></a>M. BpbBppbpBB</h2><p> 给定使用两种印章无重叠可旋转地打印出的字符画，统计每 种印章的使用次数。<br><del>没想到正解…有空补</del><br>队友想到了用的鸡兔同笼原理，根据黑点总数和洞的总数解方程。模拟了一下然后做出来了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> c[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> n,m,black,white;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c[x][y<span class="number">-1</span>]!=<span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(c[x][y+<span class="number">2</span>]!=<span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(c[x+<span class="number">3</span>][y<span class="number">-1</span>]!=<span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(c[x+<span class="number">3</span>][y+<span class="number">2</span>]!=<span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=x;i&lt;=x+<span class="number">3</span>;++i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=y;j&lt;=y+<span class="number">1</span>;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i][j]!=<span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=x+<span class="number">1</span>;i&lt;=x+<span class="number">2</span>;++i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=y<span class="number">-1</span>;j&lt;=y<span class="number">-1</span>;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i][j]!=<span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=x+<span class="number">1</span>;i&lt;=x+<span class="number">2</span>;++i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=y+<span class="number">2</span>;j&lt;=y+<span class="number">2</span>;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i][j]!=<span class="string">&#x27;.&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">y-=<span class="number">4</span>;</span><br><span class="line">x-=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=x;i&lt;=x+<span class="number">2</span>;++i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=y;j&lt;=y+<span class="number">9</span>;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i][j]!=<span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=x+<span class="number">7</span>;i&lt;=x+<span class="number">9</span>;++i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=y;j&lt;=y+<span class="number">9</span>;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i][j]!=<span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=x+<span class="number">3</span>;i&lt;=x+<span class="number">6</span>;++i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=y;j&lt;=y+<span class="number">2</span>;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i][j]!=<span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=x+<span class="number">3</span>;i&lt;=x+<span class="number">6</span>;++i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=y+<span class="number">7</span>;j&lt;=y+<span class="number">9</span>;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i][j]!=<span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">cin&gt;&gt;c[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i][j]==<span class="string">&#x27;#&#x27;</span>)black++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i][j]==<span class="string">&#x27;.&#x27;</span>&amp;&amp;c[i][j<span class="number">-1</span>]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(i,j<span class="number">-1</span>))white++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> S=(black-white*<span class="number">73</span>)/<span class="number">27</span>,C=(white-S)/<span class="number">2</span>;</span><br><span class="line">cout&lt;&lt;C&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;S;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="zCyFc"></a></p><h2 id="I-Barbecue"><a href="#I-Barbecue" class="headerlink" title="I. Barbecue"></a>I. Barbecue</h2><p>给定一个长度为 n 的字符串 S，q 次询问，每次询问指定 S 的一个子串，两个人在该子串上进行博弈。 博弈双方轮流删去当前串开头或结尾的一个字符，碰到回文串的人输。 预测两人都按最优策略操作时最终谁会获胜。<br>没学过博弈，会了之后再补思路。Putata先手，Budada后手，手模一下可以发现最后的情况必定是形如ab,abab,ababab…这样的才能让此时的人不管是撕左边的还是右边的都会输（其实做题的时候只发现了ab这种情况才一定输，但最后结论推出来居然还是对了），所以可以发现和初始状态的长度的奇偶性有关。并且还要判断一下初始态是不是回文串，快速判断一个子串是否是回文串可以使用进制哈希，我用的是manacher（好像跑的比哈希还快一些）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000006</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MLC</span> &#123;</span><br><span class="line"><span class="type">int</span> n, p[<span class="number">2</span> * N + <span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> t[N * <span class="number">2</span> + <span class="number">3</span>], s[N + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = (<span class="type">int</span>) <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">t[++m] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) t[++m] = s[i], t[++m] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="type">int</span> mid = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; r) p[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> p[i] = <span class="built_in">min</span>(p[<span class="number">2</span> * mid - i], r - i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (i - p[i] &gt; <span class="number">0</span> &amp;&amp; i + p[i] &lt;= m &amp;&amp; t[i - p[i]] == t[i + p[i]])++p[i];</span><br><span class="line"><span class="keyword">if</span> (i + p[i] - <span class="number">1</span> &gt; r) mid = i, r = i + p[i] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; manacher&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> l, r, len;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">len = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> t = manacher.p[l + r];</span><br><span class="line"><span class="keyword">if</span> (t &gt;= len) <span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;Budada&quot;</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line"><span class="keyword">if</span> (len &amp; <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;Putata&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Budada&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>, n;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; T &gt;&gt; (manacher.s + <span class="number">1</span>);</span><br><span class="line">manacher.<span class="built_in">manacher</span>();</span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> <br>个人感觉这一年的中等偏简单题偏多但完全做对有些困难，而且因为疫情线上每队有三台电脑编辑器随便选，如果队友之间没有配合好或者没使用更好的编辑器作为辅助，容易出现一道题卡很久的情况</p>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浙江 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缺省源</title>
      <link href="/2023/10/25/%E7%BC%BA%E7%9C%81%E6%BA%90/"/>
      <url>/2023/10/25/%E7%BC%BA%E7%9C%81%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="comment">//#define N 1003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si(x) (int)(x.size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug cout&lt;&lt;<span class="string">&quot;*******\n&quot;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; fixed;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//cin&gt;&gt;T;</span></span><br><span class="line"><span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCPC模板</title>
      <link href="/2023/10/25/XCPC%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/10/25/XCPC%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="DSU"><a href="#DSU" class="headerlink" title="DSU"></a>DSU</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; par, h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DSU</span><span class="params">(<span class="type">int</span> _n)</span> : n(_n + <span class="number">1</span>), par(_n + <span class="number">1</span>), h(_n + <span class="number">1</span>) &#123;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= _n; ++i)par[i] = i;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> par[x] != x ? par[x] = <span class="built_in">find</span>(par[x]) : par[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (h[x] == h[y]) &#123;</span><br><span class="line">            h[x]++;</span><br><span class="line">            par[y] = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> h[x] &lt; h[y] ? par[x] = y : par[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="built_in">dsu</span>(N);</span><br></pre></td></tr></table></figure><h2 id="manacher"><a href="#manacher" class="headerlink" title="manacher"></a>manacher</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p数组存放</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 11000007</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MLC</span> &#123;</span><br><span class="line">    <span class="type">int</span> n&#123;&#125;, p[<span class="number">2</span> * N + <span class="number">2</span>]&#123;&#125;;</span><br><span class="line">    <span class="type">char</span> t[N * <span class="number">2</span> + <span class="number">3</span>]&#123;&#125;, s[N + <span class="number">2</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = (<span class="type">int</span>) <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">        t[++m] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) t[++m] = s[i], t[++m] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; r) p[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> p[i] = <span class="built_in">min</span>(p[<span class="number">2</span> * mid - i], r - i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (i - p[i] &gt; <span class="number">0</span> &amp;&amp; i + p[i] &lt;= m &amp;&amp; t[i - p[i]] == t[i + p[i]]) ++p[i];</span><br><span class="line">            <span class="keyword">if</span> (i + p[i] - <span class="number">1</span> &gt; r) mid = i, r = i + p[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; manacher&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个子串是不是回文串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkSubPalindrome</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> l, r, len;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">len = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> t = manacher.p[l + r];</span><br><span class="line"><span class="keyword">if</span> (t &gt;= len) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来求字符串中的最长回文串的长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMaxPalindrome</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans = <span class="built_in">max</span>(ans, p[i]);</span><br><span class="line">cout &lt;&lt; ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000006</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lps[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">char</span> s[N], p[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; (s + <span class="number">1</span>) &gt;&gt; (p + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> n = (<span class="type">int</span>) <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = (<span class="type">int</span>) <span class="built_in">strlen</span>(p + <span class="number">1</span>);</span><br><span class="line">    p[m + <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = m + <span class="number">2</span>; i &lt;= n; ++i, ++j) p[j] = s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n + m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] ^ p[j + <span class="number">1</span>]) j = lps[j];</span><br><span class="line">        j += p[i] == p[j + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> ((lps[i] = j) == m) cout &lt;&lt; (i - <span class="number">2</span> * m) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cout &lt;&lt; lps[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exkmp"><a href="#exkmp" class="headerlink" title="exkmp"></a>exkmp</h2><p>用于解决在线性复杂度的限制下统计s中每一位字符开始最多可以匹配多少位p中的字符，或者求一个字符串s和它任意后缀的最长公共前后缀的长度，与KMP算法的next数组的区别是，一个是到s[i]结束，一个是从字符s[i]开始。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 20000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,z[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> s[N],p[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exkmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = (<span class="type">int</span>)<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    m = (<span class="type">int</span>)<span class="built_in">strlen</span>(p+<span class="number">1</span>);</span><br><span class="line">    p[m+<span class="number">1</span>] = <span class="string">&#x27;~&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m+<span class="number">2</span>,j = <span class="number">1</span>;j&lt;=n;++i,++j) p[i] = s[j];</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=n+m+<span class="number">1</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r) z[i] = <span class="built_in">min</span>(z[i-l+<span class="number">1</span>],r-i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i+z[i]&lt;=n+m+<span class="number">1</span> &amp;&amp; p[z[i]+<span class="number">1</span>] == p[z[i] + i]) ++z[i];</span><br><span class="line">        <span class="keyword">if</span>(i + z[i] - <span class="number">1</span> &gt; r) l = i,r = i + z[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    z[<span class="number">1</span>] = m;</span><br><span class="line">    <span class="type">int</span> Z = <span class="number">0</span>,P = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//for(int i = 0;i&lt;=m+n+1;++i)cout&lt;&lt;z[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;++i) z[i] = i*(z[i]+<span class="number">1</span>),Z ^= z[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m+<span class="number">2</span>;i&lt;=m+n+<span class="number">1</span>;++i) z[i] = (i - m - <span class="number">1</span>) * (z[i] + <span class="number">1</span>), P ^= z[i];</span><br><span class="line">    cout&lt;&lt;Z&lt;&lt;endl&lt;&lt;P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s+<span class="number">1</span>,p+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exkmp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>给定 $ n $ 个模式串 $ s_1, s_2, \dots, s_n $ 和 $ q $ 次询问，每次询问给定一个文本串 $ t_i $，请回答 $ s_1 \sim s_n $ 中有多少个字符串 $ s_j $ 满足 $ t_i $ 是 $ s_j $ 的<strong>前缀</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3000006</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, nxt[N][<span class="number">62</span>], cnt;</span><br><span class="line"><span class="type">int</span> tot[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNum</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> x - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> x - <span class="string">&#x27;a&#x27;</span> + <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x - <span class="string">&#x27;0&#x27;</span> + <span class="number">52</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="built_in">strlen</span>(s), now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x; i &lt; len; ++i) &#123;</span><br><span class="line">        x = <span class="built_in">getNum</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span> (!nxt[now][x]) nxt[now][x] = ++cnt;</span><br><span class="line">        now = nxt[now][x];</span><br><span class="line">        ++tot[now];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="built_in">strlen</span>(s), now = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x; i &lt; len &amp;&amp; ok; ++i) &#123;</span><br><span class="line">        x = <span class="built_in">getNum</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span> (!nxt[now][x]) ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> now = nxt[now][x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ok) cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; tot[now] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">62</span>; ++j)</span><br><span class="line">            nxt[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; ++i) tot[i] = <span class="number">0</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; str, <span class="built_in">insert</span>(str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        cin &gt;&gt; str, <span class="built_in">find</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 105</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Floyd</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line">    <span class="type">int</span> dp[N][N]&#123;&#125;, n&#123;&#125;, m&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _n, <span class="type">int</span> _m)</span> </span>&#123;</span><br><span class="line">        n = _n, m = _m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= _n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= _n; ++j)</span><br><span class="line">                <span class="keyword">if</span> (i ^ j) dp[i][j] = INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; ++i)</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w, dp[u][v] = dp[v][u] = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; floyd&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="BIT"><a href="#BIT" class="headerlink" title="BIT"></a>BIT</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; (-x))</span></span><br><span class="line">T n&#123;&#125;,m&#123;&#125;,k&#123;&#125;;</span><br><span class="line">vector&lt;T&gt; a,tr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BIT</span>(T _n):<span class="built_in">n</span>(_n+<span class="number">5</span>),<span class="built_in">a</span>(_n+<span class="number">5</span>),<span class="built_in">tr</span>(_n+<span class="number">5</span>)&#123;</span><br><span class="line">k = (<span class="type">int</span>)<span class="built_in">log2</span>(_n+<span class="number">10</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = u;i&lt;=n;i += <span class="built_in">lowbit</span>(i)) tr[i] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> u ? <span class="built_in">query</span>(u - <span class="built_in">lowbit</span>(u)) + tr[u] : (T)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMax</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = k;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line"><span class="keyword">if</span>(pos + ((T)<span class="number">1</span>&lt;&lt;i)&lt;=n &amp;&amp; tr[pos + ((T)<span class="number">1</span>&lt;&lt;i)] &lt;= x)&#123;</span><br><span class="line">pos += ((T)<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">x -= tr[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间修改+单点查询</span></span><br><span class="line"><span class="comment">// for (int i = 1, t, pre = 0; i &lt;= n; ++i) cin &gt;&gt; t, bit.add(i, t - pre), pre = t;</span></span><br><span class="line"><span class="comment">// for (int i = 1, op, x, y, k; i &lt;= m; ++i) &#123;</span></span><br><span class="line"><span class="comment">// cin &gt;&gt; op ;</span></span><br><span class="line"><span class="comment">// if (op == 1) &#123;</span></span><br><span class="line"><span class="comment">// cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span></span><br><span class="line"><span class="comment">// bit.add(x, k), bit.add(y + 1, -k);</span></span><br><span class="line"><span class="comment">// &#125; else cin &gt;&gt; x, cout &lt;&lt; bit.query(x) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 单点修改+区间查询</span></span><br><span class="line"><span class="comment">// for (int i = 1, t; i &lt;= n; ++i) cin &gt;&gt; t, bit.add(i, t);</span></span><br><span class="line"><span class="comment">// for (int i = 1, op, x, y; i &lt;= m; ++i) &#123;</span></span><br><span class="line"><span class="comment">// cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span></span><br><span class="line"><span class="comment">// if (op == 1)bit.add(x, y);</span></span><br><span class="line"><span class="comment">// else cout &lt;&lt; (bit.query(y) - bit.query(x - 1)) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">高维树状数组，用的不多，单点修改+区间查询</span></span><br><span class="line"><span class="comment">int n, m;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">LL tr[N][N];</span></span><br><span class="line"><span class="comment">#define lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="comment">void add(int x, int y, int d) &#123;</span></span><br><span class="line"><span class="comment">    for (int i = x; i &lt;= n; i += lowbit(i))</span></span><br><span class="line"><span class="comment">        for (int j = y; j &lt;= m; j += lowbit(j))</span></span><br><span class="line"><span class="comment">            tr[i][j] += d;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">LL query(int x, int y) &#123;</span></span><br><span class="line"><span class="comment">    LL ret = 0;</span></span><br><span class="line"><span class="comment">    for (int i = x; i; i -= lowbit(i))</span></span><br><span class="line"><span class="comment">        for (int j = y; j; j -= lowbit(j))</span></span><br><span class="line"><span class="comment">            ret += tr[i][j];</span></span><br><span class="line"><span class="comment">    return ret;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main() &#123;</span></span><br><span class="line"><span class="comment">    //加快读入</span></span><br><span class="line"><span class="comment">    ios::sync_with_stdio(false), cin.tie(0);</span></span><br><span class="line"><span class="comment">    cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line"><span class="comment">    int opt;</span></span><br><span class="line"><span class="comment">    while (cin &gt;&gt; opt) &#123;</span></span><br><span class="line"><span class="comment">        if (opt == 1) &#123;</span></span><br><span class="line"><span class="comment">            int x, y, d;</span></span><br><span class="line"><span class="comment">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; d;</span></span><br><span class="line"><span class="comment">            add(x, y, d);</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            int x1, y1, x2, y2;</span></span><br><span class="line"><span class="comment">            cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1) &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">区间修改加单点查询就是二维差分。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Eulerian-Path"><a href="#Eulerian-Path" class="headerlink" title="Eulerian Path"></a>Eulerian Path</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EP</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si(x) (int)(x.size())</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="type">int</span> to;</span><br><span class="line"><span class="type">bool</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; D,cur;</span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; edge;</span><br><span class="line">stack&lt;T&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EP</span>(T _n,T _m):<span class="built_in">n</span>(_n),<span class="built_in">m</span>(_m),<span class="built_in">D</span>(_n+<span class="number">1</span>),<span class="built_in">cur</span>(_n+<span class="number">1</span>),<span class="built_in">edge</span>(_n+<span class="number">1</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tot = <span class="built_in">si</span>(edge[u]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i = cur[u] + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;e = edge[u][i];</span><br><span class="line"><span class="keyword">if</span> (!e.v) &#123;</span><br><span class="line">e.v = <span class="literal">true</span>;</span><br><span class="line">cur[u] = i;</span><br><span class="line"><span class="built_in">dfs</span>(e.to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">e.<span class="built_in">push</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>, st = <span class="number">0</span>, ed = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="built_in">sort</span>(edge[i].<span class="built_in">begin</span>(), edge[i].<span class="built_in">end</span>(), [&amp;](Edge x, Edge y) &#123; </span><br><span class="line"><span class="keyword">return</span> x.to &lt; y.to; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (D[i]) &#123;</span><br><span class="line">++cnt;</span><br><span class="line"><span class="keyword">if</span> (D[i] == <span class="number">-1</span>)st = i;</span><br><span class="line"><span class="keyword">if</span> (D[i] == <span class="number">1</span>)ed = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!cnt)st = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cnt != <span class="number">2</span> || !st || !ed) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(st);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void solve() &#123;</span></span><br><span class="line"><span class="comment">// int n,m;</span></span><br><span class="line"><span class="comment">// cin&gt;&gt;n&gt;&gt;m;</span></span><br><span class="line"><span class="comment">// EP ep(n,m);</span></span><br><span class="line"><span class="comment">// for (int i = 0,u,v; i &lt; m; ++i) &#123;</span></span><br><span class="line"><span class="comment">// cin&gt;&gt;u&gt;&gt;v;</span></span><br><span class="line"><span class="comment">// ep.D[u]--,ep.D[v]++;</span></span><br><span class="line"><span class="comment">// ep.edge[u].push_back(&#123;v,false&#125;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// int ok = ep.euler();</span></span><br><span class="line"><span class="comment">// if(!ok) return cout&lt;&lt;&quot;No&quot;&lt;&lt;endl,void();</span></span><br><span class="line"><span class="comment">// while (!ep.e.empty()) &#123;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; ep.e.top() &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">// ep.e.pop();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1003</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SP</span> &#123;</span><br><span class="line">    <span class="type">int</span> n&#123;&#125;, m&#123;&#125;, s&#123;&#125;, t&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> dist[N]&#123;&#125;, pre[N]&#123;&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;   <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">        <span class="type">int</span> a&#123;&#125;, b&#123;&#125;, w&#123;&#125;;</span><br><span class="line">    &#125; edges[M]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        dist[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">                <span class="keyword">if</span> (dist[b] &gt; dist[a] + w) &#123;</span><br><span class="line">                    dist[b] = dist[a] + w;</span><br><span class="line">                    pre[b] = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dist[t] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dist[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (last == s) <span class="keyword">return</span> cout &lt;&lt; s, <span class="built_in">void</span>();</span><br><span class="line">        <span class="built_in">printPath</span>(pre[last]);</span><br><span class="line">        cout &lt;&lt; last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; sp&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SP</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="type">int</span> to&#123;&#125;;</span><br><span class="line"><span class="type">int</span> w&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Edge</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">to = a;</span><br><span class="line">w = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n&#123;&#125;, s&#123;&#125;, t&#123;&#125;;</span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; edge;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dist;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SP</span>(<span class="type">int</span> _n, <span class="type">int</span> _s, <span class="type">int</span> <span class="type">_t</span>): <span class="built_in">n</span>(_n), <span class="built_in">s</span>(_s), <span class="built_in">t</span>(<span class="type">_t</span>), <span class="built_in">edge</span>(_n + <span class="number">1</span>), <span class="built_in">dist</span>(_n + <span class="number">1</span>), <span class="built_in">st</span>(_n + <span class="number">1</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">fill</span>(<span class="built_in">all</span>(dist), <span class="number">1e9</span>);</span><br><span class="line">dist[s] = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;&gt;&gt; heap;</span><br><span class="line">heap.<span class="built_in">emplace</span>(<span class="number">0</span>, s);</span><br><span class="line"><span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> ver = heap.<span class="built_in">top</span>().second;</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">st[ver] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : edge[ver]) &#123;</span><br><span class="line"><span class="type">int</span> j = i.to;</span><br><span class="line"><span class="keyword">if</span> (dist[j] &gt; dist[ver] + i.w) &#123;</span><br><span class="line">dist[j] = dist[ver] + i.w;</span><br><span class="line">heap.<span class="built_in">emplace</span>(dist[j], j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//从t点开始遍历，求出s-&gt;t的所有最短路径包含的边所构成的DAG（无向图）</span></span><br><span class="line"><span class="comment">// bitset&lt;N&gt; s;</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; g[N];</span></span><br><span class="line"><span class="comment">// void build(int u) &#123;</span></span><br><span class="line"><span class="comment">//     if (s[u]) return;</span></span><br><span class="line"><span class="comment">//     for (auto i: sp.edge[u]) &#123;</span></span><br><span class="line"><span class="comment">//         int j = i.to;</span></span><br><span class="line"><span class="comment">//         if (sp.dist[u] == sp.dist[j] + i.w) g[j].push_back(u), s[u] = true, build(j);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LCA</span> &#123;</span><br><span class="line"><span class="type">int</span> n&#123;&#125;, m&#123;&#125;, s&#123;&#125;, k&#123;&#125;;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edge;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; fa;</span><br><span class="line"></span><br><span class="line"><span class="built_in">LCA</span>(<span class="type">int</span> _n, <span class="type">int</span> _m, <span class="type">int</span> _s): <span class="built_in">n</span>(_n), <span class="built_in">m</span>(_m), <span class="built_in">s</span>(_s), <span class="built_in">edge</span>(_n + <span class="number">1</span>), <span class="built_in">d</span>(_n + <span class="number">1</span>) &#123;</span><br><span class="line">k = (<span class="type">int</span>)<span class="built_in">log2</span>((<span class="type">double</span>)_n) + <span class="number">1ll</span>;</span><br><span class="line">fa.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> par)</span> </span>&#123;</span><br><span class="line">fa[u][<span class="number">0</span>] = par, d[u] = d[par] + <span class="number">1ll</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (<span class="type">int</span>)<span class="built_in">log2</span>(d[u]); ++i) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : edge[u])</span><br><span class="line"><span class="keyword">if</span> (it ^ par) <span class="built_in">dfs</span>(it, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (d[x] &lt; d[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = k; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (d[x] - (<span class="number">1ll</span> &lt;&lt; i) &gt;= d[y]) x = fa[x][i];</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = k; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (fa[x][i] ^ fa[y][i])</span><br><span class="line">x = fa[x][i], y = fa[y][i];</span><br><span class="line"><span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n+m)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tarjan</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">    <span class="type">int</span> n&#123;&#125;, m&#123;&#125;, idx&#123;&#125;, cnt&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> dfn[N]&#123;&#125;, low[N]&#123;&#125;, bel[N]&#123;&#125;;</span><br><span class="line">    bitset&lt;N&gt; ins&#123;&#125;;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; scc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++idx;</span><br><span class="line">        ins[u] = <span class="literal">true</span>;</span><br><span class="line">        stk.<span class="built_in">push</span>(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v: e[u]) &#123;</span><br><span class="line"><span class="comment">//            if (!dfn[v]) &#123;</span></span><br><span class="line"><span class="comment">//                dfs(v);</span></span><br><span class="line"><span class="comment">//                low[u] = min(low[u], low[v]);</span></span><br><span class="line"><span class="comment">//            &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                if (ins[v]) low[u] = min(low[u], dfn[v]);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) <span class="built_in">dfs</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (ins[v]) low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> v = stk.<span class="built_in">top</span>();</span><br><span class="line">                c.<span class="built_in">push_back</span>(v);</span><br><span class="line">                ins[v] = <span class="literal">false</span>;</span><br><span class="line">                bel[v] = cnt;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (v == u) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            scc.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tarjan tarjan;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    tarjan.n = n, tarjan.m = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        tarjan.e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!tarjan.dfn[i]) tarjan.<span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it: tarjan.scc)</span><br><span class="line">        ans += it.<span class="built_in">size</span>() &gt; <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kosaraju"><a href="#Kosaraju" class="headerlink" title="Kosaraju"></a>Kosaraju</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Kosaraju</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; e[N],erev[N],out,c;</span><br><span class="line">    <span class="type">int</span> n&#123;&#125;, m&#123;&#125;;</span><br><span class="line">    bitset&lt;N&gt; vis&#123;&#125;;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; scc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v: e[u])</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) <span class="built_in">dfs</span>(v);</span><br><span class="line">        out.<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:erev[u])</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]) <span class="built_in">dfs2</span>(v);</span><br><span class="line">        c.<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">kosaraju</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">        <span class="built_in">reverse</span>(out.<span class="built_in">begin</span>(),out.<span class="built_in">end</span>());</span><br><span class="line">        vis.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> u:out)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">                c.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="built_in">dfs2</span>(u);</span><br><span class="line">                scc.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Kosaraju scc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    scc.n = n, scc.m = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        scc.e[u].<span class="built_in">push_back</span>(v),scc.erev[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    scc.<span class="built_in">kosaraju</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it: scc.scc)</span><br><span class="line">        ans += it.<span class="built_in">size</span>() &gt; <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MST"><a href="#MST" class="headerlink" title="MST"></a>MST</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MST</span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; par;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>,3&gt;&gt; edge;</span><br><span class="line"><span class="built_in">MST</span>(<span class="type">int</span> _n,<span class="type">int</span> _m) : <span class="built_in">n</span>(_n),<span class="built_in">m</span>(_m),<span class="built_in">edge</span>(_m)&#123;</span><br><span class="line">par.<span class="built_in">assign</span>(_n + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=_n;++i) par[i] = i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">krus</span><span class="params">()</span></span>&#123;</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span> x)&gt; find = [&amp;](<span class="type">int</span> x)-&gt;<span class="type">int</span>&#123;</span><br><span class="line"><span class="keyword">return</span> par[x] == x ? par[x] : par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(edge));</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [w,u,v] : edge)&#123;</span><br><span class="line"><span class="type">int</span> pa = <span class="built_in">find</span>(u),pb = <span class="built_in">find</span>(v);</span><br><span class="line"><span class="keyword">if</span>(pa == pb) <span class="keyword">continue</span>;</span><br><span class="line">par[pa] = pb;</span><br><span class="line">ans += w;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt == n - <span class="number">1</span> ? ans : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ST</span> &#123;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">vector&lt;T&gt; a;</span><br><span class="line">vector&lt;vector&lt;T&gt;&gt; stTable;</span><br><span class="line"><span class="built_in">ST</span>(T _n, <span class="type">const</span> vector&lt;T&gt;&amp; input): <span class="built_in">n</span>(_n), <span class="built_in">a</span>(input) &#123;</span><br><span class="line">k = (<span class="type">int</span>)(<span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">stTable.<span class="built_in">assign</span>(_n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;T&gt;(k + <span class="number">1</span>, (T)<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) stTable[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span> - ((T)<span class="number">1</span> &lt;&lt; i); ++j) &#123;</span><br><span class="line">stTable[j][i] = <span class="built_in">max</span>(stTable[j][i - <span class="number">1</span>], stTable[j + ((T)<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> p = (<span class="type">int</span>) (<span class="built_in">log</span>(len) / <span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(stTable[l][p], stTable[r - ((T)<span class="number">1</span> &lt;&lt; p) + <span class="number">1</span>][p]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void solve() &#123;</span></span><br><span class="line"><span class="comment">// int n, m;</span></span><br><span class="line"><span class="comment">// cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; a(n + 1);</span></span><br><span class="line"><span class="comment">// for (int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i];</span></span><br><span class="line"><span class="comment">// ST&lt;int&gt; sTable(n, a);</span></span><br><span class="line"><span class="comment">// while (m--) &#123;</span></span><br><span class="line"><span class="comment">// int l, r;</span></span><br><span class="line"><span class="comment">// cin &gt;&gt; l &gt;&gt; r;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; sTable.query(l, r) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> p, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> base = x;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>) (res *= base) %= m;</span><br><span class="line">(base *= base) %= m;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res % m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>基于DFS的拓扑排序</p><p>递归有一个特点，就是输出的顺序是倒序，所以如果要正序输出则需要将它先存放进栈里面再输出。并且DFS也可以按照字典序输出所有的拓扑排序。poj 1270，P608</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Topo</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; d, q;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edge;</span><br><span class="line"><span class="built_in">Topo</span>(<span class="type">int</span> _n): <span class="built_in">n</span>(_n), <span class="built_in">d</span>(_n + <span class="number">1</span>), <span class="built_in">q</span>(_n), <span class="built_in">edge</span>(_n + <span class="number">1</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">edge[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">d[v]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (!d[i])</span><br><span class="line">q[tt++] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt) &#123;</span><br><span class="line"><span class="type">int</span> u = q[hh++];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : edge[u])</span><br><span class="line"><span class="keyword">if</span> (--d[v] == <span class="number">0</span>)</span><br><span class="line">q[tt++] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isHavTopo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">toposort</span>() == n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTopoSort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : q) cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p><a href="https://www.luogu.com.cn/problem/P2756">模板：P2756 飞行员配对方案问题</a></p><p>建议是直接全写在一个结构体里面，因为二分图往往要建边，边数不对就容易re，结构体可以在初始化的时候就申请所需要的空间并且不会浪费，注意与正常的模板相比初始化要改成-1，因为迭代的时候有时是从下标为0开始的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> wr &#123;&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> wr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NTR</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vis, st;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edge;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NTR</span>(<span class="type">int</span> n, <span class="type">int</span> m) : <span class="built_in">n</span>(n), <span class="built_in">vis</span>(m), <span class="built_in">st</span>(m), <span class="built_in">edge</span>(n) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; edge[l].<span class="built_in">push_back</span>(r); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">any_of</span>(edge[u].<span class="built_in">begin</span>(), edge[u].<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st[v]++ == <span class="number">0</span> &amp;&amp; (vis[v] == <span class="number">-1</span> || <span class="built_in">find</span>(vis[v]))) &#123;</span><br><span class="line">                vis[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">match</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fill</span>(vis.<span class="built_in">begin</span>(), vis.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">fill</span>(st.<span class="built_in">begin</span>(), st.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">            ans += <span class="built_in">find</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="comment">//申请的时候要注意下标是从0开始还是1开始，如果是1开始那么点数还要加1</span></span><br><span class="line">    <span class="function">NTR <span class="title">ntr</span><span class="params">(n + <span class="number">1</span>, m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a, b;;) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a), <span class="built_in">read</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">-1</span> &amp;&amp; b == <span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">        ntr.<span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ntr.<span class="built_in">match</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ntr.vis[i] != <span class="number">-1</span>) <span class="built_in">write</span>(ntr.vis[i], <span class="string">&#x27; &#x27;</span>), <span class="built_in">write</span>(i, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 染色法标记集合，或者用于求这个图是不是二分图</span></span><br><span class="line">function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u, <span class="type">int</span> par, <span class="type">int</span> c)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : edge[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == par)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!color[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(v, u, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color[v] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="exgcd"><a href="#exgcd" class="headerlink" title="exgcd"></a>exgcd</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">y -= (a / b) * x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c ;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> d = <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line"><span class="keyword">if</span> (c % d) <span class="keyword">return</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">a /= d;</span><br><span class="line">b /= d;</span><br><span class="line">c /= d;</span><br><span class="line"><span class="type">int</span> xx = x * (c % b) % b;</span><br><span class="line"><span class="keyword">if</span> (xx &lt; <span class="number">0</span>) xx += b;</span><br><span class="line"><span class="type">int</span> yy = (c - a * xx) / b;</span><br><span class="line">    <span class="comment">// xx yy 是一组特解，其中xx是最小的正数，如果yy不是大于0那么最小非负整数无解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EulerSieve</span>&#123;</span><br><span class="line">    bitset&lt;N+5&gt; isprime;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Euler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isprime[i]) prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; prime.<span class="built_in">size</span>() &amp;&amp; i * prime[j] &lt;= N; ++j) &#123;</span><br><span class="line">                isprime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sieve;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,q,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    sieve.<span class="built_in">Euler</span>();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        cout&lt;&lt;sieve.prime[t<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    cin&gt;&gt;T;</span></span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="素数逆元"><a href="#素数逆元" class="headerlink" title="素数逆元"></a>素数逆元</h2><p>模运算下除以一个整数，就相当于乘以这个整数的乘法逆元</p><p>因为$ ax\equiv 1(mod\ b) $</p><p>费马小定理得$ ax\equiv a^{b-1}(mod\ b) $</p><p>所以$ x\equiv a^{b-2}(mod\ b) $</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">modularInverse</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  a = (a % p + p) % p;</span><br><span class="line">  <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (a * ans) % p;</span><br><span class="line">    a = (a * a) % p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中p必须是质数</p><h2 id="欧拉函数-简化剩余系"><a href="#欧拉函数-简化剩余系" class="headerlink" title="欧拉函数/简化剩余系"></a>欧拉函数/简化剩余系</h2><p>欧拉函数：把对模m的简化剩余系的元素个数称为m的欧拉函数，记为Φ(m).</p><p>容斥原理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> phin = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">2</span>;d*d&lt;=n;++d)</span><br><span class="line"><span class="keyword">if</span>(n%d == <span class="number">0</span>)&#123;</span><br><span class="line">phin = phin/d*(d<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(n%d == <span class="number">0</span>) n/=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n!=<span class="number">1</span>) phin = phin / n *(n<span class="number">-1</span>);</span><br><span class="line">cout&lt;&lt;phin&lt;&lt;endl;</span><br><span class="line"><span class="comment">//  这里φ(1) = 1，实际上是0</span></span><br></pre></td></tr></table></figure><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回有序数组（下标从1到n）中小于x的元素的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = num + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &lt; x) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这种写法是将l和r考虑为找分界线的作用，在l的右边</span></span><br><span class="line"><span class="comment">//都是不满足条件的，r的左边都是满足条件的。最后的</span></span><br><span class="line"><span class="comment">//情况是分界线卡在l和r的中间，注意l和r的定义，所以</span></span><br><span class="line"><span class="comment">//l和r的初始化必须要这样设置</span></span><br><span class="line"><span class="comment">//lowerbound版</span></span><br><span class="line"><span class="comment">//后继</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bin_search1</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;<span class="comment">//left + ((right - left) &gt;&gt; 1)（1）</span></span><br><span class="line"><span class="keyword">if</span> (a[mid] &gt;= x)</span><br><span class="line">right = mid;<span class="comment">//（2）</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;<span class="comment">//（3）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;<span class="comment">//（4）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前驱</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bin_search2</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> mid = (left + right+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;<span class="comment">//mid = left + ((right - left + 1) &gt;&gt; 1)（1）</span></span><br><span class="line"><span class="keyword">if</span> (a[mid] &lt;= x)</span><br><span class="line">left = mid;<span class="comment">//（2）</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right = mid - <span class="number">1</span>;<span class="comment">//（3）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;<span class="comment">//（4）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分答案</span></span><br><span class="line"><span class="comment">//后继</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bin_search1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">check1</span>()) &#123;<span class="comment">//left&lt;right</span></span><br><span class="line"><span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;<span class="comment">//left + ((right - left) &gt;&gt; 1)（1）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check2</span>(mid))</span><br><span class="line">right = mid;<span class="comment">//（2）</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;<span class="comment">//（3）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;<span class="comment">//（4）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前驱</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bin_search2</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">check1</span>()) &#123;<span class="comment">//left&lt;right</span></span><br><span class="line"><span class="type">int</span> mid = left + right+<span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//mid = left + ((right - left + 1) &gt;&gt; 1)（1）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check2</span>(mid))</span><br><span class="line">left = mid;<span class="comment">//（2）</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right = mid - <span class="number">1</span>;<span class="comment">//（3）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;<span class="comment">//（4）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h2><p>一个字符串，这个字符串的首尾是连在一起的，要求寻找一个位置，以该位置为起点的字符串的字典序在所有的字符串中中最小，复杂度为线性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 300005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[N*<span class="number">2</span> + <span class="number">2</span>],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">read</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i)<span class="built_in">read</span>(s[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i)s[i+n] = s[i];</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>,j=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=n&amp;&amp;j&lt;=n)&#123;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(s[i+k] == s[j+k]) ++k;</span><br><span class="line"><span class="keyword">if</span>(s[i+k]&gt;s[j+k])i+=k+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> j += k+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i==j)++j;</span><br><span class="line"><span class="keyword">if</span>(i&gt;j)<span class="built_in">swap</span>(i,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l = i;l&lt;n+i;++l)<span class="built_in">write</span>(s[l],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="O-n-求-1-n-的素数逆元"><a href="#O-n-求-1-n-的素数逆元" class="headerlink" title="O(n)求[1,n]的素数逆元"></a>O(n)求[1,n]的素数逆元</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>) inv[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> inv[i] = (mod - mod/i)*inv[mod%i]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="01Trie"><a href="#01Trie" class="headerlink" title="01Trie"></a>01Trie</h2><p><a href="https://z01prime.github.io/2024/02/13/01%E5%AD%97%E5%85%B8%E6%A0%91/">https://z01prime.github.io/2024/02/13/01%E5%AD%97%E5%85%B8%E6%A0%91/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="type">int</span> nxt[N][<span class="number">2</span>],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">8</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"><span class="type">int</span> y = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(nxt[u][y]) u = nxt[u][y];</span><br><span class="line"><span class="keyword">else</span> nxt[u][y] = ++cnt,u = nxt[u][y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> u = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">8</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"><span class="type">int</span> y = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(nxt[u][y^<span class="number">1</span>]) sum += (<span class="number">1</span>&lt;&lt;i),u = nxt[u][y^<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> u = nxt[u][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=cnt;++i) nxt[i][<span class="number">1</span>] = nxt[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i],a[i] ^= a[i<span class="number">-1</span>],<span class="built_in">insert</span>(a[i]);</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i) ans = <span class="built_in">max</span>(&#123;ans,<span class="built_in">find</span>(a[i]),a[i]&#125;);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合数学相关"><a href="#组合数学相关" class="headerlink" title="组合数学相关"></a>组合数学相关</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, fact[N], invFact[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= mod;</span><br><span class="line">(a *= a) %= mod;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fact[<span class="number">0</span>] = fact[<span class="number">1</span>] = invFact[<span class="number">0</span>] = invFact[<span class="number">1</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">inv[i] = (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">invFact[i] = invFact[i - <span class="number">1</span>] * inv[i] % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m || m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fact[n] * invFact[n - m] % mod * invFact[m] % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="excrt"><a href="#excrt" class="headerlink" title="excrt"></a>excrt</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">slow_mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>)(ans += x) %= mod;</span><br><span class="line">(x += x) %= mod;</span><br><span class="line">y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">y -= a / b * x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">crt</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b, <span class="type">int</span> c, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">-1</span> &amp;&amp; b == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> g = <span class="built_in">exgcd</span>(b, d, x, y);</span><br><span class="line">(c = c - a % d + d) %= d;</span><br><span class="line"><span class="keyword">if</span> (c % g) <span class="keyword">return</span> a = b = <span class="number">-1</span>, <span class="built_in">void</span>();</span><br><span class="line">d /= g;</span><br><span class="line"><span class="comment">//int x0 = (c / g) % d * x % d;</span></span><br><span class="line"><span class="type">int</span> x0 = <span class="built_in">slow_mul</span>((c / g + d) % d, (x + d) % d, d);</span><br><span class="line"><span class="keyword">if</span> (x0 &lt; <span class="number">0</span>) x0 += d;</span><br><span class="line">a = b * x0 + a;</span><br><span class="line">b = b * d;</span><br><span class="line">a = (a % b + b) % b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, c, d; i &lt;= n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; d &gt;&gt; c;</span><br><span class="line"><span class="built_in">crt</span>(a, b, c, d);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="segmentTree"><a href="#segmentTree" class="headerlink" title="segmentTree"></a>segmentTree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jiangly</span></span><br><span class="line"><span class="comment">template&lt;class Info&gt; 是 C++ 中的模板声明。它指示编译器该类或函数是一个模板，并且其参数是一个名为 Info 的类型参数。</span></span><br><span class="line"><span class="comment">模板允许您编写通用的类或函数，其行为可以针对不同的类型进行参数化。在这种情况下，</span></span><br><span class="line"><span class="comment">SegmentTree 是一个类模板，Info 是模板的类型参数。</span></span><br><span class="line"><span class="comment">这意味着您可以在实例化 SegmentTree 类时指定不同的类型作为 Info，从而创建不同类型的线段树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Info</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::vector&lt;Info&gt; info;</span><br><span class="line"><span class="comment">//默认构造函数。当您创建一个新的 SegmentTree 对象时，如果没有提供任何参数，就会调用这个默认构造函数。</span></span><br><span class="line"><span class="built_in">SegmentTree</span>() : <span class="built_in">n</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="comment">//这是带参数的构造函数。它用于创建一个具有指定大小的线段树对象，并且可以选择性地为每个节点指定初始值。</span></span><br><span class="line"><span class="comment">//n_ 表示线段树的大小，即包含的元素数量。参数 v_ 是可选的，默认为 Info()，</span></span><br><span class="line"><span class="comment">//这里的 Info() 是 Info 类的默认构造函数，用于创建一个默认的 Info 对象。</span></span><br><span class="line"><span class="comment">//比如SegmentTree&lt;Info&gt; s(n);Info是一个结构体或者是int之类的一种数据类型。就会用到这个构造方法</span></span><br><span class="line"><span class="built_in">SegmentTree</span>(<span class="type">int</span> n_, Info v_ = <span class="built_in">Info</span>()) &#123;</span><br><span class="line"><span class="built_in">init</span>(n_, v_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="title">SegmentTree</span><span class="params">(std::vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line"><span class="built_in">init</span>(init_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个 init 函数实际上是调用了第二个 init 函数，这是一种比较常见的设计模式，称为函数重载。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_, Info v_ = Info())</span> </span>&#123;</span><br><span class="line"><span class="built_in">init</span>(std::<span class="built_in">vector</span>&lt;Info&gt;(n_, v_));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line">n = init_.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//初始化 info 向量，使其大小为 4 * 2^log₂(n)，并将所有元素的值设置为 Info() 的默认构造值。</span></span><br><span class="line">info.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; std::__lg(n), <span class="built_in">Info</span>());</span><br><span class="line"><span class="comment">//build函数</span></span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">info[p] = init_[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">2</span> * p, l, m);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r);</span><br><span class="line"><span class="built_in">pull</span>(p);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从上往下传递区间值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">info[p] = info[<span class="number">2</span> * p] + info[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">info[p] = v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">2</span> * p, l, m, x, v);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pull</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询</span></span><br><span class="line"><span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line"><span class="keyword">return</span> info[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p, l, m, x, y) + <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码实现了线段树中的范围查询功能，具体来说是实现了查找满足特定条件的第一个元素的位置。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= y || r &lt;= x || !<span class="built_in">pred</span>(info[p])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">findFirst</span>(<span class="number">2</span> * p, l, m, x, y, pred);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">res = <span class="built_in">findFirst</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">findFirst</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= y || r &lt;= x || !<span class="built_in">pred</span>(info[p])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">findLast</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">res = <span class="built_in">findLast</span>(<span class="number">2</span> * p, l, m, x, y, pred);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">findLast</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line"><span class="type">int</span> max1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> max2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt2 = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Info <span class="keyword">operator</span>+(Info a, Info b) &#123;</span><br><span class="line"><span class="comment">//Info c;</span></span><br><span class="line"><span class="keyword">if</span> (a.max1 == b.max1) &#123;</span><br><span class="line"><span class="keyword">if</span> (a.max2 &lt; b.max2) <span class="built_in">swap</span>(a, b);</span><br><span class="line"><span class="comment">//if(a.max2 == b.max2) c.cnt2 = a.cnt2 + b.cnt2;</span></span><br><span class="line">a.cnt1 += b.cnt1;</span><br><span class="line"><span class="comment">//c.cnt1 = a.cnt1 + b.cnt1;</span></span><br><span class="line"><span class="keyword">if</span> (a.max2 == b.max2) a.cnt2 += b.cnt2;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a.max1 &lt; b.max1)<span class="built_in">swap</span>(a, b);</span><br><span class="line"><span class="keyword">if</span> (a.max2 == b.max1) a.cnt2 += b.cnt1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a.max2 &lt; b.max1) &#123;</span><br><span class="line">a.cnt2 = b.cnt1;</span><br><span class="line">a.max2 = b.max1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模2的64次意义下的long-long取模"><a href="#模2的64次意义下的long-long取模" class="headerlink" title="模2的64次意义下的long long取模"></a>模2的64次意义下的long long取模</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y, <span class="type">long</span> <span class="type">long</span> m)</span> </span>&#123;</span><br><span class="line">x %= m, y %= m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> d = ((<span class="type">long</span> <span class="type">double</span>)x * y / m);</span><br><span class="line">d = x * y - d * m;</span><br><span class="line"><span class="keyword">if</span> (d &gt;= m) d -= m;</span><br><span class="line"><span class="keyword">if</span> (d &lt; <span class="number">0</span>) d += m;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求1-n的所有n/i的值的和，根号复杂度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; ++l) &#123;</span><br><span class="line">    <span class="type">int</span> d = n / l, r = n/d;</span><br><span class="line">    ans += (r-l+<span class="number">1</span>)*d;</span><br><span class="line">    l = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floordiv-ceildiv"><a href="#floordiv-ceildiv" class="headerlink" title="floordiv/ceildiv"></a>floordiv/ceildiv</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">floordiv</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a % b == <span class="number">0</span>) <span class="keyword">return</span> a / b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a &gt; <span class="number">0</span>) <span class="keyword">return</span> a / b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a / b - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ceildiv</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a % b == <span class="number">0</span>) <span class="keyword">return</span> a / b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a &gt; <span class="number">0</span>) <span class="keyword">return</span> a / b + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带模运算的行列式求值"><a href="#带模运算的行列式求值" class="headerlink" title="带模运算的行列式求值"></a>带模运算的行列式求值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">det</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; d, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = (<span class="type">int</span>)d.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line"><span class="keyword">while</span> (d[i][i]) &#123;</span><br><span class="line"><span class="type">int</span> div = d[j][i] / d[i][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; n; ++k)</span><br><span class="line">(d[j][k] = d[j][k] - div * d[i][k] % p + p) %= p;</span><br><span class="line">w = -w;</span><br><span class="line"><span class="built_in">swap</span>(d[i], d[j]);</span><br><span class="line">&#125;</span><br><span class="line">w = -w;</span><br><span class="line"><span class="built_in">swap</span>(d[i], d[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) (w *= d[i][i]) %= p;</span><br><span class="line"><span class="keyword">return</span> (w + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>trick</title>
      <link href="/2023/10/05/trick/"/>
      <url>/2023/10/05/trick/</url>
      
        <content type="html"><![CDATA[<p>本文用来记录一些做题时看到的小技巧以及踩过的坑<br><a name="s6d6l"></a></p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p><a name="xaLOm"></a></p><h2 id="bool可以直接作为参数传递："><a href="#bool可以直接作为参数传递：" class="headerlink" title="bool可以直接作为参数传递："></a>bool可以直接作为参数传递：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> m,<span class="type">int</span> n,<span class="type">int</span> next)</span></span>&#123; </span><br><span class="line"><span class="keyword">if</span>(next&gt;=<span class="number">8</span>)&#123;</span><br><span class="line">s[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i+m][j+n]==k[next]) </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(i+m,j+n,m,n,next+<span class="number">1</span>))&#123;</span><br><span class="line">    s[i][j]=<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br></pre></td></tr></table></figure><p><a name="Ccyul"></a></p><h2 id="清除缓冲区"><a href="#清除缓冲区" class="headerlink" title="清除缓冲区"></a>清除缓冲区</h2><p>printf(“字符串”);后面加fflush(stdout)；cout使用endl。<br><a name="hSZJf"></a></p><h2 id="bool类型可以用bitset代替"><a href="#bool类型可以用bitset代替" class="headerlink" title="bool类型可以用bitset代替"></a>bool类型可以用bitset代替</h2><p><a href="https://blog.nowcoder.net/n/45218f11e93842788069886a6d097484?from=nowcoder_improve">C++ bitset用法_牛客博客</a><br><a name="U9Zy5"></a></p><h2 id="递归可以实现倒序"><a href="#递归可以实现倒序" class="headerlink" title="递归可以实现倒序"></a>递归可以实现倒序</h2><p>十进制转二进制输出<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    r = num%<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&gt;=<span class="number">2</span>) <span class="built_in">toBin</span>(num/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r) cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用递归解决了倒取余数的问题而递归条件是num&gt;=2而不是0可以解决了判断num为1时不需要输出0的情况<br><a name="cblnK"></a></p><h2 id="取字符串首尾："><a href="#取字符串首尾：" class="headerlink" title="取字符串首尾："></a>取字符串首尾：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="keyword">while</span>(s[i] != <span class="number">0</span>) ++i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,s[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure><p>现在复习回来看到发现这个好像没什么用…<br>2023/10/05<br><a name="rsGEE"></a></p><h2 id="while-cin-gt-gt-a-："><a href="#while-cin-gt-gt-a-：" class="headerlink" title="while(cin&gt;&gt;a)："></a>while(cin&gt;&gt;a)：</h2><p>重载操作符的返回值：由cin&gt;&gt;后续参数类型决定，其返回值类型为istream&amp;类型，大多数情况下其返回值为cin本身（非0值），只有当遇到EOF输入时，返回值为0。</p><p><a name="oTzHq"></a></p><h2 id="取余："><a href="#取余：" class="headerlink" title="取余："></a>取余：</h2><p>1、取余是为了防止溢出，<br>2、但是在取了余数之后，有可能成为负数，<br>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fib[i] = fib[i - <span class="number">1</span>] * <span class="number">2</span> - fib[i - k - <span class="number">1</span>];</span><br><span class="line">fib[i] %= m;</span><br></pre></td></tr></table></figure><br>所以要<code>(fib[n] + m) % m</code><br>3、<code>(a *= b)%=mod;</code>&lt;-&gt;<code>a *= b;a %= mod;</code><br><a name="gcqwo"></a></p><h2 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h2><p>c++实现多行输出<br>c++11标准规定了一个原始字符串： raw string literal<br>以   R”(  开头， )” 结束，是可以跨越多行的字符串字面值，转义字符如 \t\n 在raw string literal中是普通的文本，而不再是转义字符，<br>如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">R&quot;(                ********</span></span><br><span class="line"><span class="string">               ************</span></span><br><span class="line"><span class="string">               ####....#.</span></span><br><span class="line"><span class="string">             #..###.....##....</span></span><br><span class="line"><span class="string">             ###.......######              ###            ###</span></span><br><span class="line"><span class="string">                ...........               #...#          #...#</span></span><br><span class="line"><span class="string">               ##*#######                 #.#.#          #.#.#</span></span><br><span class="line"><span class="string">            ####*******######             #.#.#          #.#.#</span></span><br><span class="line"><span class="string">           ...#***.****.*###....          #...#          #...#</span></span><br><span class="line"><span class="string">           ....**********##.....           ###            ###</span></span><br><span class="line"><span class="string">           ....****    *****....</span></span><br><span class="line"><span class="string">             ####        ####</span></span><br><span class="line"><span class="string">           ######        ######</span></span><br><span class="line"><span class="string">##############################################################</span></span><br><span class="line"><span class="string">#...#......#.##...#......#.##...#......#.##------------------#</span></span><br><span class="line"><span class="string">###########################################------------------#</span></span><br><span class="line"><span class="string">#..#....#....##..#....#....##..#....#....#####################</span></span><br><span class="line"><span class="string">##########################################    #----------#</span></span><br><span class="line"><span class="string">#.....#......##.....#......##.....#......#    #----------#</span></span><br><span class="line"><span class="string">##########################################    #----------#</span></span><br><span class="line"><span class="string">#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#</span></span><br><span class="line"><span class="string">##########################################    ############ )&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">                ********</span><br><span class="line">               ************</span><br><span class="line">               ####....#.</span><br><span class="line">             #..###.....##....</span><br><span class="line">             ###.......######              ###            ###</span><br><span class="line">                ...........               #...#          #...#</span><br><span class="line">               ##*#######                 #.#.#          #.#.#</span><br><span class="line">            ####*******######             #.#.#          #.#.#</span><br><span class="line">           ...#***.****.*###....          #...#          #...#</span><br><span class="line">           ....**********##.....           ###            ###</span><br><span class="line">           ....****    *****....</span><br><span class="line">             ####        ####</span><br><span class="line">           ######        ######</span><br><span class="line">##############################################################</span><br><span class="line">#...#......#.##...#......#.##...#......#.##------------------#</span><br><span class="line">###########################################------------------#</span><br><span class="line">#..#....#....##..#....#....##..#....#....#####################</span><br><span class="line">##########################################    #----------#</span><br><span class="line">#.....#......##.....#......##.....#......#    #----------#</span><br><span class="line">##########################################    #----------#</span><br><span class="line">#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#</span><br><span class="line">##########################################    ############</span><br></pre></td></tr></table></figure><br><a name="NYtqG"></a></p><h2 id="基于范围的-for-循环："><a href="#基于范围的-for-循环：" class="headerlink" title="基于范围的 for 循环："></a>基于范围的 for 循环：</h2><p>在 C++11 及更高版本中推荐的方法是迭代 a 的字符 std::string 使用基于范围的 for 循环。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string dq2 = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> &amp;c : dq2) &#123;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">使用引用可以节省复制字符串所需要的时间</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>注意在使用stl容器时定义了容器为string类型则不能使用char类型引用，会出现[错误] invalid initialization of reference of 类型 ‘char&amp;’ 从 表达式 of type ‘std::__cxx11::basic_string<char>‘<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">deque&lt;string&gt; dq1, dq2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dq1.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (string &amp;c : dq1) &#123;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果使用char &amp;，则会有</span></span><br><span class="line"><span class="comment">//nvalid initialization of reference of类型 &#x27;char&amp;&#x27; 从 表达式 of type &#x27;std::__cxx11::basic_string&lt;char&gt;&#x27;的错误提示</span></span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp; i : v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(isBoundary[temp.first+i[<span class="number">0</span>]][temp.second+i[<span class="number">1</span>]]||isDraw[temp.first+i[<span class="number">0</span>]][temp.second+i[<span class="number">1</span>]]))&#123;</span><br><span class="line">        isDraw[temp.first+i[<span class="number">0</span>]][temp.second+i[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">emplace</span>(temp.first+i[<span class="number">0</span>],temp.second+i[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除此之外，像<code>for (auto cur: &#123;4, 2, 1&#125;)</code>这样的也是合法的 </char></p><p><a name="SZmnB"></a></p><h2 id="加快cin-cout的方法"><a href="#加快cin-cout的方法" class="headerlink" title="加快cin cout的方法"></a>加快cin cout的方法</h2><p>对于大输入输出可以快2-3倍<br>注意不要和printf，scanf等C语言的输出输入函数混用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解除与C语言的绑定，加快cincout执行速度</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><br><a name="UB8Z5"></a></p><h2 id="获取int最大值："><a href="#获取int最大值：" class="headerlink" title="获取int最大值："></a>获取int最大值：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans = (<span class="type">unsigned</span>)(<span class="number">-1</span>) &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><a name="g5wdI"></a></p><h2 id="使用auto关键字代替冗长的定义如："><a href="#使用auto关键字代替冗长的定义如：" class="headerlink" title="使用auto关键字代替冗长的定义如："></a>使用auto关键字代替冗长的定义如：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; l;</span><br><span class="line">l.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">l.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">l.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = l.<span class="built_in">begin</span>(); p != l.<span class="built_in">end</span>(); p++)<span class="comment">//auto == list&lt;int&gt; ::iterator</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="EEXqD"></a></p><h2 id="read快读"><a href="#read快读" class="headerlink" title="read快读"></a>read快读</h2><p>留坑待填<br><a href="https://blog.csdn.net/tkzlfg/article/details/110288548#:~:text=%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%9A%20inline%20void%20read%28unsigned%20long%20long%20%26a%29%7B%20a%3D0%3B,while%28%28c%3Dgetchar%28%29%29%3C48%29%3B%20do%20a%3D%2A10%2B%28c%5E48%29%3B%20while%28%28c%3Dgetchar%28%29%29%3E47%29%3B%20%7D%20%E8%BF%99%E7%A7%8D%E5%8A%9E%E6%B3%95%E4%BB%85%E9%80%82%E7%94%A8%E4%BA%8E%E4%B8%8D%E5%A4%A7%E4%BA%8E%20264%20%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0%E3%80%82">C/C++中最快、最简洁的read()快读(卡常数)方法</a><br><a href="https://www.cnblogs.com/lingyunvoid/p/15204568.html">https://www.cnblogs.com/lingyunvoid/p/15204568.html</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wr &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">        T a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ch != <span class="string">&#x27;-&#x27;</span> &amp;&amp; (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)) ch = (<span class="type">char</span>) <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            b = <span class="number">-1</span>;</span><br><span class="line">            ch = (<span class="type">char</span>) <span class="built_in">getchar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            a = ((T) a &lt;&lt; <span class="number">3</span>) + ((T) a &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            ch = (<span class="type">char</span>) <span class="built_in">getchar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        x = a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">            x = -x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">9</span>) <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;\0&#x27;</span>) <span class="built_in">putchar</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> wr;</span><br></pre></td></tr></table></figure><br><a name="ECP1B"></a></p><h2 id="scanf可以加上一些参数使得读入的时候能够读取固定长度，如“-1d”"><a href="#scanf可以加上一些参数使得读入的时候能够读取固定长度，如“-1d”" class="headerlink" title="scanf可以加上一些参数使得读入的时候能够读取固定长度，如“%1d”"></a>scanf可以加上一些参数使得读入的时候能够读取固定长度，如“%1d”</h2><p><a name="xNt0C"></a></p><h2 id="输入预处理（二分插入排序）"><a href="#输入预处理（二分插入排序）" class="headerlink" title="输入预处理（二分插入排序）"></a>输入预处理（二分插入排序）</h2><p><a name="ruXtB"></a></p><h2 id="vectora-a-insert-upper-bound-a-begin-a-end-x-x-二分插入保证单调性"><a href="#vectora-a-insert-upper-bound-a-begin-a-end-x-x-二分插入保证单调性" class="headerlink" title="vectora;a.insert(upper_bound(a.begin(),a.end(),x),x);//二分插入保证单调性"></a>vector<int>a;<br>a.insert(upper_bound(a.begin(),a.end(),x),x);//二分插入保证单调性</int></h2><p><a name="OGa85"></a></p><h2 id="关于断环为链的思想"><a href="#关于断环为链的思想" class="headerlink" title="关于断环为链的思想"></a>关于断环为链的思想</h2><p>有时题目会要求让你处理一个环，也就是一个环形链表，但是比赛没有时间手搓链表，可以把环断开成为一条链，这样可以方便处理对于每一个k的情况。说通俗点就是在n后面再接上1—(n-1)的值，所以数组要开双倍长度（或者说长度是2n-1）。<br>如<a href="https://www.luogu.com.cn/problem/P2629">P2629 好消息，坏消息</a>，这道题就是要开双倍的空间存储消息的好坏度<br><a name="u17vX"></a></p><h2 id="复杂的判断不建议使用-代替！表示非运算"><a href="#复杂的判断不建议使用-代替！表示非运算" class="headerlink" title="复杂的判断不建议使用~代替！表示非运算"></a>复杂的判断不建议使用~代替！表示非运算</h2><p>比如这种情况：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!(isBoundary[x][y]||isDraw[x][y])</span><br><span class="line">~(isBoundary[x][y]||isDraw[x][y])</span><br></pre></td></tr></table></figure><br>这两个不是等价的<br>主要还是-1的情况，负数在C语言中是以补码的形式存在，-1按位取反之后就是0了<br>2023/07/01<br><a name="Z7BOY"></a></p><h2 id="max函数，min函数可以同时比较两个及以上的数"><a href="#max函数，min函数可以同时比较两个及以上的数" class="headerlink" title="max函数，min函数可以同时比较两个及以上的数"></a>max函数，min函数可以同时比较两个及以上的数</h2><p><code>max(&#123;x,y,z&#125;)</code><br><a name="qrHPA"></a></p><h2 id="用字符表示的0和1可以用异或一个1来反转"><a href="#用字符表示的0和1可以用异或一个1来反转" class="headerlink" title="用字符表示的0和1可以用异或一个1来反转"></a>用字符表示的0和1可以用异或一个1来反转</h2><p><code>s[i] ^= 1;</code><br><a name="dwCRP"></a></p><h2 id="树的叶子结点可以用出度为1来判断"><a href="#树的叶子结点可以用出度为1来判断" class="headerlink" title="树的叶子结点可以用出度为1来判断"></a>树的叶子结点可以用出度为1来判断</h2><p><a name="CyDK9"></a></p><h2 id="bool数组的memset和bitset的reset的时间复杂度比较"><a href="#bool数组的memset和bitset的reset的时间复杂度比较" class="headerlink" title="bool数组的memset和bitset的reset的时间复杂度比较"></a>bool数组的memset和bitset的reset的时间复杂度比较</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">1000000</span>; <span class="comment">// 要处理的元素数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testBitset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::bitset&lt;SIZE&gt; bits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)bits.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="comment">//bits.reset();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::bitset reset time: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testMemset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> arr[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)<span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span> arr);</span><br><span class="line">    <span class="comment">//memset(arr,0,sizeof arr);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;memset time: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">testBitset</span>();</span><br><span class="line">    <span class="built_in">testMemset</span>();</span><br><span class="line">    <span class="comment">//处理大数据的情况下bitset要快8倍，在小范围内速度优势更为明显，快了近26倍</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="mMZ28"></a></p><h2 id="sort函数指定排序方式的三种写法"><a href="#sort函数指定排序方式的三种写法" class="headerlink" title="sort函数指定排序方式的三种写法"></a>sort函数指定排序方式的三种写法</h2><p>第一种就是写一个比较函数<br>第二种是运算符的重载<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;X)<span class="type">const</span> &#123;<span class="keyword">return</span> x&lt;X.x;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第三种<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,[&amp;](st l,st r)&#123;<span class="built_in">return</span> (l.x*l.x+l.y*l.y)&lt;(r.x*r.x+r.y*r.y);&#125;);</span><br></pre></td></tr></table></figure><br><a name="yKzMm"></a></p><h2 id="几个常用的memset的赋值"><a href="#几个常用的memset的赋值" class="headerlink" title="几个常用的memset的赋值"></a>几个常用的memset的赋值</h2><p>memset是一个字节一个字节的赋值，所以赋值为128就会变成极小的数字，赋值为127就会变成极大的数字，赋值为255就会是-1<br><a name="b0qVR"></a></p><h2 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h2><p><a href="https://blog.csdn.net/guangcheng0312q/article/details/109108472">https://blog.csdn.net/guangcheng0312q/article/details/109108472</a><br><a name="Sl0Zo"></a></p><h2 id="return-…-void"><a href="#return-…-void" class="headerlink" title="return ….,void();"></a>return ….,void();</h2><p>这条语句可以用来在void函数中return的时候加上一些附带的语句，例如<code>return cout&lt;&lt;-1,void();</code><br><a name="jmp0u"></a></p><h2 id="加快unordered-map的技巧"><a href="#加快unordered-map的技巧" class="headerlink" title="加快unordered_map的技巧"></a>加快unordered_map的技巧</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">mp.<span class="built_in">reserve</span>(<span class="number">1024</span>);</span><br><span class="line">mp.<span class="built_in">max_load_factor</span>(<span class="number">0.25</span>);</span><br></pre></td></tr></table></figure><p>第一句话重新分配了容器的桶数，第二句话设置了容器的最大负载因子，元素数量/总的桶数超过了负载因子就增加桶数，这样写可以防止被对默认参数的hack，变得不那么容易退化成线性速度<br>还是少用吧有时候会爆内存…..<br>2023.11.13</p><p><a name="a1VDo"></a></p><h2 id="染色法可以判断一棵无根树是否存在两个叶子结点之间的路径长度为奇数"><a href="#染色法可以判断一棵无根树是否存在两个叶子结点之间的路径长度为奇数" class="headerlink" title="染色法可以判断一棵无根树是否存在两个叶子结点之间的路径长度为奇数"></a>染色法可以判断一棵无根树是否存在两个叶子结点之间的路径长度为奇数</h2><p><a name="Av0Fx"></a></p><h2 id="范围不大的组合可以使用数组去一一映射"><a href="#范围不大的组合可以使用数组去一一映射" class="headerlink" title="范围不大的组合可以使用数组去一一映射"></a>范围不大的组合可以使用数组去一一映射</h2><p>比如枚举一个1到3的数据对，并且每对数据中的两个元素不能相同（如（1,2）,(1,3)，像(2,2)就是不合法的）<br>可以使用两层for循环加上条件判断，也可以直接先手模一下写到一个数组中这样直接一个for循环就可以解决</p><p><a name="IjGIN"></a></p><h2 id="形如-a-b-c-in-1-2-3-a-ne-b-ne-c-a-b-c-6-已知a-b-求c"><a href="#形如-a-b-c-in-1-2-3-a-ne-b-ne-c-a-b-c-6-已知a-b-求c" class="headerlink" title="形如$a,b,c\in \{1,2,3\}  ,a\ne b\ne c,a+b+c=6$已知a,b,求c"></a>形如$a,b,c\in \{1,2,3\}  ,a\ne b\ne c,a+b+c=6$已知a,b,求c</h2><p>利用恒等式：<br>c = 6-a-b，快速求出c而不需要两个for循环迭代加if条件判断遍历。</p><p><a name="MZZ8I"></a></p><h2 id="对于边长度固定的图（如等于1），那么BFS找到的从起点结点到任意节点的路径都是最短路"><a href="#对于边长度固定的图（如等于1），那么BFS找到的从起点结点到任意节点的路径都是最短路" class="headerlink" title="对于边长度固定的图（如等于1），那么BFS找到的从起点结点到任意节点的路径都是最短路"></a>对于边长度固定的图（如等于1），那么BFS找到的从起点结点到任意节点的路径都是最短路</h2><p><a name="C0FJD"></a></p><h2 id="DAG的出栈顺序是反图的拓扑序，有向图SCC缩点后必定是DAG-缩完点之后的SCC最后一个出栈的必定是源点，但第一个出栈的不一定是汇点"><a href="#DAG的出栈顺序是反图的拓扑序，有向图SCC缩点后必定是DAG-缩完点之后的SCC最后一个出栈的必定是源点，但第一个出栈的不一定是汇点" class="headerlink" title="DAG的出栈顺序是反图的拓扑序，有向图SCC缩点后必定是DAG,缩完点之后的SCC最后一个出栈的必定是源点，但第一个出栈的不一定是汇点"></a>DAG的出栈顺序是反图的拓扑序，有向图SCC缩点后必定是DAG,缩完点之后的SCC最后一个出栈的必定是源点，但第一个出栈的不一定是汇点</h2><p><a name="riFkw"></a></p><h2 id="判断一个DAG是否是一个连通图可以用是否只存在一个汇点（只有一个点出度为0）来判断"><a href="#判断一个DAG是否是一个连通图可以用是否只存在一个汇点（只有一个点出度为0）来判断" class="headerlink" title="判断一个DAG是否是一个连通图可以用是否只存在一个汇点（只有一个点出度为0）来判断"></a>判断一个DAG是否是一个连通图可以用是否只存在一个汇点（只有一个点出度为0）来判断</h2><p><a name="pTpkj"></a></p><h2 id="求最大公约数的时候可以写成a-gcd-a-b-b这样可以防爆"><a href="#求最大公约数的时候可以写成a-gcd-a-b-b这样可以防爆" class="headerlink" title="求最大公约数的时候可以写成a/gcd(a,b)*b这样可以防爆"></a>求最大公约数的时候可以写成a/gcd(a,b)*b这样可以防爆</h2><p><a name="ElchI"></a></p><h2 id="（待验证）优先队列的初始化无序序列的时间复杂度要比直接插入元素的时间复杂度要小"><a href="#（待验证）优先队列的初始化无序序列的时间复杂度要比直接插入元素的时间复杂度要小" class="headerlink" title="（待验证）优先队列的初始化无序序列的时间复杂度要比直接插入元素的时间复杂度要小"></a>（待验证）优先队列的初始化无序序列的时间复杂度要比直接插入元素的时间复杂度要小</h2><p>上数据结构的时候发现堆有一个操作是将序列堆化，这个的操作好像时间复杂度更低一些，查了一下stl中的优先队列也有类似的操作。</p><p>因为优先队列的内部是通过堆来实现的，将一个无序序列堆化的复杂度是O(nlogn)实际上通常小于这个复杂度，接近于线性，但是插入的复杂度一般都能达到O(nlogn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;<span class="type">int</span>&gt; maxHeap;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; unorderedSequence = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">34</span>,<span class="number">56</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">31</span>,<span class="number">3</span>,<span class="number">345</span>,&#125;; </span><br><span class="line">maxHeap = std::<span class="built_in">priority_queue</span>&lt;<span class="type">int</span>&gt;(unorderedSequence.<span class="built_in">begin</span>(),unorderedSequence.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="排序后保留原数组中每一个元素的索引值"><a href="#排序后保留原数组中每一个元素的索引值" class="headerlink" title="排序后保留原数组中每一个元素的索引值"></a>排序后保留原数组中每一个元素的索引值</h2><p>很多时候并不希望排序会影响索引值，因为会用到原先的索引值，一种做法是将其放在一个结构体里面，对结构体进行排序，实际上可以利用sort的自定义排序规则对一个新的索引值数组进行排序这样就不会影响到元素组中的内容<br>如<a href="https://www.luogu.com.cn/problem/AT_abc331_e">[ABC331E] Set Meal</a>，让你输出排序之后元素的下标等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; op;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; idx;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cin &gt;&gt; b[i], idx.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, c, d; i &lt;= op; ++i) &#123;</span><br><span class="line">cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">h.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(c, d));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">all</span>(idx), [&amp;](<span class="type">int</span> _a, <span class="type">int</span> _b) &#123;<span class="keyword">return</span> b[_a] &gt; b[_b];&#125;);</span><br><span class="line"><span class="comment">// idx数组存的是排序之后每个位置对应的初始元素的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> j : idx) </span><br><span class="line"><span class="keyword">if</span> (!h.<span class="built_in">count</span>(<span class="built_in">make_pair</span>(i, j))) &#123;</span><br><span class="line">res = <span class="built_in">max</span>(res, a[i] + b[j]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for-int-j-1-j-lt-n-i-j-复杂度大概是ln级别的（比ln更大一些）"><a href="#for-int-j-1-j-lt-n-i-j-复杂度大概是ln级别的（比ln更大一些）" class="headerlink" title="for(int j = 1;j&lt;=n/i;++j)复杂度大概是ln级别的（比ln更大一些）"></a>for(int j = 1;j&lt;=n/i;++j)复杂度大概是ln级别的（比ln更大一些）</h2><p>或者是形如<code>for(int j = i;j&lt;=n;j += i)</code>等，就是一个调和级数画出反比例函数图像求其反常积分</p><h2 id="当元素大小比较小的时候（比如都小于1e6）动态的查询数组有几个元素在一个范围内可以用树状数组，静态可以用前缀和"><a href="#当元素大小比较小的时候（比如都小于1e6）动态的查询数组有几个元素在一个范围内可以用树状数组，静态可以用前缀和" class="headerlink" title="当元素大小比较小的时候（比如都小于1e6）动态的查询数组有几个元素在一个范围内可以用树状数组，静态可以用前缀和"></a>当元素大小比较小的时候（比如都小于1e6）动态的查询数组有几个元素在一个范围内可以用树状数组，静态可以用前缀和</h2><p>就是将tree数组，sum数组定义为一个桶，对桶进行RMQ</p><h2 id="2的模乘逆元为-p-1-gt-gt-1"><a href="#2的模乘逆元为-p-1-gt-gt-1" class="headerlink" title="2的模乘逆元为(p+1)&gt;&gt;1"></a>2的模乘逆元为(p+1)&gt;&gt;1</h2><p>由费马小定理得，$2^{p-1} \equiv 1 \ (mod\ p)$,所以有$2^{p-2}\equiv2^{-1}\equiv \frac{p+1}{2}\ (mod\ p)$,那么有$2^{-1}\equiv \frac{p+1}{2}\ (mod\ p)$也就是说2的逆元除了与2的p-2次幂相同以外，还和(p+1)&gt;&gt;1相同，由于p是素数，素数一定是奇数，那么(p+1)/2不可能是分数，所以2的模乘逆元就是(p+1)&gt;&gt;1，类似的有4对于7的模意义下的逆元等于2（(7+1)/4 = 2，前提是一定要可以被整除）</p><h1 id="寄巧"><a href="#寄巧" class="headerlink" title="寄巧"></a>寄巧</h1><p><a name="ZTCfj"></a></p><h2 id="并查集的路径压缩"><a href="#并查集的路径压缩" class="headerlink" title="并查集的路径压缩"></a>并查集的路径压缩</h2><p>如果题目对于父结点没有什么特殊的要求那么最好还是加上，因为这个真的可以被卡掉，比如这道题：<br><a href="https://codeforces.com/contest/1131/submission/226674117">不加路径压缩</a>会在第八个点tle，同样的规模第七个点就能很短时间内通过，<a href="https://codeforces.com/contest/1131/submission/226676219">加了之后</a>就通过了<br><a name="OQs8D"></a></p><h2 id="关于对拍的数据强度问题"><a href="#关于对拍的数据强度问题" class="headerlink" title="关于对拍的数据强度问题"></a>关于对拍的数据强度问题</h2><p>有一些题目如果只是单纯的随机生成数据，那么大多数情况下很有可能得到的结果和标程相同，像类似于<a href="https://codeforces.com/contest/1672/problem/D">这道题</a>：</p><p>你会得到一个长度为 $n$ 的数组 $a$ ，进行以下操作：</p><p>选择两个数 $l,r$ 满足 $1\le l&lt; r\le n$ 并且 $a[l]=a[r]$ ，将 $a[l…r]$ 替换为 $a[l+1,l+2,…r,l]$ 。</p><p>你还会得到一个长度为 $n$ 的数组 $b$ ，判断 $a$ 能否通过若干次操作变成 $b$ 。</p><p>正解是两个指针i,j，i指向$a_1$,j指向,$b_1$如果相同就++i,++j，不相同但满足b[j] == a[i - 1]并且之前有出现过没有对上的数和b[j]相同，那么j指针继续往后移动。<br>一开始写了一个假做法，认为每次查询之前有没有对上的数时只需要开一个队列，合法的数只有在队列的头和尾端，这个做法在后面对拍的时候发现了hack数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line">standout:YES</span><br></pre></td></tr></table></figure><p>当时对拍对了好久也没找出hack，因为如果单纯的生成大数据然后对拍，很有可能是都是no,就比如只有特定的排列才会输出yes，那么大多数情况下生成的数据都会是no，所以这道题的正确对拍思路是写尽量多的组数，每组的序列长度适当的小，这样才能保证最后的答案有机会是yes，这样写一定要注意数组下标会不会越界。<br>这道题一开始对拍时每次序列的长度都是在[1,200000]里面取，跑了500多组，都没发现错误…<br><a name="moyn5"></a></p><h2 id="大常数对执行速度的影响"><a href="#大常数对执行速度的影响" class="headerlink" title="大常数对执行速度的影响"></a>大常数对执行速度的影响</h2><p>或者说是被卡常，有些题目由于使用了非正解，并且复杂度并不是特别好需要题目数据配合才能通过。这个时候要特别注意常数的影响，比如这道<a href="https://www.luogu.com.cn/problem/P1972">P1972 [SDOI2009] HH的项链</a>，10的6次方的数据规模其实常数小可以用莫队卡过去：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000006</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> wr &#123;&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> wr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, p;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="type">int</span> pos[N], a[N], res[N], pre[N], suf[N], flag[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> block = (<span class="type">int</span>) <span class="built_in">sqrt</span>(n);</span><br><span class="line">    block += n % block;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        pos[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(q[i].l), <span class="built_in">read</span>(q[i].r);</span><br><span class="line">        q[i].p = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(int i = 1;i&lt;=m;++i) cout&lt;&lt;q[i].l&lt;&lt;&#x27; &#x27;&lt;&lt;q[i].r&lt;&lt;&#x27; &#x27;&lt;&lt;q[i].p&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, [&amp;](Node A, Node B) &#123;</span><br><span class="line">        <span class="keyword">return</span> pos[A.l] == pos[B.l] ? (pos[A.l] &amp; <span class="number">1</span> ? A.r &gt; B.r : A.r &lt; B.r) : pos[A.l] &lt; pos[B.l];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//for(int i = 1;i&lt;=m;++i) cout&lt;&lt;q[i].l&lt;&lt;&#x27; &#x27;&lt;&lt;q[i].r&lt;&lt;&#x27; &#x27;&lt;&lt;q[i].p&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pre[i] = flag[a[i]], flag[a[i]] = i;</span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> flag);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) suf[i] = flag[a[i]], flag[a[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) ans += suf[--l] &gt; r;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) ans -= pre[r--] &lt; l;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) ans += pre[++r] &lt; l;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) ans -= suf[l++] &gt; r;</span><br><span class="line">        res[q[i].p] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">write</span>(res[i], <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;my.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但如果另外一种贪心策略来移动双指针就会因为大常数过不去<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000006</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> wr &#123;&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> wr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, p;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="type">int</span> pos[N], a[N], res[N], pre[N], suf[N], flag[N], cnt[N];</span><br><span class="line"><span class="type">int</span> ans, test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ++cnt[a[x]], test += cnt[a[x]] == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    --cnt[a[x]], test -= cnt[a[x]] == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> block = (<span class="type">int</span>) <span class="built_in">sqrt</span>(n);</span><br><span class="line">    block += n % block;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        pos[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(q[i].l), <span class="built_in">read</span>(q[i].r);</span><br><span class="line">        q[i].p = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(int i = 1;i&lt;=m;++i) cout&lt;&lt;q[i].l&lt;&lt;&#x27; &#x27;&lt;&lt;q[i].r&lt;&lt;&#x27; &#x27;&lt;&lt;q[i].p&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, [&amp;](Node A, Node B) &#123;</span><br><span class="line">        <span class="keyword">return</span> pos[A.l] == pos[B.l] ? (pos[A.l] &amp; <span class="number">1</span> ? A.r &gt; B.r : A.r &lt; B.r) : pos[A.l] &lt; pos[B.l];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//for(int i = 1;i&lt;=m;++i) cout&lt;&lt;q[i].l&lt;&lt;&#x27; &#x27;&lt;&lt;q[i].r&lt;&lt;&#x27; &#x27;&lt;&lt;q[i].p&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pre[i] = flag[a[i]], flag[a[i]] = i;</span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> flag);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) suf[i] = flag[a[i]], flag[a[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) ans += suf[--l] &gt; r, <span class="built_in">add</span>(l);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) ans -= pre[r--] &lt; l, <span class="built_in">add</span>(r);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) ans += pre[++r] &lt; l, <span class="built_in">del</span>(l);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) ans -= suf[l++] &gt; r, <span class="built_in">del</span>(r);</span><br><span class="line">        res[q[i].p] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">write</span>(res[i], <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;my.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以发现只是for循环里面的语句数量多了几句就会超时，测试下来大概慢了3-4倍，差不多每次执行的时候多了2、3句话，原先600ms的数据多了这几句话就很危险（时限2s），所以在能决定复杂度的语句块内能少写就尽量少写…<br><a name="GqqNK"></a></p><h2 id="在一些对精度有要求（比如控制在1e-6）的题目中不要用默认的cout输出"><a href="#在一些对精度有要求（比如控制在1e-6）的题目中不要用默认的cout输出" class="headerlink" title="在一些对精度有要求（比如控制在1e-6）的题目中不要用默认的cout输出"></a>在一些对精度有要求（比如控制在1e-6）的题目中不要用默认的cout输出</h2><p>如果要用cout可以加上精度的控制，因为cout默认大概意思是保留6位有效数字比如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">123.12315078765432134</span>;</span><br><span class="line">cout&lt;&lt;a;</span><br><span class="line">output：</span><br><span class="line"><span class="number">123.123</span></span><br></pre></td></tr></table></figure><br>会出现精度的丢失<br><a name="jReW5"></a></p><h2 id="在c-c-里，a-b的正负与a有关"><a href="#在c-c-里，a-b的正负与a有关" class="headerlink" title="在c/c++里，a%b的正负与a有关"></a>在c/c++里，a%b的正负与a有关</h2><h2 id="long-long-类型的数据参与除法运算或使用floor、ceil、log2等函数原型的参数类型是double的时候可能会引起精度丢失"><a href="#long-long-类型的数据参与除法运算或使用floor、ceil、log2等函数原型的参数类型是double的时候可能会引起精度丢失" class="headerlink" title="long long 类型的数据参与除法运算或使用floor、ceil、log2等函数原型的参数类型是double的时候可能会引起精度丢失"></a>long long 类型的数据参与除法运算或使用floor、ceil、log2等函数原型的参数类型是double的时候可能会引起精度丢失</h2><p>double的精度只有15-16位，如果题目最大1E17，然后是大于1E16的输入会出问题，比如1e16+9转成double类型再转回来就会变成1e16+8。<br>如果题目要求对一个long long类型除以二向上或者向下取整，最稳的办法是使用位运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上取整</span></span><br><span class="line">(n&gt;&gt;<span class="number">1</span>)+n&amp;<span class="number">1</span></span><br><span class="line"><span class="comment">// 向下取整</span></span><br><span class="line">n&gt;&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>  同理log2等函数也是最好先预处理再计算，函数尽量少用不太安全</p><p><a name="v50s2"></a></p><h2 id="手动开栈"><a href="#手动开栈" class="headerlink" title="手动开栈"></a>手动开栈</h2><p>有的时候直接将一些变量声明在局部可以避免初始化的麻烦，但是有的时候会爆栈虽然交上去不会有影响但是本地测试的时候就很麻烦要改数组大小等，这时候就需要手动开栈。<br>一些常见的调整栈大小的方法：<br>使用 GCC 或 Clang（Unix/Linux/macOS）:<br>可以使用 <code>-Wl,-stack_size,&lt;size&gt;</code> 选项来调整栈大小。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wl,-stack_size,1024000000 -o program program.c</span><br></pre></td></tr></table></figure><br>使用 CMake（clion）:<br>在 CMake 中，可以通过 <code>target_link_options</code> 或者 <code>add_link_options</code> 来设置编译选项，以调整栈大小。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_options</span>(untitled1 PRIVATE <span class="string">&quot;-Wl,--stack=1024000000&quot;</span>)</span><br></pre></td></tr></table></figure><br>注意linux下可能会失败因为系统可能对进程的栈大小作出限制。<br>redpanda:<br>工具 → 编译选项 →  编译器选项 → 在编译时加入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Wl,--stack=SIZE 1024000000</span><br></pre></td></tr></table></figure><br>1024000000 大概分了1000MB，一般都是足够用的</p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幽默的世界</title>
      <link href="/2023/10/02/%E5%B9%BD%E9%BB%98%E7%9A%84%E4%B8%96%E7%95%8C/"/>
      <url>/2023/10/02/%E5%B9%BD%E9%BB%98%E7%9A%84%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="洛谷十月月赛-幽默的世界"><a href="#洛谷十月月赛-幽默的世界" class="headerlink" title="洛谷十月月赛 幽默的世界"></a><strong>洛谷十月月赛 幽默的世界</strong></h1><p>题目描述</p><p>给定一个长为 $n$ 的序列 $a_1,a_2,\cdots,a_n$，定义 $a$ 的一个连续子序列 $a_l,a_{l+1},\cdots,a_r$ 是幽默的，当且仅当：</p><ul><li>$\sum\limits_{i=l}^ra_i&gt;0$；</li><li>对于所有 $l\le x\le y&lt;r$，满足 $\sum\limits_{i=x}^y a_i\le 0$。</li></ul><p>$q$ 次询问，每次给定两个整数 $l,r$，查询满足以下条件的数对 $(l’,r’)$ 个数：</p><ul><li>$l\le l’\le r’\le r$；</li><li>连续子序列 $a_{l’},a_{l’+1},\cdots a_{r’}$ 是幽默的。</li></ul><p>输入格式</p><p>第一行输入两个整数 $n,q$。</p><p>接下来一行输入 $n$ 个整数，第 $i$ 个整数代表 $a_i$。</p><p>接下来 $q$ 行，每行输入两个整数 $l,r$，代表一次询问。</p><p>输出格式</p><p>对于每组询问，输出一行一个整数，代表答案。</p><p>样例输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 6</span><br><span class="line">-1 2 -1 -1 -1 2 -1</span><br><span class="line">2 5</span><br><span class="line">4 7</span><br><span class="line">1 7</span><br><span class="line">5 5</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>对于所有数据，保证 $1\le n,q\le 2\times 10^5$，$1\le l\le r\le n$，$|a_i|\le 10^9$。</p><p>子任务</p><div class="table-container"><table><thead><tr><th style="text-align:center">#</th><th style="text-align:center">特殊性质</th><th style="text-align:center">分值</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">样例</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">$n,q\le 50$</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$n,q\le 3\times 10^3$</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">对于所有询问，$r=n$</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">对于所有询问，$l=1$</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">-</td><td style="text-align:center">35</td></tr></tbody></table></div><p>不算难的一道题目，但是题目的描述过于抽象导致我差几十分钟写对它…<br>35pts：<br>读懂题目之后可以发现其实一个正数一定是一个幽默的数，那么再继续考虑可以发现，如果一个子序列长度大于1那么它的右边界一定是正数，并且有且只有一个正数，因为其他位置的正数都不会满足第二个要求，同时为了满足第一个要求，这个子序列的元素之和必定大于0，因此可以想到一种暴力的解法：定义一个指针先指向右边界，找到每次查询中最靠近右边界的正数，从这个正数开始找最长的满足第一个要求且不包含其他正数的子序列，多长就有多少个满足条件的子序列，反复去找直到指针指到左边界为止。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;stand.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, l, r; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = r,pPos = r; j &gt;= l; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + a[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">if</span> (pPos != j &amp;&amp; a[j]&gt;<span class="number">0</span>)sum = <span class="number">0</span>;</span><br><span class="line">                sum += a[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (a[j] &lt;= <span class="number">0</span> &amp;&amp; j &gt;= l)--j;</span><br><span class="line">                pPos = j;</span><br><span class="line">                ++j;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以证明这个做法是正确的，但是由于复杂度过高会超时。<br>100pts：<br>观察超时代码，可以发现主要的时间浪费在查询的遍历上，那么需要优化查询速度，至少要优化到O(logn)级别的复杂度，那么这个范围内可以接受的算法显然是二分，然后就往单调性方面去想，设左右边界为L,R，如果预处理出所有的正数下标，存在<code>positive</code>数组中那么显然这个下标是递增的，可以用二分查找，然后可以在O(logn)级别查到第一个下标小于等于R的正数下标r和第一个下标大于等于L的正数下标l，那么如果遍历一遍预处理出每个正数对应的最大的子序列，那么只需要计算<code>sum[r] - sum[l] + min(positive[l] - L + 1, sum[l] - sum[l - 1])</code>就可以不重不漏的查询出区间[L,R]内幽默的序列个数，但是还有个问题像下面这个数据就会输出负的数<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 1</span><br><span class="line">5 -3 1 3 0</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure><br>原因很简单这时候r&lt;l因为这个区间内没有正数，所以对于这种情况要将它的值取为0，合起来的表达式就是：</p><p><code>max(0ll, sum[r] - sum[l] + min(positive[l] - L + 1, sum[l] - sum[l - 1]))</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q, a[N], sum[N], positive[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;my.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) positive[++len] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, cnt; i &lt;= len; ++i) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = positive[i], S = <span class="number">0</span>; j &gt; positive[i - <span class="number">1</span>]; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S + a[j] &gt; <span class="number">0</span>) cnt++, S += a[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> L, R;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line">        l = <span class="built_in">lower_bound</span>(positive + <span class="number">1</span>, positive + len + <span class="number">1</span>, L) - positive;</span><br><span class="line">        r = <span class="built_in">upper_bound</span>(positive + <span class="number">1</span>, positive + len + <span class="number">1</span>, R) - positive - <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">max</span>(<span class="number">0ll</span>, sum[r] - sum[l] + <span class="built_in">min</span>(positive[l] - L + <span class="number">1</span>, sum[l] - sum[l - <span class="number">1</span>])) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体来说不算难，比赛的时候由于用vector存正数，将前缀和数组从0开始赋值导致加了很多在0的时候的特判，导致在最后没调出来，比完了重构了代码就写出来了。其实对于这种题目，已经做出它的暴力版本然后发现正解出错而找不到bug的时候就应该考虑对拍，这道题的对拍不复杂，也是通过对拍在补题的时候发现了输出为负数的情况。<br>对拍代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> random(a, b) ((a)+rand()%((b)-(a)+1))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">random</span>(<span class="number">1</span>,<span class="number">10</span>),q = <span class="built_in">random</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;q&lt;&lt;endl;</span><br><span class="line">    fout&lt;&lt;n&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;q&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,t;i&lt;=n;++i)&#123;</span><br><span class="line">        t = <span class="built_in">random</span>(<span class="number">-5</span>,<span class="number">5</span>);</span><br><span class="line">        cout&lt;&lt;t&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        fout&lt;&lt;t&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    fout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,l,r;i&lt;=q;++i)&#123;</span><br><span class="line">        l = <span class="built_in">random</span>(<span class="number">1</span>,n);</span><br><span class="line">        r = <span class="built_in">random</span>(l,n);</span><br><span class="line">        cout&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">        fout&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    fout.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_dataset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">random</span>(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">build</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">create_dataset</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;stand.exe &lt; input.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;my.exe &lt; input.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">system</span>(<span class="string">&quot;fc stand.txt my.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> tot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">work</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;WrongAnswer\n&quot;</span>;</span><br><span class="line">            <span class="built_in">getchar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">256</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这道题充分说明了<strong>前缀和不要以0下标为开头</strong>不然在二分的时候要做一堆的判断血压容易上来…</p>]]></content>
      
      
      <categories>
          
          <category> 小比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷月赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『GROI-R2』不空白的画布</title>
      <link href="/2023/10/01/%E3%80%8EGROI-R2%E3%80%8F%E4%B8%8D%E7%A9%BA%E7%99%BD%E7%9A%84%E7%94%BB%E5%B8%83/"/>
      <url>/2023/10/01/%E3%80%8EGROI-R2%E3%80%8F%E4%B8%8D%E7%A9%BA%E7%99%BD%E7%9A%84%E7%94%BB%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h1 id="洛谷九月月赛『GROI-R2』-不空白的画布"><a href="#洛谷九月月赛『GROI-R2』-不空白的画布" class="headerlink" title="洛谷九月月赛『GROI-R2』 不空白的画布"></a><strong>洛谷九月月赛</strong>『GROI-R2』 不空白的画布</h1><p>你有连续的 $n$ 个方格，每个方格上有一个初始颜色 $c_i$，且保证 $1\le c_i \le k$。</p><p>你可以操作<strong>至多</strong> $m$ 次，每个操作为改变某个方格颜色，要求改变后的颜色范围仍在 $[1,k]$ 内。</p><p>我们称一个<strong>极长相同颜色连续段</strong>为一块，要求求出经过至多 $m$ 次操作后的<strong>最多</strong>块数。</p><p>输入格式</p><p>本题有多组测试数据。</p><p>第一行输入一个正整数 $T$ 表示数据组数。</p><p>对于每组测试数据，第一行输入三个正整数 $n,m,k$，表示画布的长度，坦尼尔作画的次数上限和颜色的取值范围。</p><p>第二行输入一个长度为 $n$ 的整数序列 $c$，表示画布上每个位置的初始颜色。</p><p>输出格式</p><p>对于每组测试数据，输出一行一个正整数，表示记忆碎片最多有多少个。</p><p>样例输入 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 1 3</span><br><span class="line">2 2 2</span><br><span class="line">5 2 4</span><br><span class="line">2 2 2 2 3</span><br></pre></td></tr></table></figure><p>样例输出 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>样例解释</p><p>对于第一组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，得到 $\{c_n\}=\{2,1,2\}$，块数为 $3$。</p><p>对于第二组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，将从左到右的第三个位置涂成颜色 $3$，得到 $\{c_n\}=\{2,1,3,2,3\}$，块数为 $5$。</p><p>数据范围</p><div class="table-container"><table><thead><tr><th style="text-align:center">$\text{Subtask}$</th><th style="text-align:center">$\sum n\le$</th><th style="text-align:center">$m\le$</th><th style="text-align:center">$k\le$</th><th style="text-align:center">分值</th></tr></thead><tbody><tr><td style="text-align:center">$1$</td><td style="text-align:center">$10$</td><td style="text-align:center">$10$</td><td style="text-align:center">$3$</td><td style="text-align:center">$10$</td></tr><tr><td style="text-align:center">$2$</td><td style="text-align:center">$5\times 10^5$</td><td style="text-align:center">$1$</td><td style="text-align:center">$5\times 10^5$</td><td style="text-align:center">$10$</td></tr><tr><td style="text-align:center">$3$</td><td style="text-align:center">$10^3$</td><td style="text-align:center">$10^3$</td><td style="text-align:center">$10^3$</td><td style="text-align:center">$15$</td></tr><tr><td style="text-align:center">$4$</td><td style="text-align:center">$5\times 10^5$</td><td style="text-align:center">$5\times 10^5$</td><td style="text-align:center">$3$</td><td style="text-align:center">$25$</td></tr><tr><td style="text-align:center">$5$</td><td style="text-align:center">$5\times 10^5$</td><td style="text-align:center">$5\times 10^5$</td><td style="text-align:center">$5\times 10^5$</td><td style="text-align:center">$40$</td></tr></tbody></table></div><p>对于 $100\%$ 的数据满足 $1\le  n\le 5\times 10^5$，$1\le \sum n\le 5\times 10^5$，$1\le m\le n$，$3\le  k \le 5\times 10^5$，$1\le c_i\le k$。</p><p>大部分的解法是把长度为奇数的块和长度为偶数的块放在两个数组里，分别排序，先把奇数块切掉，再切偶数块，偶数块考虑特殊情况特判。<br>比赛时也是这种想法但是写挂了,后来换一种思路，一共跑两次循环，第一次循环处理序列中块的长度大于2的部分，每次处理时三个三个的看，每三个可以加两次，第一次判断此时是不是三个，是的话就将中间一个标记为修改，此时加块数加一，用一个isMod数组记录有没有修改过，这样如果前面一个被修改过那么后面不管是什么必定是一个新的块，也要加一，这时候可以通过isMod数组判断，也是能在一个循环内完成，但是有一种情况：比如长度是7两次3 3之后（第一个循环）会剩下6 和 7上的位置没有处理，但这种情况其实就相当于长度是二的块，也就是说，第一次遍历可以解决两种情况：<br>1：长度大于2的部分（可能会剩余最后两个，比如长度7会剩，6就不会）；<br>2：长度是1的情况<br>那么如果还有剩下的，那么必然是长度为二的或者是大于二的数剩余二的情况，也就是满足：<br>c[i] == c[i - 1] &amp;&amp; c[i] != c[i + 1]&amp;&amp;!isMod[i-1]<br>一直遍历直到遍历完或者次数用完为止<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500105</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, m, k, c[N];</span><br><span class="line">bitset&lt;N&gt; isMod;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        isMod.<span class="built_in">reset</span>();</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; c[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] != c[i - <span class="number">1</span>] || isMod[i - <span class="number">1</span>]) ans++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c[i] == c[i - <span class="number">1</span>] &amp;&amp; c[i] == c[i + <span class="number">1</span>] &amp;&amp; m) &#123;</span><br><span class="line">                isMod[i] = <span class="literal">true</span>;</span><br><span class="line">                ans++, --m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == c[i - <span class="number">1</span>] &amp;&amp; c[i] != c[i + <span class="number">1</span>]&amp;&amp;!isMod[i<span class="number">-1</span>]) </span><br><span class="line">                ans++, --m;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个思路感觉代码还是比较精简的，只是思维量相对比较大，实现起来比较困难</p>]]></content>
      
      
      <categories>
          
          <category> 小比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷月赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客更新记录</title>
      <link href="/2023/10/01/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/10/01/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>2026-01-16 上传文章：三蓝一棕：傅里叶变换</p><p>2025-12-22 上传文章：关于雅思</p><p>2025-04-21 上传文章：2021SCCPC</p><p>2025-04-17 更新文章：XCPC模板</p><p>2025-03-06 更新头像</p><p>2025-02-25</p><p>更新文章：hexo+github个人网站开发</p><p>2024-12-31</p><p>上传文章：2024，更新文章：19thZJCPC</p><p>2024-11-22</p><p>上传文章：2024CCPC山东邀请赛，更新文章：19thZJCPC</p><p>2024-10-25</p><p>上传文章：2024ICPC昆明邀请赛</p><p>2024-09-18</p><p>上传文章：2024JXCPC</p><p>2024-07-26</p><p>上传文章：2024SXCPC</p><p>2024-07-24</p><p>上传文章：2024SCCPC</p><p>2024-07-18</p><p>上传文章：文件管理系统的搭建</p><p>2024-07-01</p><p>更新文章：关于linux(Ubuntu),调整了一些文章的优先级以及标签分类等</p><p>2024-06-29</p><p>更新文章：关于Ubuntu-&gt;关于linux(Ubuntu)</p><p>2024-04-07</p><p>更新文章：18thZJCPC，19thZJCPC</p><p>2024-04-06</p><p>上传文章：17thZJCPC，18thZJCPC</p><p>2024-03-31</p><p>上传文章：2024年度第五届全国大学生算法设计与编程挑战赛（春季赛）更新文章：XCPC模板</p><p>2024-03-26</p><p>上传文章：2022SHCPC，2023JSCPC；更新文章：hexo-github个人网站开发；添加文章置顶功能</p><p>2024-03-16</p><p>上传文章：13thSDCPC,整除分块</p><p>2024-03-11</p><p>更新文章：XCPC模板</p><p>2024-03-04</p><p>上传文章：【LGR-174-Div-2】T2、T3</p><p>2024-02-26</p><p>更新文章trick</p><p>2024-02-15</p><p>上传文章：ICPC2023-HangZhou R 签到+铜牌题，更新文章：2023ICPC杭州站打铁游记，hexo+github个人网站开发</p><p>2024-02-13</p><p>上传文章：01字典树，更新文章：trick，XCPC模板</p><p>2024-02-09</p><p>上传文章：根号分治，更新文章：trick，以及更新一些文章的分类，标签等</p><p>2024-02-007</p><p>上传文章：hexo+github个人网站开发，更新文章：缺省源，对拍器与数据生成，2023ICPC杭州站打铁游记，XCPC模板</p><p>2024-01-06</p><p>上传文章：关于ubuntu，更新文章：trick</p><p>2023-12-11</p><p>上传文章：2023ICPC杭州站打铁游记</p><p>2023-12-02</p><p>更新文章：XCPC模板</p><p>2023-11-22</p><p>更新文章：XCPC模板</p><p>2023-11-15</p><p>上传文章：ICPC2021-Nanjing-R-签到-铜牌题,修改文章untitled标题为trick,更新文章：trick</p><p>2023-10-26</p><p>上传文章：19thZJCPC,更新文章：XCPC模板</p><p>2023-10-25</p><p>上传文章：缺省源，XCPC模板，更新文章：untitled</p><p>2023-10-13</p><p>更新文章：untitled</p><p>2023-10-09</p><p>更新文章：untitled</p><p>2023-10-07</p><p>更新文章：untitled</p><p>2023-10-05：</p><p>上传文章：untitled，更改侧边栏</p><p>2023-10-02：</p><p>上传文章：洛谷十月月赛 幽默的世界</p><p>2023-10-01：</p><p>上传文章：算法大赛2023-村庄，博客更新记录，洛谷九月月赛『GROI-R2』不空白的画布。修改文章：20thZJCPC的文件名，更新了对图片的引用。删除文章：test。修改footer、侧边栏以及行内数学公式的渲染</p><p>2023-09-25：</p><p>上传文章：E-梅莉的市场经济学</p><p>2023-09-18：</p><p>上传文章：对拍器与数据生成。在test文章中测试图床外链</p><p>2023-09-02：<br>上传文章：test</p><p>2023-08-19：</p><p>上传文章：20thZJCPC</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对拍器与数据生成</title>
      <link href="/2023/09/18/%E5%AF%B9%E6%8B%8D%E5%99%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90/"/>
      <url>/2023/09/18/%E5%AF%B9%E6%8B%8D%E5%99%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p><a name="WJjdK"></a></p><h1 id="对拍器模板"><a href="#对拍器模板" class="headerlink" title="对拍器模板"></a>对拍器模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> random(a, b) ((a)+rand()%((b)-(a)+1))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_dataset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">fout.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">create_dataset</span>();</span><br><span class="line"><span class="comment">//system(&quot;stand.exe &lt; input.txt &gt; stand.txt&quot;);</span></span><br><span class="line"><span class="comment">//system(&quot;my.exe &lt; input.txt &gt; my.txt&quot;);</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;stand.exe &lt; input.txt&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;my.exe &lt; input.txt&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">system</span>(<span class="string">&quot;fc stand.txt my.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> itNum)</span> </span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= itNum; i ++ ) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">work</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Wrong Answer\n&quot;</span>;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Done&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">dp</span>(<span class="number">64</span>);<span class="comment">//测试的数据组数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试的代码，命名为my</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">函数,变量命名等...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//多加这两行其他都不变</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;my.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确的代码，命名为stand</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">函数,变量命名等...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//多加这两行其他都不变</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;stand.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个ofstream fout(“input.txt”);以及fout.close()，close最好在不用了就写上以避免不必要的错误。ofstream fout() 的括号里面还可以传递其它参数，这里默认表示为：ofstream fout(“input.txt”,ios::trunc);<br>表示截断并覆写文件。所有可以表示的参数：<br>ios::app 添加到文件尾<br>ios::ate 把文件标志放在末尾而非起始。<br>ios::trunc 默认. 截断并覆写文件。<br>ios::nocreate 文件不存在也不创建。<br>ios::noreplace 文件存在则失败。<br>通常ios::app用的会比较多，他可以让对拍程序分开输入数据到文件</p><h1 id="linux下的对拍"><a href="#linux下的对拍" class="headerlink" title="linux下的对拍"></a>linux下的对拍</h1><p>linux下的系统命令与windows的命令不太一样，所以对拍器的写法也要变一下。</p><p>其实要改的就只有work函数以及main函数，其他都不需要变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> random(a, b) ((a)+rand()%((b)-(a)+1))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_dataset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    fout.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">create_dataset</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;./my.out&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;./stand.out&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">system</span>(<span class="string">&quot;diff my.txt  stand.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> itNum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= itNum; i ++ ) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;正在运行第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;组数据&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">work</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;出错了&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">getchar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;g++ my.cpp -o my.out&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;g++ stand.cpp -o stand.out&quot;</span>);</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">64</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="nC3Pv"></a></p><h1 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h1><p>通常的数据生成比较容易，但是遇到一些不好处理的输入则需要模板<br><a name="ZPKHL"></a></p><h2 id="指定根节点的多叉树-无根树"><a href="#指定根节点的多叉树-无根树" class="headerlink" title="指定根节点的多叉树/无根树"></a>指定根节点的多叉树/无根树</h2><p>树的生成要保证边数等于结点树减一，并且不能成环且每个点之间都要联通<br>输入形式形如：<br>5<br>1 2<br>1 3<br>2 4<br>4 5<br>这种可以用并查集来维护这棵树。<br>考虑以1为根节点，那么只要对于n到2的每一个节点i,让random(1,i-1)为它的根，可以保证这样不会成环且连通。<br>如果不要求一定以1为根节点,可以用random_shuffle函数获得一个随机的1~n的排列，然后对应着输出就好。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">2</span>; --i) &#123;</span><br><span class="line">dsu[i] = <span class="built_in">random</span>(<span class="number">1</span>, i - <span class="number">1</span>);<span class="comment">//生成一颗以1为根节点的树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上为以1为根，随机还要重新编号对应一下，可以借助随机乱序函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) mapp[i] = i;</span><br><span class="line"><span class="built_in">random_shuffle</span>(mapp + <span class="number">1</span>, mapp + n + <span class="number">1</span>);<span class="comment">//随机排列</span></span><br><span class="line"><span class="comment">//打印树，必要可以随机边权</span></span><br><span class="line">fout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">fout &lt;&lt; mapp[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mapp[dsu[i]] &lt;&lt; endl;</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>形如：<br>9<br>1 3 2 4 5<br>2 2 3 6<br>3 2 7 9<br>4 1 8<br>5 0<br>6 0<br>7 0<br>8 0<br>9 0<br>其中2到n+1行的第一列表示第几个节点，第二列表示接来跟着的几个数的总数是所对应的相邻节点的个数。<br>实现的方法也很简单，第一种形式已经得到了第i个结点对应的父节点，所以可以反过来开一个set数组记录父节点对应的子节点，因为第一种生成的得到的会有重复，所以用set去重。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_dataset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">random</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">fout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"><span class="comment">//生成一棵以0为根节点的树</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">2</span>; --i) &#123;</span><br><span class="line">son[<span class="built_in">random</span>(<span class="number">1</span>, i - <span class="number">1</span>) - <span class="number">1</span>].<span class="built_in">insert</span>(i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">fout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">fout &lt;&lt; son[i].<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; son[i].<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> it : son[i]) &#123;</span><br><span class="line">fout &lt;&lt; it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20thZJCPC</title>
      <link href="/2023/08/19/20thZJCPC/"/>
      <url>/2023/08/19/20thZJCPC/</url>
      
        <content type="html"><![CDATA[<p>省赛补题，顺序大致按难度(赛时通过人数)排列</p><p>CF的gym里暂时还没有今年省赛的题目上传，目前只查到了<a href="https://qoj.ac/contest/1221">D/F/G/H/I的补题链接</a><br>2023.08.22<br><a name="D6zKp"></a></p><h1 id="A-Look-and-Say"><a href="#A-Look-and-Say" class="headerlink" title="A.Look and Say"></a>A.Look and Say</h1><p><img src="/2023/08/19/20thZJCPC/lookAndSay.png" alt="lookAndSay"></p><p>翻译：</p><p>给一个数字序列，你需要使用以下方法“描述”它：</p><p>1.每段划分成最大的连续相同的数字；</p><p>2 . 对于每段，将其替换为段的长度加段中的数字。例如，“0” 应替换为 “10”， ”9999999999“ 应替换为“109” </p><p>3.将替换的段连接在一起并输出</p><p>输入：</p><p>第一行包含一个整数n，范围是[1,1000]，表示输入序列的长度；</p><p>第二行为一个长度为n的序列，表示原始序列</p><p>输出：</p><p>输出转换后的序列</p><p>签到题，就是相同连续的数字压缩成长度+数字的组合输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> pre = <span class="string">&#x27;#&#x27;</span>, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;my.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t == pre)++cnt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pre != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; cnt &lt;&lt; pre;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = t;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="NaOBs"></a></p><h1 id="E-Interval-Sum"><a href="#E-Interval-Sum" class="headerlink" title="E.Interval Sum"></a>E.Interval Sum</h1><p><img src="/2023/08/19/20thZJCPC/IntervalSum.png" alt></p><p>翻译</p><p>构造一个长度为n的排列，使其所有子序列的和中能够被n整除的子序列的个数最多，输出任意一种构造。</p><p>输入：</p><p>一个n，表示排列的长度</p><p>输出：</p><p>一行排列，空格分开排列中的元素</p><p>一道贪心题，猜想比较好想：考虑哪些数相加为n，有n，{1，n-1},{2,n-2}…..注意n是偶数时，要把n放排列的最前面或者最后面，并且最后没有{n/2,n-n/2}这种组合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;my.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    t = n / <span class="number">2</span> + (n &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>))cout &lt;&lt; n / <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; t; ++i) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n - i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题<a href="https://www.luogu.com.cn/problem/P9573">P9573 「TAOI-2」核心共振</a>和它比较像，但更难一点<br><a name="G8CRf"></a></p><h1 id="M-A-Wine-and-Four-Dishes"><a href="#M-A-Wine-and-Four-Dishes" class="headerlink" title="M.A Wine and Four Dishes"></a>M.A Wine and Four Dishes</h1><p><img src="/2023/08/19/20thZJCPC/AWineandFourDishes.png" alt></p><p>翻译：</p><p>Rice老师为自己准备了一场盛宴。宴会上有x瓶酒和y盘菜，这意味着他需要x杯和y盘。</p><p>有n个箱子。第i个盒子里有a杯子和b盘子。请帮助Rice老师确定他必须打开的最小数量的盒子，这样他才能收集到足够的杯子和盘子。如果Rice老师不可能收集到足够的杯子或盘子，那么输出“IMPOSSIBLE”。</p><p>输入</p><p>第一行包含了三个整数n,x,y表示箱子数，瓶子和盘子数</p><p>接下来n行表示每个箱子含有的瓶子和盘子数量</p><p>输出</p><p>最小数量的盒子，无解输出IMPOSSIBLE</p><p>贪心题，注意到每个箱子包含的盘子数是[0,1]，所以如果x不是0，那么优先从含有x的箱子中选最大的那几个，选完了就选剩下的箱子中y最大的那几个，如果选完了都凑不出那么就是无解，数据很小，随便做都可以过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bottle</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">&#125; box[<span class="number">40</span>];</span><br><span class="line"><span class="type">int</span> n, x, y, bound = <span class="number">1</span>, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;my.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (!(x || y)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; box[i].a &gt;&gt; box[i].b;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(box + <span class="number">1</span>, box + <span class="number">1</span> + n, [&amp;](Bottle A, Bottle B) &#123; <span class="keyword">return</span> A.a &gt; B.a || A.a == B.a &amp;&amp; A.b &gt; B.b; &#125;);</span><br><span class="line">        <span class="keyword">if</span> (!box[x].a) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;IMPOSSIBLE&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; ++i, ++bound) t += box[i].b;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= y) &#123;</span><br><span class="line">            cout &lt;&lt; x;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(box + bound, box + <span class="number">1</span> + n, [&amp;](Bottle A, Bottle B) &#123; <span class="keyword">return</span> A.b &gt; B.b; &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = bound; i &lt;= n; ++i) &#123;</span><br><span class="line">            t += box[i].b;</span><br><span class="line">            <span class="keyword">if</span> (t &gt;= y) &#123;</span><br><span class="line">                cout &lt;&lt; i;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;IMPOSSIBLE&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">sort</span>(box + <span class="number">1</span>, box + <span class="number">1</span> + n, [&amp;](Bottle A, Bottle B) &#123; <span class="keyword">return</span> A.b &gt; B.b; &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            t += box[i].b;</span><br><span class="line">            <span class="keyword">if</span> (t &gt;= y) &#123;</span><br><span class="line">                cout &lt;&lt; i;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;IMPOSSIBLE&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比赛的时候还不知道sort还有这种写法，嫌写比较函数太复杂用优先队列和pair瞎搞做对的，有些队伍用搜索剪枝过的，好像背包也可以<br><a name="xSdUp"></a></p><h1 id="F-Turn-the-Light"><a href="#F-Turn-the-Light" class="headerlink" title="F.Turn the Light"></a>F.Turn the Light</h1><p><img src="/2023/08/19/20thZJCPC/TurntheLight.png" alt="TurntheLight"><br>翻译：<br>这是一个交互问题。<br>Putata有n个灯，从1到n从左到右编号。最初，所有的灯都是关着的。其中一盏灯是他最喜欢的灯,灯的号码是隐藏的。 Budada想知道Putata最喜欢的灯的编号，他可以做如下查询:<br>“? x”:如果x的灯是关的，打开编号为x的灯，然后问putata，在putata最喜欢的灯的左边打开的灯数的绝对值减去右边打开的灯数。<br>Budada只能进行不超过40次的查询。请帮他找到putata最喜欢的灯。在这个问题中，交互者是自适应的，这意味着答案可能不是固定的，交互者可以任意选择它，并且答案将与你与交互者的交互相一致。<br>已通过此<a href="https://qoj.ac/contest/1221/problem/6394">oj</a>的评测<br>2023.08.22<br>一眼二分，因为首先这个数据范围符合二分(log2(n)&lt;40)，并且不难看出如果输出和上一次比较没有变化那么那个数就是喜欢的数，但是发现由于输出的是差的绝对值，所以没有单调性，但又发现log2(n)*2是一个接近40的数，所以猜测每次问两次保证单调性：每次都先问左边界的数是不是喜欢的数字，然后再二分问中间的数是不是喜欢的先问左边界就保证了左边的数始终大于右边的数，也就去掉了绝对值使其有了单调性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, pre, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + <span class="number">1</span> + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t == pre) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = t;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t == pre) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre &gt; t) r = mid - <span class="number">1</span>, l++;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        pre = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//验题代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> random(a, b) ((a)+rand()%((b)-(a)+1))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, pre, t;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> st[<span class="number">1000006</span>];</span><br><span class="line"><span class="type">int</span> lLight, rLight, cnt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_num</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> x, <span class="type">int</span> fav)</span> </span>&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == fav &amp;&amp; cnt &lt;= <span class="number">40</span>)cout &lt;&lt; <span class="string">&quot;Accept&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt &gt; <span class="number">40</span>)cout &lt;&lt; <span class="string">&quot;Time Limit Error&quot;</span> &lt;&lt; endl, <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Wrong Answer&quot;</span> &lt;&lt; endl, <span class="built_in">getchar</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; fav &amp;&amp; !st[x]) &#123;</span><br><span class="line">            ++rLight;</span><br><span class="line">            st[x] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; fav &amp;&amp; !st[x]) &#123;</span><br><span class="line">            ++lLight;</span><br><span class="line">            st[x] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">abs</span>(lLight - rLight) &lt;&lt; endl;</span><br><span class="line">        t = <span class="built_in">abs</span>(lLight - rLight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    n = pre = t = lLight = rLight = cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    n = <span class="built_in">random</span>(<span class="number">1</span>, <span class="number">1000000</span>);</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">random</span>(<span class="number">1</span>, n);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + <span class="number">1</span> + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">get_num</span>(<span class="string">&#x27;?&#x27;</span>, l, num);</span><br><span class="line">        <span class="keyword">if</span> (t == pre) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">get_num</span>(<span class="string">&#x27;!&#x27;</span>, l, num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = t;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">get_num</span>(<span class="string">&#x27;?&#x27;</span>, mid, num);</span><br><span class="line">        <span class="keyword">if</span> (t == pre) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">get_num</span>(<span class="string">&#x27;!&#x27;</span>, mid, num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre &gt; t)</span><br><span class="line">            r = mid - <span class="number">1</span>, l++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        pre = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;正在运行第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;个数据&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑了很多组对拍发现其实这个算法能够在29次询问以内通过</p><p><a name="rEnYB"></a></p><h1 id="K-Lazy-but-Diligent"><a href="#K-Lazy-but-Diligent" class="headerlink" title="K. Lazy but Diligent"></a><strong>K. Lazy but Diligent</strong></h1><p><img src="/2023/08/19/20thZJCPC/LazybutDiligent.png" alt="LazybutDiligent"><br>翻译：<br>PigeIand大学拥有n幢编号分别为1-n的建筑物，其中1号楼是学生宿舍，其他是教学楼。所有建筑物通过双向路径连接，其中第i条路是长度为li,链接xi和yi楼，从a时间开始，到b时间结束。小猪需要在t时间后回到宿舍休息，更重要的是，在她的学习时间，小猪可以偷偷溜回去睡觉。小猪很懒，但很聪明，所以她希望 在学习期间至少花 s 个单位的时间在宿舍睡觉。我们认为小猪参加课程i，当且仅当她在从ai到bi的时间里都待在pi楼，这意味着她必须完成整个课程。请输出小猪最多能学习多少门课程，同时满足她的睡眠要求。<br>输入：<br>第一行包含五个整数n，m，g，t，s，表示建筑物的数目、道路的数目、课程的数目，总学习时间，需要睡眠的时间<br>以下m行中的每一行都包含三个整数$x_{i},y_i,l_i$，表示连接x和y的双向路径，长度为l。<br>以下q行中的每一行都包含三个整数$a_i,b_i,p_i$，表示这门课程在p楼从a点开始到b点结束。<br>输出：<br>最多能学习多少门课程</p><p>这题的程序对拍目前只验证了树这一特殊图的情况<br>2023.08.21<br>第一次做这种带图的dp。一般没有什么思路感觉像深搜的时候就可以考虑dp了。<br>n个楼，m条路，m的数据保证了图是联通的，q个课程，问在满足条件下最多可以学几门。<br>看范围q&lt;=400,考虑n^3的dp，也就是说状态的维数必须是小于等于3，首先因为要枚举，所以显然有一维一定是i，表示当前枚举到第几个课程，那么可以发现上一步在哪里也会影响到后面的决策，所以再加一维j，表示在哪里，由于要枚举当前和之前在哪里，所以复杂度再加上n^2,总复杂度在n^3左右可以通过。<br>除了第i个课并且此时在j楼时最多能学习的课程的数目要用dp表存储以外，这道题还需要在第i个课并且此时在j楼时最多能休息的时间长度上dp，因为存在中途可以回去睡觉的情况：当这个人前一步在k位置并且要走到j位置时，因为j课程有开始时间的限制，所以如果他走到j还要花时间等待j课程到开始时间，所以不如在k点时先回到1号点休息后再从1号点走到j点，这样就能保证在不耽误课程的情况下能够谁最多的时间（前提是回1号点再走到j点不会大于j课程开始时间）。<br>状态定义：<br>dp[i][j]，表示已经上到i个课并且此时在j楼时最多能学习的课程的数目<br>rest[i][j],表示已经上到i个课并且此时在j楼时最多能休息的时间的长度<br>状态转移：<br>当枚举的前一个有课的教学楼的位置能够到达（只有在这个位置上过课的才有必要停留在这个位置，否则对于结果没有贡献也就没有必要到那个位置），并从这幢楼的课程的结束时间加上从这个位置到当前想去的位置所需要的时间：<br>即当满足：<br><code>dp[i - 1][course[k].p] &amp;&amp; dist[course[k].p][course[j].p] + course[k].b &lt;= course[j].a</code><br>就可以计算从k点时先回到1号点休息后再从1号点走到j点最多可以休息的时间restT：<br><code>restT = max(course[j].a - course[k].b - dist[course[k].p][1] - dist[1][course[j].p], 0)</code><br>然后需要判断两个限制条件：一个是学完课程后能不能在规定的时间内回到1号点，第二个是总的睡眠时间小于需要的睡眠时间，<br>即当满足：<br><code>course[j].b + dist[course[j].p][1] &lt;= t &amp;&amp; (t - course[j].b - dist[course[j].p][1]) + restT + rest[i - 1][k] &gt;= s</code><br>有转移方程：<br><code>dp[i][course[j].p] = max(dp[i][course[j].p], dp[i - 1][course[k].p] + 1)</code><br><code>rest[i][j] = min(s, max(rest[i][j], rest[i - 1][k] + restT))</code><br>同时更新答案：<code>ans = max(ans, dp[i][course[j].p])</code><br>开始之前先floyd跑出任意2栋楼直接最短路，存在dist数组里预处理。也要预处理出到第一个位置可以睡的最长时间和能不能到达那个位置，因为第一个位置比较特殊不用考虑前一个位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">10</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">9</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">8</span> <span class="number">3</span></span><br><span class="line">output：<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">4</span> <span class="number">15</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">8</span> <span class="number">9</span> <span class="number">3</span></span><br><span class="line"><span class="number">13</span> <span class="number">14</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line">output：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">hack：</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">1</span> <span class="number">5883</span> <span class="number">1327</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">43</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">48</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">37</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span> <span class="number">43</span></span><br><span class="line"><span class="number">1398</span> <span class="number">5257</span> <span class="number">2</span></span><br><span class="line">output：<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3760</span> <span class="number">1835</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">16</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">53</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">89</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span> <span class="number">61</span></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">49</span></span><br><span class="line"><span class="number">320</span> <span class="number">1728</span> <span class="number">4</span></span><br><span class="line"><span class="number">437</span> <span class="number">2046</span> <span class="number">2</span></span><br><span class="line"><span class="number">1950</span> <span class="number">2242</span> <span class="number">6</span></span><br><span class="line"><span class="number">3754</span> <span class="number">3758</span> <span class="number">3</span></span><br><span class="line"><span class="number">1689</span> <span class="number">3242</span> <span class="number">5</span></span><br><span class="line">output: <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">3</span> <span class="number">1967</span> <span class="number">1249</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">40</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">72</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">93</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">49</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">36</span></span><br><span class="line"><span class="number">1651</span> <span class="number">1928</span> <span class="number">5</span></span><br><span class="line"><span class="number">591</span> <span class="number">770</span> <span class="number">6</span></span><br><span class="line"><span class="number">1557</span> <span class="number">1612</span> <span class="number">4</span></span><br><span class="line">output:<span class="number">1</span></span><br><span class="line"></span><br><span class="line">大样例:</span><br><span class="line"><span class="number">155</span> <span class="number">154</span> <span class="number">126</span> <span class="number">3118</span> <span class="number">1830</span> </span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">10</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">7</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">66</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span> <span class="number">89</span></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">42</span></span><br><span class="line"><span class="number">8</span> <span class="number">4</span> <span class="number">81</span></span><br><span class="line"><span class="number">9</span> <span class="number">3</span> <span class="number">59</span></span><br><span class="line"><span class="number">10</span> <span class="number">1</span> <span class="number">28</span></span><br><span class="line"><span class="number">11</span> <span class="number">8</span> <span class="number">33</span></span><br><span class="line"><span class="number">12</span> <span class="number">4</span> <span class="number">38</span></span><br><span class="line"><span class="number">13</span> <span class="number">3</span> <span class="number">70</span></span><br><span class="line"><span class="number">14</span> <span class="number">3</span> <span class="number">93</span></span><br><span class="line"><span class="number">15</span> <span class="number">13</span> <span class="number">71</span></span><br><span class="line"><span class="number">16</span> <span class="number">15</span> <span class="number">28</span></span><br><span class="line"><span class="number">17</span> <span class="number">2</span> <span class="number">87</span></span><br><span class="line"><span class="number">18</span> <span class="number">8</span> <span class="number">41</span></span><br><span class="line"><span class="number">19</span> <span class="number">4</span> <span class="number">67</span></span><br><span class="line"><span class="number">20</span> <span class="number">13</span> <span class="number">12</span></span><br><span class="line"><span class="number">21</span> <span class="number">15</span> <span class="number">27</span></span><br><span class="line"><span class="number">22</span> <span class="number">15</span> <span class="number">59</span></span><br><span class="line"><span class="number">23</span> <span class="number">15</span> <span class="number">72</span></span><br><span class="line"><span class="number">24</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">25</span> <span class="number">11</span> <span class="number">59</span></span><br><span class="line"><span class="number">26</span> <span class="number">12</span> <span class="number">12</span></span><br><span class="line"><span class="number">27</span> <span class="number">8</span> <span class="number">57</span></span><br><span class="line"><span class="number">28</span> <span class="number">15</span> <span class="number">50</span></span><br><span class="line"><span class="number">29</span> <span class="number">15</span> <span class="number">51</span></span><br><span class="line"><span class="number">30</span> <span class="number">4</span> <span class="number">18</span></span><br><span class="line"><span class="number">31</span> <span class="number">1</span> <span class="number">82</span></span><br><span class="line"><span class="number">32</span> <span class="number">3</span> <span class="number">66</span></span><br><span class="line"><span class="number">33</span> <span class="number">3</span> <span class="number">35</span></span><br><span class="line"><span class="number">34</span> <span class="number">10</span> <span class="number">28</span></span><br><span class="line"><span class="number">35</span> <span class="number">5</span> <span class="number">89</span></span><br><span class="line"><span class="number">36</span> <span class="number">14</span> <span class="number">70</span></span><br><span class="line"><span class="number">37</span> <span class="number">5</span> <span class="number">22</span></span><br><span class="line"><span class="number">38</span> <span class="number">15</span> <span class="number">93</span></span><br><span class="line"><span class="number">39</span> <span class="number">10</span> <span class="number">52</span></span><br><span class="line"><span class="number">40</span> <span class="number">29</span> <span class="number">8</span></span><br><span class="line"><span class="number">41</span> <span class="number">25</span> <span class="number">10</span></span><br><span class="line"><span class="number">42</span> <span class="number">26</span> <span class="number">103</span></span><br><span class="line"><span class="number">43</span> <span class="number">39</span> <span class="number">36</span></span><br><span class="line"><span class="number">44</span> <span class="number">7</span> <span class="number">65</span></span><br><span class="line"><span class="number">45</span> <span class="number">21</span> <span class="number">71</span></span><br><span class="line"><span class="number">46</span> <span class="number">37</span> <span class="number">91</span></span><br><span class="line"><span class="number">47</span> <span class="number">11</span> <span class="number">67</span></span><br><span class="line"><span class="number">48</span> <span class="number">8</span> <span class="number">52</span></span><br><span class="line"><span class="number">49</span> <span class="number">32</span> <span class="number">91</span></span><br><span class="line"><span class="number">50</span> <span class="number">31</span> <span class="number">46</span></span><br><span class="line"><span class="number">51</span> <span class="number">10</span> <span class="number">83</span></span><br><span class="line"><span class="number">52</span> <span class="number">19</span> <span class="number">58</span></span><br><span class="line"><span class="number">53</span> <span class="number">42</span> <span class="number">77</span></span><br><span class="line"><span class="number">54</span> <span class="number">31</span> <span class="number">85</span></span><br><span class="line"><span class="number">55</span> <span class="number">30</span> <span class="number">31</span></span><br><span class="line"><span class="number">56</span> <span class="number">2</span> <span class="number">37</span></span><br><span class="line"><span class="number">57</span> <span class="number">31</span> <span class="number">104</span></span><br><span class="line"><span class="number">58</span> <span class="number">26</span> <span class="number">20</span></span><br><span class="line"><span class="number">59</span> <span class="number">55</span> <span class="number">14</span></span><br><span class="line"><span class="number">60</span> <span class="number">47</span> <span class="number">73</span></span><br><span class="line"><span class="number">61</span> <span class="number">60</span> <span class="number">27</span></span><br><span class="line"><span class="number">62</span> <span class="number">12</span> <span class="number">43</span></span><br><span class="line"><span class="number">63</span> <span class="number">36</span> <span class="number">36</span></span><br><span class="line"><span class="number">64</span> <span class="number">19</span> <span class="number">95</span></span><br><span class="line"><span class="number">65</span> <span class="number">33</span> <span class="number">71</span></span><br><span class="line"><span class="number">66</span> <span class="number">27</span> <span class="number">3</span></span><br><span class="line"><span class="number">67</span> <span class="number">17</span> <span class="number">99</span></span><br><span class="line"><span class="number">68</span> <span class="number">29</span> <span class="number">4</span></span><br><span class="line"><span class="number">69</span> <span class="number">17</span> <span class="number">32</span></span><br><span class="line"><span class="number">70</span> <span class="number">63</span> <span class="number">64</span></span><br><span class="line"><span class="number">71</span> <span class="number">44</span> <span class="number">51</span></span><br><span class="line"><span class="number">72</span> <span class="number">20</span> <span class="number">25</span></span><br><span class="line"><span class="number">73</span> <span class="number">31</span> <span class="number">47</span></span><br><span class="line"><span class="number">74</span> <span class="number">65</span> <span class="number">23</span></span><br><span class="line"><span class="number">75</span> <span class="number">43</span> <span class="number">29</span></span><br><span class="line"><span class="number">76</span> <span class="number">50</span> <span class="number">5</span></span><br><span class="line"><span class="number">77</span> <span class="number">59</span> <span class="number">63</span></span><br><span class="line"><span class="number">78</span> <span class="number">60</span> <span class="number">17</span></span><br><span class="line"><span class="number">79</span> <span class="number">30</span> <span class="number">86</span></span><br><span class="line"><span class="number">80</span> <span class="number">41</span> <span class="number">32</span></span><br><span class="line"><span class="number">81</span> <span class="number">3</span> <span class="number">15</span></span><br><span class="line"><span class="number">82</span> <span class="number">26</span> <span class="number">72</span></span><br><span class="line"><span class="number">83</span> <span class="number">80</span> <span class="number">2</span></span><br><span class="line"><span class="number">84</span> <span class="number">39</span> <span class="number">49</span></span><br><span class="line"><span class="number">85</span> <span class="number">66</span> <span class="number">40</span></span><br><span class="line"><span class="number">86</span> <span class="number">22</span> <span class="number">26</span></span><br><span class="line"><span class="number">87</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">88</span> <span class="number">38</span> <span class="number">91</span></span><br><span class="line"><span class="number">89</span> <span class="number">22</span> <span class="number">96</span></span><br><span class="line"><span class="number">90</span> <span class="number">36</span> <span class="number">4</span></span><br><span class="line"><span class="number">91</span> <span class="number">52</span> <span class="number">52</span></span><br><span class="line"><span class="number">92</span> <span class="number">66</span> <span class="number">99</span></span><br><span class="line"><span class="number">93</span> <span class="number">52</span> <span class="number">54</span></span><br><span class="line"><span class="number">94</span> <span class="number">1</span> <span class="number">73</span></span><br><span class="line"><span class="number">95</span> <span class="number">67</span> <span class="number">1</span></span><br><span class="line"><span class="number">96</span> <span class="number">6</span> <span class="number">21</span></span><br><span class="line"><span class="number">97</span> <span class="number">65</span> <span class="number">23</span></span><br><span class="line"><span class="number">98</span> <span class="number">90</span> <span class="number">91</span></span><br><span class="line"><span class="number">99</span> <span class="number">42</span> <span class="number">32</span></span><br><span class="line"><span class="number">100</span> <span class="number">75</span> <span class="number">55</span></span><br><span class="line"><span class="number">101</span> <span class="number">90</span> <span class="number">47</span></span><br><span class="line"><span class="number">102</span> <span class="number">10</span> <span class="number">1</span></span><br><span class="line"><span class="number">103</span> <span class="number">32</span> <span class="number">77</span></span><br><span class="line"><span class="number">104</span> <span class="number">47</span> <span class="number">86</span></span><br><span class="line"><span class="number">105</span> <span class="number">5</span> <span class="number">76</span></span><br><span class="line"><span class="number">106</span> <span class="number">83</span> <span class="number">50</span></span><br><span class="line"><span class="number">107</span> <span class="number">90</span> <span class="number">3</span></span><br><span class="line"><span class="number">108</span> <span class="number">52</span> <span class="number">88</span></span><br><span class="line"><span class="number">109</span> <span class="number">10</span> <span class="number">72</span></span><br><span class="line"><span class="number">110</span> <span class="number">40</span> <span class="number">96</span></span><br><span class="line"><span class="number">111</span> <span class="number">71</span> <span class="number">71</span></span><br><span class="line"><span class="number">112</span> <span class="number">45</span> <span class="number">10</span></span><br><span class="line"><span class="number">113</span> <span class="number">21</span> <span class="number">85</span></span><br><span class="line"><span class="number">114</span> <span class="number">21</span> <span class="number">56</span></span><br><span class="line"><span class="number">115</span> <span class="number">15</span> <span class="number">80</span></span><br><span class="line"><span class="number">116</span> <span class="number">40</span> <span class="number">59</span></span><br><span class="line"><span class="number">117</span> <span class="number">34</span> <span class="number">78</span></span><br><span class="line"><span class="number">118</span> <span class="number">60</span> <span class="number">66</span></span><br><span class="line"><span class="number">119</span> <span class="number">114</span> <span class="number">47</span></span><br><span class="line"><span class="number">120</span> <span class="number">64</span> <span class="number">24</span></span><br><span class="line"><span class="number">121</span> <span class="number">72</span> <span class="number">19</span></span><br><span class="line"><span class="number">122</span> <span class="number">101</span> <span class="number">68</span></span><br><span class="line"><span class="number">123</span> <span class="number">46</span> <span class="number">27</span></span><br><span class="line"><span class="number">124</span> <span class="number">55</span> <span class="number">17</span></span><br><span class="line"><span class="number">125</span> <span class="number">22</span> <span class="number">13</span></span><br><span class="line"><span class="number">126</span> <span class="number">8</span> <span class="number">12</span></span><br><span class="line"><span class="number">127</span> <span class="number">49</span> <span class="number">96</span></span><br><span class="line"><span class="number">128</span> <span class="number">70</span> <span class="number">28</span></span><br><span class="line"><span class="number">129</span> <span class="number">58</span> <span class="number">35</span></span><br><span class="line"><span class="number">130</span> <span class="number">108</span> <span class="number">21</span></span><br><span class="line"><span class="number">131</span> <span class="number">58</span> <span class="number">65</span></span><br><span class="line"><span class="number">132</span> <span class="number">40</span> <span class="number">9</span></span><br><span class="line"><span class="number">133</span> <span class="number">100</span> <span class="number">37</span></span><br><span class="line"><span class="number">134</span> <span class="number">65</span> <span class="number">73</span></span><br><span class="line"><span class="number">135</span> <span class="number">74</span> <span class="number">76</span></span><br><span class="line"><span class="number">136</span> <span class="number">17</span> <span class="number">54</span></span><br><span class="line"><span class="number">137</span> <span class="number">42</span> <span class="number">63</span></span><br><span class="line"><span class="number">138</span> <span class="number">21</span> <span class="number">32</span></span><br><span class="line"><span class="number">139</span> <span class="number">44</span> <span class="number">102</span></span><br><span class="line"><span class="number">140</span> <span class="number">45</span> <span class="number">91</span></span><br><span class="line"><span class="number">141</span> <span class="number">17</span> <span class="number">40</span></span><br><span class="line"><span class="number">142</span> <span class="number">120</span> <span class="number">56</span></span><br><span class="line"><span class="number">143</span> <span class="number">74</span> <span class="number">78</span></span><br><span class="line"><span class="number">144</span> <span class="number">31</span> <span class="number">1</span></span><br><span class="line"><span class="number">145</span> <span class="number">12</span> <span class="number">75</span></span><br><span class="line"><span class="number">146</span> <span class="number">47</span> <span class="number">46</span></span><br><span class="line"><span class="number">147</span> <span class="number">26</span> <span class="number">86</span></span><br><span class="line"><span class="number">148</span> <span class="number">30</span> <span class="number">14</span></span><br><span class="line"><span class="number">149</span> <span class="number">115</span> <span class="number">69</span></span><br><span class="line"><span class="number">150</span> <span class="number">32</span> <span class="number">12</span></span><br><span class="line"><span class="number">151</span> <span class="number">57</span> <span class="number">87</span></span><br><span class="line"><span class="number">152</span> <span class="number">106</span> <span class="number">20</span></span><br><span class="line"><span class="number">153</span> <span class="number">110</span> <span class="number">57</span></span><br><span class="line"><span class="number">154</span> <span class="number">139</span> <span class="number">3</span></span><br><span class="line"><span class="number">155</span> <span class="number">121</span> <span class="number">60</span></span><br><span class="line"><span class="number">1889</span> <span class="number">2840</span> <span class="number">127</span></span><br><span class="line"><span class="number">2328</span> <span class="number">2789</span> <span class="number">9</span></span><br><span class="line"><span class="number">1254</span> <span class="number">1456</span> <span class="number">52</span></span><br><span class="line"><span class="number">2231</span> <span class="number">3048</span> <span class="number">25</span></span><br><span class="line"><span class="number">1937</span> <span class="number">2019</span> <span class="number">96</span></span><br><span class="line"><span class="number">71</span> <span class="number">117</span> <span class="number">91</span></span><br><span class="line"><span class="number">556</span> <span class="number">1318</span> <span class="number">79</span></span><br><span class="line"><span class="number">2029</span> <span class="number">2616</span> <span class="number">33</span></span><br><span class="line"><span class="number">363</span> <span class="number">1158</span> <span class="number">29</span></span><br><span class="line"><span class="number">60</span> <span class="number">1979</span> <span class="number">40</span></span><br><span class="line"><span class="number">2938</span> <span class="number">2971</span> <span class="number">95</span></span><br><span class="line"><span class="number">1506</span> <span class="number">2530</span> <span class="number">15</span></span><br><span class="line"><span class="number">484</span> <span class="number">1232</span> <span class="number">13</span></span><br><span class="line"><span class="number">2142</span> <span class="number">2273</span> <span class="number">94</span></span><br><span class="line"><span class="number">2418</span> <span class="number">3085</span> <span class="number">26</span></span><br><span class="line"><span class="number">1456</span> <span class="number">2049</span> <span class="number">69</span></span><br><span class="line"><span class="number">409</span> <span class="number">2793</span> <span class="number">81</span></span><br><span class="line"><span class="number">2506</span> <span class="number">2876</span> <span class="number">122</span></span><br><span class="line"><span class="number">1694</span> <span class="number">2651</span> <span class="number">43</span></span><br><span class="line"><span class="number">2734</span> <span class="number">3020</span> <span class="number">87</span></span><br><span class="line"><span class="number">665</span> <span class="number">1578</span> <span class="number">134</span></span><br><span class="line"><span class="number">1107</span> <span class="number">1681</span> <span class="number">145</span></span><br><span class="line"><span class="number">2654</span> <span class="number">3059</span> <span class="number">73</span></span><br><span class="line"><span class="number">387</span> <span class="number">1226</span> <span class="number">143</span></span><br><span class="line"><span class="number">1957</span> <span class="number">2556</span> <span class="number">133</span></span><br><span class="line"><span class="number">1355</span> <span class="number">1893</span> <span class="number">93</span></span><br><span class="line"><span class="number">995</span> <span class="number">1661</span> <span class="number">152</span></span><br><span class="line"><span class="number">1011</span> <span class="number">2205</span> <span class="number">51</span></span><br><span class="line"><span class="number">1251</span> <span class="number">2780</span> <span class="number">58</span></span><br><span class="line"><span class="number">2251</span> <span class="number">2374</span> <span class="number">121</span></span><br><span class="line"><span class="number">1824</span> <span class="number">1847</span> <span class="number">54</span></span><br><span class="line"><span class="number">504</span> <span class="number">1866</span> <span class="number">42</span></span><br><span class="line"><span class="number">738</span> <span class="number">2361</span> <span class="number">154</span></span><br><span class="line"><span class="number">1233</span> <span class="number">1627</span> <span class="number">78</span></span><br><span class="line"><span class="number">1330</span> <span class="number">2763</span> <span class="number">68</span></span><br><span class="line"><span class="number">1994</span> <span class="number">2048</span> <span class="number">18</span></span><br><span class="line"><span class="number">1636</span> <span class="number">2392</span> <span class="number">66</span></span><br><span class="line"><span class="number">17</span> <span class="number">2079</span> <span class="number">155</span></span><br><span class="line"><span class="number">1324</span> <span class="number">2415</span> <span class="number">45</span></span><br><span class="line"><span class="number">675</span> <span class="number">1181</span> <span class="number">129</span></span><br><span class="line"><span class="number">1536</span> <span class="number">2185</span> <span class="number">108</span></span><br><span class="line"><span class="number">1332</span> <span class="number">1752</span> <span class="number">57</span></span><br><span class="line"><span class="number">1307</span> <span class="number">2932</span> <span class="number">85</span></span><br><span class="line"><span class="number">1078</span> <span class="number">1130</span> <span class="number">99</span></span><br><span class="line"><span class="number">902</span> <span class="number">982</span> <span class="number">24</span></span><br><span class="line"><span class="number">1791</span> <span class="number">2453</span> <span class="number">21</span></span><br><span class="line"><span class="number">1528</span> <span class="number">2256</span> <span class="number">148</span></span><br><span class="line"><span class="number">3032</span> <span class="number">3047</span> <span class="number">114</span></span><br><span class="line"><span class="number">1493</span> <span class="number">3016</span> <span class="number">103</span></span><br><span class="line"><span class="number">1298</span> <span class="number">2529</span> <span class="number">104</span></span><br><span class="line"><span class="number">434</span> <span class="number">2578</span> <span class="number">63</span></span><br><span class="line"><span class="number">1682</span> <span class="number">2611</span> <span class="number">36</span></span><br><span class="line"><span class="number">1722</span> <span class="number">3056</span> <span class="number">5</span></span><br><span class="line"><span class="number">350</span> <span class="number">2091</span> <span class="number">20</span></span><br><span class="line"><span class="number">1822</span> <span class="number">2810</span> <span class="number">62</span></span><br><span class="line"><span class="number">1196</span> <span class="number">1885</span> <span class="number">38</span></span><br><span class="line"><span class="number">486</span> <span class="number">1738</span> <span class="number">105</span></span><br><span class="line"><span class="number">722</span> <span class="number">1375</span> <span class="number">17</span></span><br><span class="line"><span class="number">495</span> <span class="number">1559</span> <span class="number">120</span></span><br><span class="line"><span class="number">262</span> <span class="number">837</span> <span class="number">37</span></span><br><span class="line"><span class="number">404</span> <span class="number">2209</span> <span class="number">124</span></span><br><span class="line"><span class="number">1621</span> <span class="number">2570</span> <span class="number">89</span></span><br><span class="line"><span class="number">1966</span> <span class="number">2783</span> <span class="number">65</span></span><br><span class="line"><span class="number">2970</span> <span class="number">3024</span> <span class="number">50</span></span><br><span class="line"><span class="number">2020</span> <span class="number">3033</span> <span class="number">136</span></span><br><span class="line"><span class="number">1410</span> <span class="number">1559</span> <span class="number">83</span></span><br><span class="line"><span class="number">504</span> <span class="number">1481</span> <span class="number">90</span></span><br><span class="line"><span class="number">288</span> <span class="number">1350</span> <span class="number">97</span></span><br><span class="line"><span class="number">755</span> <span class="number">1289</span> <span class="number">117</span></span><br><span class="line"><span class="number">1232</span> <span class="number">1552</span> <span class="number">80</span></span><br><span class="line"><span class="number">2967</span> <span class="number">3025</span> <span class="number">70</span></span><br><span class="line"><span class="number">1695</span> <span class="number">2304</span> <span class="number">106</span></span><br><span class="line"><span class="number">2874</span> <span class="number">2900</span> <span class="number">109</span></span><br><span class="line"><span class="number">1257</span> <span class="number">3109</span> <span class="number">56</span></span><br><span class="line"><span class="number">1900</span> <span class="number">2510</span> <span class="number">101</span></span><br><span class="line"><span class="number">2535</span> <span class="number">2961</span> <span class="number">32</span></span><br><span class="line"><span class="number">2636</span> <span class="number">2975</span> <span class="number">48</span></span><br><span class="line"><span class="number">2951</span> <span class="number">2962</span> <span class="number">14</span></span><br><span class="line"><span class="number">2964</span> <span class="number">2994</span> <span class="number">130</span></span><br><span class="line"><span class="number">1325</span> <span class="number">1407</span> <span class="number">35</span></span><br><span class="line"><span class="number">60</span> <span class="number">523</span> <span class="number">88</span></span><br><span class="line"><span class="number">1701</span> <span class="number">2273</span> <span class="number">12</span></span><br><span class="line"><span class="number">710</span> <span class="number">2279</span> <span class="number">31</span></span><br><span class="line"><span class="number">557</span> <span class="number">668</span> <span class="number">76</span></span><br><span class="line"><span class="number">2459</span> <span class="number">2546</span> <span class="number">111</span></span><br><span class="line"><span class="number">2925</span> <span class="number">3092</span> <span class="number">119</span></span><br><span class="line"><span class="number">700</span> <span class="number">2041</span> <span class="number">128</span></span><br><span class="line"><span class="number">2117</span> <span class="number">2311</span> <span class="number">125</span></span><br><span class="line"><span class="number">2152</span> <span class="number">2252</span> <span class="number">126</span></span><br><span class="line"><span class="number">1646</span> <span class="number">2038</span> <span class="number">8</span></span><br><span class="line"><span class="number">1867</span> <span class="number">3039</span> <span class="number">102</span></span><br><span class="line"><span class="number">2341</span> <span class="number">2360</span> <span class="number">34</span></span><br><span class="line"><span class="number">906</span> <span class="number">1225</span> <span class="number">86</span></span><br><span class="line"><span class="number">1270</span> <span class="number">1906</span> <span class="number">150</span></span><br><span class="line"><span class="number">267</span> <span class="number">2672</span> <span class="number">39</span></span><br><span class="line"><span class="number">1684</span> <span class="number">1807</span> <span class="number">55</span></span><br><span class="line"><span class="number">1622</span> <span class="number">1746</span> <span class="number">149</span></span><br><span class="line"><span class="number">170</span> <span class="number">1839</span> <span class="number">142</span></span><br><span class="line"><span class="number">1234</span> <span class="number">2035</span> <span class="number">132</span></span><br><span class="line"><span class="number">3045</span> <span class="number">3065</span> <span class="number">151</span></span><br><span class="line"><span class="number">1832</span> <span class="number">2659</span> <span class="number">2</span></span><br><span class="line"><span class="number">2800</span> <span class="number">3045</span> <span class="number">110</span></span><br><span class="line"><span class="number">56</span> <span class="number">1396</span> <span class="number">135</span></span><br><span class="line"><span class="number">2119</span> <span class="number">3050</span> <span class="number">140</span></span><br><span class="line"><span class="number">218</span> <span class="number">299</span> <span class="number">118</span></span><br><span class="line"><span class="number">1911</span> <span class="number">2022</span> <span class="number">41</span></span><br><span class="line"><span class="number">1737</span> <span class="number">2205</span> <span class="number">137</span></span><br><span class="line"><span class="number">2694</span> <span class="number">2728</span> <span class="number">27</span></span><br><span class="line"><span class="number">1661</span> <span class="number">2797</span> <span class="number">72</span></span><br><span class="line"><span class="number">1662</span> <span class="number">2828</span> <span class="number">131</span></span><br><span class="line"><span class="number">49</span> <span class="number">390</span> <span class="number">146</span></span><br><span class="line"><span class="number">2206</span> <span class="number">2350</span> <span class="number">3</span></span><br><span class="line"><span class="number">293</span> <span class="number">331</span> <span class="number">10</span></span><br><span class="line"><span class="number">1784</span> <span class="number">2204</span> <span class="number">47</span></span><br><span class="line"><span class="number">43</span> <span class="number">192</span> <span class="number">74</span></span><br><span class="line"><span class="number">596</span> <span class="number">769</span> <span class="number">46</span></span><br><span class="line"><span class="number">2109</span> <span class="number">2766</span> <span class="number">144</span></span><br><span class="line"><span class="number">2992</span> <span class="number">3050</span> <span class="number">22</span></span><br><span class="line"><span class="number">2381</span> <span class="number">3024</span> <span class="number">123</span></span><br><span class="line"><span class="number">2156</span> <span class="number">2873</span> <span class="number">107</span></span><br><span class="line"><span class="number">67</span> <span class="number">1236</span> <span class="number">67</span></span><br><span class="line"><span class="number">717</span> <span class="number">726</span> <span class="number">98</span></span><br><span class="line"><span class="number">2357</span> <span class="number">2483</span> <span class="number">4</span></span><br><span class="line"><span class="number">211</span> <span class="number">686</span> <span class="number">100</span></span><br><span class="line"><span class="number">1506</span> <span class="number">2983</span> <span class="number">116</span></span><br><span class="line"><span class="number">1196</span> <span class="number">1301</span> <span class="number">77</span></span><br><span class="line">output:<span class="number">6</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 405</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dist[N][N], dp[N][N], n, m, q, t, s, ans;</span><br><span class="line"><span class="type">int</span> rest[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, p;</span><br><span class="line">&#125; course[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;my.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q &gt;&gt; t &gt;&gt; s;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        dist[a][b] = dist[b][a] = <span class="built_in">min</span>(dist[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        course[i].a = a, course[i].b = b, course[i].p = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[<span class="number">1</span>][course[i].p] &lt;= course[i].a) &#123;</span><br><span class="line">            rest[<span class="number">1</span>][i] = <span class="built_in">min</span>(course[i].a - dist[<span class="number">1</span>][course[i].p], s);</span><br><span class="line">            <span class="keyword">if</span> (t - (dist[course[i].p][<span class="number">1</span>] + course[i].b) + rest[<span class="number">1</span>][i] &gt;= s) &#123;</span><br><span class="line">                ++dp[<span class="number">1</span>][course[i].p];</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[<span class="number">1</span>][course[i].p]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= q; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= q; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= q; ++k)</span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][course[k].p] &amp;&amp; dist[course[k].p][course[j].p] + course[k].b &lt;= course[j].a) &#123;</span><br><span class="line">                    <span class="type">int</span> restT = <span class="built_in">max</span>(course[j].a - course[k].b - dist[course[k].p][<span class="number">1</span>] - dist[<span class="number">1</span>][course[j].p], <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (course[j].b + dist[course[j].p][<span class="number">1</span>] &lt;= t &amp;&amp; (t - course[j].b - dist[course[j].p][<span class="number">1</span>]) + restT + rest[i - <span class="number">1</span>][k] &gt;= s) &#123;</span><br><span class="line">                        dp[i][course[j].p] = <span class="built_in">max</span>(dp[i][course[j].p], dp[i - <span class="number">1</span>][course[k].p] + <span class="number">1</span>);</span><br><span class="line">                        rest[i][j] = <span class="built_in">min</span>(s, <span class="built_in">max</span>(rest[i][j], rest[i - <span class="number">1</span>][k] + restT));</span><br><span class="line">                        ans = <span class="built_in">max</span>(ans, dp[i][course[j].p]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对拍代码，生成的不是一张图而是一棵树，没有判断过不是树的情况</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> random(a, b) ((a)+rand()%((b)-(a)+1))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dsu[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> mapp[<span class="number">10000005</span>];</span><br><span class="line"><span class="type">bool</span> st[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>,ios::trunc)</span></span>;</span><br><span class="line">    <span class="comment">//ofstream fout(&quot;input.txt&quot;,ios::app);</span></span><br><span class="line">    <span class="comment">//fout.seekp( 0, ios::end);</span></span><br><span class="line">    <span class="type">int</span> q = <span class="built_in">random</span>(<span class="number">1</span>,n<span class="number">-1</span>),t = <span class="built_in">random</span>(<span class="number">3</span>,<span class="number">10004</span>);</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">random</span>(<span class="number">0</span>,t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">2</span>; --i) &#123;</span><br><span class="line">        dsu[i] = <span class="built_in">random</span>(<span class="number">1</span>, i - <span class="number">1</span>);<span class="comment">//生成一颗以1为根节点的树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) mapp[i] = i;</span><br><span class="line">    <span class="comment">//打印树，必要可以随机边权</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; n<span class="number">-1</span>&lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;q&lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;t&lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;s&lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;endl;</span><br><span class="line">    fout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; n<span class="number">-1</span>&lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;q&lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;t&lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;s&lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="built_in">random</span>(<span class="number">1</span>,<span class="number">104</span>);</span><br><span class="line">        cout &lt;&lt; mapp[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mapp[dsu[i]] &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;temp &lt;&lt;endl;</span><br><span class="line">        fout &lt;&lt; mapp[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mapp[dsu[i]] &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;temp&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">random</span>(<span class="number">2</span>,n);</span><br><span class="line">        <span class="keyword">while</span>(st[p])p = <span class="built_in">random</span>(<span class="number">2</span>,n);</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">random</span>(<span class="number">1</span>,t<span class="number">-2</span>);</span><br><span class="line">        <span class="type">int</span> b = <span class="built_in">random</span>(a+<span class="number">1</span>,t<span class="number">-1</span>);</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">        fout&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    fout.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_dataset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">random</span>(<span class="number">2</span>, <span class="number">400</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">build</span>(n);</span><br><span class="line">    <span class="comment">//::getchar();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">create_dataset</span>();</span><br><span class="line">    <span class="comment">//system(&quot;standDP.exe &lt; input.txt &gt; stand.txt&quot;);</span></span><br><span class="line">    <span class="comment">//system(&quot;myDP.exe &lt; input.txt &gt; my.txt&quot;);</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;stand.exe &lt; input.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;my.exe &lt; input.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">system</span>(<span class="string">&quot;fc stand.txt my.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> tot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i ++ ) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;正在运行第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;个数据&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">work</span>())&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;出错了\n&quot;</span>;</span><br><span class="line">            <span class="built_in">getchar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="comment">//work(); </span></span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">512</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题算不上太难，但因为实现细节有很多，算上Floyd一共做了3次dp，补题的时候包括写对拍程序一共做了两个晚上，每次对拍都会出现不少没有考虑到的情况，第一次的时候没有考虑到存在中途回去睡觉可以是最优解的情况，之后的几次都是在代码的细节上出错，比如<code>dp[i][course[j].p]</code>写成<code>dp[i][j]</code>等，而且是在有clion的静态代码分析的情况下写了这么久，比赛时devc++没有分析和代码补全功能，所以在那种环境下更有可能没处理好拿好几次罚时。<br><a name="zkicg"></a></p><h1 id="G-Puzzle-Kusabi"><a href="#G-Puzzle-Kusabi" class="headerlink" title="G. Puzzle: Kusabi"></a>G. Puzzle: Kusabi</h1><p><img src="/2023/08/19/20thZJCPC/PuzzleKusabi1.png" alt="PuzzleKusabi1"><br><img src="/2023/08/19/20thZJCPC/PuzzleKusabi.png" alt="PuzzleKusabi"><br></p><p><img src="/2023/08/19/20thZJCPC/PuzzleKusabi2.png" alt="PuzzleKusabi2"></p><p>Grammy是个拼图高手。今天，她正在玩“Kusabi”拼图的变体。在这个变体中，有一棵有根的树，上面有一些汉字。树的根是顶点1，没有标记。有标记的顶点可以有“长”、“短”或“同”的符号。其目标是将所有标记的顶点连接成对，以便:<br>每个标记顶点通过标记它们之间的最短路径上的每条边连接到另一个标记顶点<br>字符“长”的顶点与根之间的距离必须比对应点到根的距离长。<br>字符“短”的顶点与根之间的距离必须比对应点到根的距离短。<br>字符“同”的顶点与根之间的距离必须与对应点到根的距离相同。<br>树上的每一条边最多只能标记一次。<br>左图展示了一个只有条件的可行谜题，右图展示了一个可行的解题方法。<br>Grammy当然知道如何解决这个难题，但她决定给你一个小测验。请解开这个谜题。<br>输入：<br>第一行包含一个整数n(1<n<10^5)，表示树上的顶点数。<br>接下来的n-1行中的每一行都包含两个整数i，$p_i$和字符串$t_i(t_i\in \left \{ chang,duan,tong,- \right \} )$表示在$p_i$和i之间有一条边，以及顶点的类型I是$t_i$”_”表示未标记顶点i)。保证i是按递增顺序给出的。还保证至少有一个标记的顶点。<br>输出：<br>如果解决方案不存在，则在单行上输出“NO”<br>否则，在第一行输出“YES”，然后输出几行，每行包含两个整数Ui，Vi，表示解决方案中的一对连接顶点。如果有多个解，输出任意一个。<br>已通过此<a href="https://qoj.ac/contest/1221/problem/6396">oj</a>的评测<br>2023.08.22</n<10^5)，表示树上的顶点数。<br></p><p>贪心题：<br>1.显然总的标记为Tong的数量必须为偶数，Chang和Duan数量一定相同<br>2.标记为Tong的一定和相同深度的配对，标记为Chang的深度为第i深的一定和深度为第i深的标记为Duan的配对，如果配不上则需要考虑第3条贪心策略是不是无解，证明：<br>$S_{Duan} = \left \{…i…j…  \right \} ,S_{Chang} = \left \{…i…j…  \right \} $<br>假设没有按照这个规则配对，则必有“Duan”的i和“Chang”的j配对（i小于j）,可以发现“Duan”的j号点所对应的“Chang”被占，“Duan”的j号点又不一定可以与小于j的“Chang”的点配对，也就是说选择变少了，如果“Duan”的j号位的深度大于“Chang”的点中的j-1号位，那么就无法配对，最优性不如原先的假设，所以按照之前的排法是最优的。<br>3.对于一棵子树，最多只能留出一个点无法与子树内的其他点配对，去和别的子树上的点去配对，否则无解，这个也是显然的，因为要去到别的子树的最短路，有一条边是必须要经过的：子树的根节点到这颗子树的父亲节点的这条边，因为每条边只能经过一次，所以最多只能保留一个结点；还有一种可能无解是考虑当前子树的剩下那个点不是给“Tong”节点并且“Tong”的个数是奇数，那么一定无解<br>4.保留的一个结点的选择：<br>对于“Chang”和“Duan”这种节点有剩的：“Chang”结点剩最长的，因为这样可以选择的“Duan”结点就会最多，“Duan”也是同理，应该剩最短的<br>对于“Tong”这种结点有剩的：保留的结点只要选择不能配对的就可以，对深度没有要求，因为不管怎样都一定要和深度一样的配对，实现方法很简单，对所有没有配对的“Tong”结点小到大排序，排完之后两两配对，如果剩下最后一个配不上或者两两配对时深度不一样就将这个点存为剩下的点，注意无解的情况：考虑这棵树最后是不是还保留了一个“Tong”结点，如果是，那么也是无解的<br><img src="/2023/08/19/20thZJCPC/PuzzleKusabi3.png" alt="PuzzleKusabi3" style="zoom:27%;"><img src="/2023/08/19/20thZJCPC/PuzzleKusabi4.png" alt="PuzzleKusabi4" style="zoom:25%;">红点表示“Tong”蓝点表示不是“Tong”的标记点，第一张图表明第一种无解情况，第二张表明第二种无解情况，注意并不需要特地判断当前子树是不是存在两个及以上的无法配对的情况，证明需要根据奇偶性分四类讨论：<br>1.假设当前子树剩的是偶数个未配对的“Tong”结点，并且根节点的父节点除当前子树以外所包含的“Tong”结点个数是奇数，那么总共加起来一定是奇数，一定会留下一个交给其他子树配对，参考第二张图去掉左上那个节点的情况；<br>2.假设当前子树剩的是偶数个未配对的“Tong”结点，并且根节点的父节点除当前子树以外所包含的“Tong”结点个数是偶数，那么因为当前子树会尝试和其他不是该子树上的“Tong”节点配对，不管怎么配对于根节点的父节点来说都是配不完的，一定会留下一个交给其他子树配对；<br>3.假设当前子树剩的是奇数个未配对的“Tong”结点，并且根节点的父节点除当前子树以外所包含的“Tong”结点个数是奇数，那么如果配的上就可以配成合法情况（剩0个），如果配不上也会剩下偶数个，也就变成了第一第二种情况<br>4.假设当前子树剩的是奇数个未配对的“Tong”结点，并且根节点的父节点除当前子树以外所包含的“Tong”结点个数是偶数，同第一种情况，那么总共加起来一定是奇数，一定会留下一个交给其他子树配对；<br>所以观察无解的情况都是会剩下一个和其他子树上的节点配对，所以可以有由叶子结点归纳，一步一步扩大子树的大小直到变成一整棵树都是这样的情况，由于到一整棵树还是会剩一个，这种情况就是第二个无解情况，所以不需要考虑<br>5.这种贪心决策的路径一定不会重叠，证明用类似树形dp的思想，可以从最原始的情况一步步归纳：<br>最底层：当前只有叶子结点时，显然不用考虑，<br>往上一层：将所有同一个父结点的叶子结点连接与父结点组成子树，那么就算是前面讨论的有剩余的未配对结点，那也是最多选出一个通过父结点和其他子树相连，也就相当于是父结点存在一个标记为“Chang”“Duan”“Tong”中的任意一个，他的儿子结点因为已经配对完就不用考虑，所以不会重叠<br>归纳：对父结点和它对应的祖先组成子树，这个子树显然也可以看成第二层的情况，也不会出现重叠<br>所以整个情况合起来路径不会重叠,因此这种贪心策略是正确的<br>代码的实现：<br><code>d[u]</code>数组：存储当前结点对应的深度<br><code>ver[u]</code>数组：存储当前结点对应的种类，0表示不是特殊点，1-3表示“Duan”“Chang”“Tong”，三种状态<br><code>remain[u]</code>数组：存储当前结点的儿子们有无剩余的未配对的结点，数值同ver数组<br><code>num[u][i]</code>数组：存储当前u结点下包括自身的所有状态为i的结点个数<br><code>edge[N]</code>数组：邻接表存图<br><code>v[i]</code>vector数组：存储当前子树所有没有配对的结点，并可由size()统计个数<br><code>flag</code>变量：表示当前是否有无解的状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> d[N], ver[N], remain[N], num[N][<span class="number">4</span>], n;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">vector&lt;PII&gt; ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> par)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v[<span class="number">4</span>];</span><br><span class="line">    d[u] = d[par] + <span class="number">1</span>;<span class="comment">//计算深度</span></span><br><span class="line">    ++num[u][ver[u]];<span class="comment">//计算当前u结点的转态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) <span class="keyword">if</span> (ver[u] == i)v[i].<span class="built_in">push_back</span>(u);<span class="comment">//计算当前结点属于哪个状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ne: edge[u]) &#123;<span class="comment">//递归儿子结点</span></span><br><span class="line">        <span class="keyword">if</span> (ne == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(ne, u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (ver[remain[ne]] == i) v[i].<span class="built_in">push_back</span>(remain[ne]);<span class="comment">//存储儿子结点的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) num[u][i] += num[ne][i];<span class="comment">//存储所有i状态的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;<span class="comment">//判断有无解，无解就不用再继续运行</span></span><br><span class="line">    <span class="comment">//特判两种无解情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(num[u][<span class="number">1</span>] - num[u][<span class="number">2</span>]) &gt;= <span class="number">2</span>) &#123;<span class="comment">//如果当前“Chang”和“Duan”个数相差大于1就说明无解</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num[u][<span class="number">1</span>] != num[u][<span class="number">2</span>] &amp;&amp; (num[u][<span class="number">3</span>] &amp; <span class="number">1</span>)) &#123;<span class="comment">//如果当前子树的剩下那个点不是给“Tong”节点并且“Tong”的个数是奇数，那么一定无解</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(), v[i].<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> <span class="type">int</span> u, <span class="type">const</span> <span class="type">int</span> v) &#123; <span class="keyword">return</span> d[u] &lt; d[v]; &#125;);</span><br><span class="line">    <span class="type">int</span> v1 = (<span class="type">int</span>) v[<span class="number">1</span>].<span class="built_in">size</span>(), v2 = (<span class="type">int</span>) v[<span class="number">2</span>].<span class="built_in">size</span>(), v3 = (<span class="type">int</span>) v[<span class="number">3</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//分类遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v3; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == v3 - <span class="number">1</span>) &#123;</span><br><span class="line">            remain[u] = v[<span class="number">3</span>][i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d[v[<span class="number">3</span>][i]] != d[v[<span class="number">3</span>][i + <span class="number">1</span>]]) remain[u] = v[<span class="number">3</span>][i++];</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(v[<span class="number">3</span>][i], v[<span class="number">3</span>][i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num[u][<span class="number">1</span>] &gt; num[u][<span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="type">int</span> l = v1 - <span class="number">1</span>, r = v2 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> || r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &gt;= <span class="number">0</span> &amp;&amp; d[v[<span class="number">1</span>][l]] &lt; d[v[<span class="number">2</span>][r]]) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(v[<span class="number">1</span>][l--], v[<span class="number">2</span>][r--]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!remain[u] &amp;&amp; l &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                remain[u] = v[<span class="number">1</span>][l--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; v1 || r &lt; v2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; v1 &amp;&amp; r &lt; v2 &amp;&amp; d[v[<span class="number">1</span>][l]] &lt; d[v[<span class="number">2</span>][r]]) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(v[<span class="number">1</span>][l++], v[<span class="number">2</span>][r++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!remain[u] &amp;&amp; r &lt; v2) &#123;</span><br><span class="line">                remain[u] = v[<span class="number">2</span>][r++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; s;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(v), edge[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>)ver[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)ver[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;T&#x27;</span>)ver[u] = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!flag || remain[<span class="number">1</span>]) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;<span class="comment">//注意remain[1]里面有东西也是无解的</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it: ans)</span><br><span class="line">            cout &lt;&lt; it.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; it.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树上贪心问题，这题的贪心策略并不算好想，也融合了树的遍历，树形dp的思想，由于树这种结构天然的适合dp和递归，所以题目就算没有要用树形dp去解也要考虑是否可以利用这个特殊的结构去实现算法，这道题的坑点也很多，像没看到每条边只能经过一次这个条件就会误以为是很简单的一道贪心题，最后关于“Tong”结点的处理也不好想到，很难在短时间内验证正确性<br><a name="wQHBt"></a></p><h1 id="H-Puzzle-Tapa"><a href="#H-Puzzle-Tapa" class="headerlink" title="H. Puzzle: Tapa"></a><strong>H. Puzzle: Tapa</strong></h1><p><img src="/2023/08/19/20thZJCPC/PuzzleTapa1.png" alt="PuzzleTapa1"><br><img src="/2023/08/19/20thZJCPC/PuzzleTapa2.png" alt="PuzzleTapa2"></p><p>翻译：<br>Grammy是解谜大师，今天，她正在玩一个“Tapa”拼图的变体。在这个变体中，有 (2n − 1)×(2m−1)矩形网格上的n×m个线索。所有线索都位于单元格（i，j）上，其中i，j都很奇怪。每条线索都是一个等于或比周围单元格数小1的数字线索。具体来说，网格角落上的线索可以是2条或3条，网格边缘上的线索可以是4或5并且网格中心上的线索可以是7或8。目标是对一些格子进行遮光，例如即：<br>•所有线索单元格都未加阴影。<br>•每个线索单元格表示其周围连续阴影单元格的数量。<br>左上图显示了一个可能的5×5网格，只有线索，右上图显示了可能的解决谜题的方法，底部的图片显示了一个错误的谜题解决方案，因为阴影4周围的单元格是不连续的。<br>Grammy肯定知道如何解决这个难题，但她决定给你一个小测验。请解开这个谜题。<br>输入<br>第一行包含两个整数n，m（2≤n，m≤50），表示网格的大小。<br>接下来的2n−1行中的每一行都包含2m−1个字符，表示具有给定线索的网格。点（’.’）<br>表示没有线索的单元格，而数字表示单元格上的线索。它保证了<br>奇数行和奇数列的交叉点有一条线索，所有其他单元格都不包含任何线索。<br>输出 <br>如果解决方案不存在，则在单行上输出“NO”。<br>否则，在第一行输出“YES”，然后输出2n−1行，每行包含2m−1个字符，<br>表示谜题的答案。格式类似于输入网格，但您应该标记<br>用“#”对单元格进行着色。换句话说，输出中的点（’.’）表示一个没有线索的无阴影单元格，<br>（’#’）表示带阴影的单元格，数字表示单元格上的线索。<br>如果有多个解决方案，请输出任何一种解决方案。<br>已通过此<a href="https://qoj.ac/contest/1221/problem/6398">oj</a>的评测<br>2023.08.26<br>大致意思就是扫雷，数字表示周围连续的雷的数量，判断有无解，如果有解就输出任意一种，注意涂色的点必须是联通的。</p><p>这题的通过率低到离谱，是除了只有一队通过的C题以外最低的一题，原因可能是题目只说了每个线索单元格表示其周围连续阴影单元格的数量，没有说明要涂色的点必须是联通的，像</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">3.2</span><span class="number">.3</span></span><br><span class="line">.....</span><br><span class="line"><span class="number">5.7</span><span class="number">.5</span></span><br><span class="line">.....</span><br><span class="line"><span class="number">3.5</span><span class="number">.3</span></span><br><span class="line">output:</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p>如果理解为涂色点可以不联通只要最多的联通数量等于给的线索那么输出会是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span>#<span class="number">2</span>#<span class="number">3</span></span><br><span class="line">##.##</span><br><span class="line"><span class="number">5</span>#<span class="number">7</span>#<span class="number">5</span></span><br><span class="line">#####</span><br><span class="line"><span class="number">3.5</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><p>由于要求连续，所以有一个很重要的结论：<br>如果合法那么最外圈（除去数字的最外圈）一定全是’#’，原因很简单因为要求连续，像上面的例子给出的就是不合法的，只有最外圈全是’#’才能保证数字的最外圈每个阴影都是连续的。<br>正难则反，假设现在全部都是阴影，如果能去掉一些阴影来满足条件那么就是合法的。将这个想象成一张图，没有’#’的相邻两个数字，即这两个数字周围允许有空白（即不是3,5,8）就是存在一条边，相邻才会有一条边，并且一定不会存在一行像3.4.5.4.3这样隔一列的合法情况，那也就是说奇数行和偶数行可以被两两匹配，就很容易联想到跑一次二分图的最大匹配，一边的点集全是奇数行列，一边的点集全是偶数行列，如果做得到完全匹配那么就是一种合法情况。然后再结合上面的结论可以枚举出二分图的边集：如果都是在最外层的或者都是在里面的并且相邻那么这两个点之间就存在一条边，跑一遍匈牙利算法如果是完全匹配那么就是合法的。<br>需要注意的是二分图不一定的两个集合不是必须按照点来划分，这道题只要能够正确描述点与点之间的关系并且可以判断是不是完全匹配就可以。代码中是将点的集合重新分配一个编号，将这个编号与编号之间的关系作为一条边建二分图，而且因为是用编号映射点，所以：<br>1.下标是从0开始的，与正常的模板相比，数组的初始化一定要初始化成-1，如果没有初始化是0那么就是说明这个下标与第0个点匹配，这样就会出错，并且条件的判断也要从!=0变成!=-1<br>2.输出的时候要考虑映射关系<br>用邻接表存储编号的数组一定要开到1500左右，因为n和m最大都是50，两两组合有50*49/2，所以要开的足够大才不会re</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1505</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edge[N];</span><br><span class="line"><span class="type">int</span> n, m, v[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">vector&lt;PII&gt; vl, vr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    st[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y: edge[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[y] == <span class="number">-1</span> || (!st[v[y]] &amp;&amp; <span class="built_in">find</span>(v[y]))) &#123;</span><br><span class="line">            v[y] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">match</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">-1</span>, <span class="keyword">sizeof</span> v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i)) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">mat</span><span class="params">(<span class="number">2</span> * n - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s: mat) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c: s)</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) c = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="type">char</span> t = mat[<span class="number">2</span> * i][<span class="number">2</span> * j];</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="string">&#x27;3&#x27;</span> || t == <span class="string">&#x27;5&#x27;</span> || t == <span class="string">&#x27;8&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((i + j) % <span class="number">2</span> == <span class="number">0</span>)vl.<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">            <span class="keyword">else</span> vr.<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> v1 = (<span class="type">int</span>) vl.<span class="built_in">size</span>(), v2 = (<span class="type">int</span>) vr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (v1 != v2) <span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>, <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [x1, y1] = vl[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v2; ++j) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x2, y2] = vr[j];</span><br><span class="line">            <span class="type">int</span> dist = <span class="built_in">abs</span>(x1 - x2) + <span class="built_in">abs</span>(y1 - y2);</span><br><span class="line">            <span class="type">bool</span> isBoundary = (x1 == <span class="number">0</span> &amp;&amp; x2 == <span class="number">0</span>) || (x1 == n - <span class="number">1</span> &amp;&amp; x2 == n - <span class="number">1</span>) ||</span><br><span class="line">                              (y1 == <span class="number">0</span> &amp;&amp; y2 == <span class="number">0</span>) || (y1 == m - <span class="number">1</span> &amp;&amp; y2 == m - <span class="number">1</span>);</span><br><span class="line">            <span class="type">bool</span> isIntern = mat[<span class="number">2</span> * x1][<span class="number">2</span> * y1] == <span class="string">&#x27;7&#x27;</span> &amp;&amp; mat[<span class="number">2</span> * x2][<span class="number">2</span> * y2] == <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (dist == <span class="number">1</span> &amp;&amp; (isBoundary || isIntern)) edge[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">match</span>(v1) != v1) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v2; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x2, y2] = vr[i];</span><br><span class="line">            <span class="type">int</span> j = v[i];</span><br><span class="line">            <span class="keyword">auto</span> [x1, y1] = vl[j];</span><br><span class="line">            mat[x1 + x2][y1 + y2] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s: mat) cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct MBM &#123;</span></span><br><span class="line"><span class="comment">    int L;</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; match, seen;</span></span><br><span class="line"><span class="comment">    vector&lt;vector&lt;int&gt; &gt; g;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    MBM(int L, int R) : L(L), match(R), seen(R), g(L) &#123;&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    void add_edge(int l, int r) &#123; g[l].push_back(r); &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    bool dfs(int u) &#123;</span></span><br><span class="line"><span class="comment">        return any_of(g[u].begin(), g[u].end(), [&amp;](int v) &#123;</span></span><br><span class="line"><span class="comment">            if (seen[v]++ == 0 &amp;&amp; (match[v] == -1 || dfs(match[v]))) &#123;</span></span><br><span class="line"><span class="comment">                match[v] = u;</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int max_matching() &#123;</span></span><br><span class="line"><span class="comment">        int ans = 0;</span></span><br><span class="line"><span class="comment">        fill(match.begin(), match.end(), -1);</span></span><br><span class="line"><span class="comment">        for (int u = 0; u &lt; L; ++u) &#123;</span></span><br><span class="line"><span class="comment">            fill(seen.begin(), seen.end(), 0); </span></span><br><span class="line"><span class="comment">            ans += dfs(u);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以像注释里的代码一样定义一个结构体，将所有的初始化，数组长度在结构体初始化的时候申请对应的大小就可以保证空间也不会被浪费。<br>其实还是很套路的一道题，如果题目做多了就会发现棋盘矩阵其实天生的适合划分成两个点集，这些题基本上程序的框架是一样的，的比如像这样黑白染色：<br><img src="/2023/08/19/20thZJCPC/PuzzleTapa3.png" alt="PuzzleTapa3" style="zoom: 50%;"><br>行号加列号是偶数就染黑，奇数就染白，就可以变成黑格是一类点，白格是一类点，黑白相邻格子之间连上一条边，就可以解决这道棋盘覆盖问题：<br><img src="/2023/08/19/20thZJCPC/PuzzleTapa4.png" alt="PuzzleTapa4"></p><p><a name="IOCys"></a></p><h1 id="I-Equation-Discovering"><a href="#I-Equation-Discovering" class="headerlink" title="I. Equation Discovering"></a>I. Equation Discovering</h1><p><img src="/2023/08/19/20thZJCPC/IEquationDiscovering1.png" alt="IEquationDiscovering1"><br><img src="/2023/08/19/20thZJCPC/IEquationDiscovering2.png" alt="IEquationDiscovering2"></p><p>翻译：</p><p>Mika教授是一位计算机科学研究人员，他提出了以下问题:给定n对(x,y)，其中1≤n≤20,我们如何找到适用于所有对的控制方程y=f(x)?换句话说，他试图确定一个方程，该方程涉及二元运算符(+，-，x，÷)、一元运算符(sin，cos)、符号x和适用于所有给定对的括号，例如y=x<em>x÷sin(x)或y=x</em>(x+x÷x)。</p><p>为了生成所有有效的方程，我们定义了一个上下文无关语法，如下所示:</p><p>1.起始符号为S。</p><p>2.S→S+S | S-S</p><p>3.S→SxS | S+S</p><p>4.S→sin(S) | cos(S)</p><p>5.S→(S) l x</p><p>然而，为了防止过拟合，我们将方程的复杂度限制为小于或等于9，其中复杂度定义为二元运算符(+，-，x，÷)数量的两倍加上方程中一元运算符(sin，cos)数量的一倍。例如，方程x+(x+x<em>x)的复杂度为6，而x</em>sin()的复杂程度为3。只有复杂度小于或等于9的方程才会被认为是正确的。</p><p>输入</p><p>第一行包含一个整数n(1≤n≤20)，表示要拟合的(x，y)对的数量。以下n行，每行两个实数r，y(zl，&lt;103)，小数点后正好有六位数字，表示(x，y)对。</p><p>x的值保证是准确的，我们使用一些有效的方程来生成y的值，然后将其四舍五入到六位数。</p><p>输出</p><p>输出只有一行表达式f，由’+’、-’、*’(对于x)、/’(对于÷)、’sin’、’cos’、’x’、(’和)’组成。</p><p>如果您的答案满足以下条件，则视为正确:</p><p>1.表达式f是使用前面描述的上下文无关语法生成的，并且根据该语法是有效的。</p><p>2表达式f的复杂度不超过9，并且长度不超过1000个字符。</p><p>3.对于每个(z，y)对，f(z)和g之间的绝对或相对误差不大于10</p><p>3。即≤10-3</p><p>4.在计算除法运算时，被除数的绝对值必须不小于0.01。</p><p>留坑待填</p><p><a name="xiJVw"></a></p><h1 id="赛后总结"><a href="#赛后总结" class="headerlink" title="赛后总结"></a>赛后总结</h1><p>…没去颁奖现场也没找到获奖率的通知，文件里面只写了这些：<br>本届竞赛按本科组、专科组分别进行评奖和设奖，根据每队答题数量及解题时长进行排名。为与国际竞赛获奖名称接轨，特设置奖项如下：<br>颁发金、银、铜奖（牌）：若干名；<br>颁发最佳女队奖（牌）：1名；要求获等级奖的参赛队中，应有3名女生组队，则有资格参评此奖项；<br>颁发顽强拼搏奖（牌）:1名；<br>要求竞赛中表现特别顽强的队伍，如提交某题次数最多、在比赛结束前最后成功通过一题的队伍等，都有可能获此奖项；<br>颁发高校优秀组织奖（牌）：若干名。<br>上述获奖比例按浙江省大学生科技竞赛委员会相关规定执行，奖牌颁发给参赛高校，获奖证书颁发给获奖师生本人。<br>如果按2014年的评奖规则：<br>本届竞赛按本科组、大专组分别进行评奖和设奖，根据每队解答竞赛题目的数目多少及解题程序算式所需时间长短进行排名。评定以下奖项：<br>特等奖：1队（可空缺），颁发奖杯、证书；<br>一等奖：8%参赛队，颁发金牌、证书；<br>二等奖：15%参赛队，颁发银牌、证书；<br>三等奖：25%参赛队，颁发铜牌、证书；<br>特别奖：最佳女队奖（获等级奖的参赛队中，应有3名女生组队，则有资格参评此奖项）、顽强拼搏奖（竞赛中表现特别顽强的队伍，如提交某题次数最多、在比赛结束前最后成功通过一题的队伍等，都有可能获此奖项）、最佳组织奖（颁发给积极参与竞赛的学校）若干，颁发奖牌。<br>优胜奖：未获等级奖和特别奖，但在比赛中至少成功解答一题的队。无证书。<br>成功参赛奖：未获上述奖项的参赛。无证书。</p><p>比赛时做了AEFM四道题，按照这个规则来看，如果要拿铜必须要做得快，银牌需要做出K题，做出G题稳银，再做出H题稳金。<br>这次打铁也属于是意料之中了，队友之间的配合明显不算好，可以看出做简单题花时间检查比直接交上去赌对而错了罚时的收益高，但是在做F题的时候仍然出现了一次罚时，这是因为我没有看清题目每次查询都会返回绝对值而不是差值，导致第一次在设计程序的时候总体思路就错了，最后我拍了几组错误的输出发现没错就提交罚时一次，在发现题目看错了又重新设计程序，就因为一个绝对值导致思路和之前的完全不一样，算上罚时总共浪费了一个多小时，导致来不及细想K题最后只解出了四道题，如果以现在补题时的能力来看，前面做的快，留出充足的时间是有可能写五道题拿银。但是金牌的话G题的难度过大不大可能在有限的时间内想出完全正确的贪心，H题更不可能联想到建模成二分图跑最大匹配(其实棋盘建模成二分图是比较套路的做法)<br>总的来说大一没有拿牌还是能力和比赛经验不够，练得太少做不到将想法写成程序，在补题的时候还只是第一次做这种dp，比赛时就更弱了，在写M题的时候写个sort的比较函数都要写半天，最后是一个队友用STL里面的pair加优先队列做出来的。并且英语也很重要，平时英文题也没有练过，比赛时三个人在做题的时候原本的想法是三个人分开看题，结果甚至查英文字典都看不懂题目，都是看哪题通过率高的没写就三个人一起翻译题目，这样做明显降低了读题速度，一直到比赛结束都没看K题以后的题目。并且F题题面都加粗了绝对值但是读完还是忘了…其实在英语题练多了后去打比赛，可以在做完签到题后英语好的两个人读题，一个人从前往后一个人从后往前，另一个在devc++上先打好缺省源顺便看看榜单里面哪一题做的人多，这样可以节省不少时间。<br><a name="QJpMQ"></a></p><h2 id="比赛的排名规则"><a href="#比赛的排名规则" class="headerlink" title="比赛的排名规则"></a>比赛的排名规则</h2><p>首先按解题数量排序，每道题权值一样，解题数量越多的排在前面，题数一样多的队伍按时间排（表中的score），时间的具体计算是：每道题第一次ac的时间（单位为分钟）的总和加上已ac的题目中先前提交wa的次数<em>20。像我们队解出AEMF的时间分别是比赛开始后的10，49，95，210，其中F题罚时一次，那么总时间就是10+49+95+210+20</em>1 = 384,所以四题里用时比我们长的都排在后面<br><a name="yjSUR"></a></p><h2 id="终榜"><a href="#终榜" class="headerlink" title="终榜"></a><a href="https://acm.hznu.edu.cn/domjudge/scoreboard/">终榜</a></h2>]]></content>
      
      
      <categories>
          
          <category> XCPC省赛/邀请赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浙江 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法大赛2023-村庄</title>
      <link href="/2023/04/18/%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B2023-%E6%9D%91%E5%BA%84/"/>
      <url>/2023/04/18/%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B2023-%E6%9D%91%E5%BA%84/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/01/XQNDcgyW9wPuRmj.png" alt="image _4_.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>数据范围：<br>2 &lt;= N &lt;= 10^5<br>1 &lt;= K &lt;= M &lt;= 10^5<br>1 &lt;= ai &lt; bi &lt;= N<br>所有的村庄组合(ai, bi) 各不相同。<br><img src="https://s2.loli.net/2023/10/01/cXa2pktlq6SOAb3.png" alt="image.png" style="zoom:50%;"><br><img src="https://s2.loli.net/2023/10/01/Cbm4r62qlzaNpXW.png" alt="image _5_.png" style="zoom:50%;"><br>将村庄看成点，桥看成边，显然一开始给你的一定是所有的点都可以通过某条边直接或者间接相连，那么村庄的组合就是$C_{n}^{2} = \frac{n*(n-1)}{2} $，即选出两个村庄进行组合。去除一些边后问你毁了多少个组合。所以思路就是求连通块，计算每个连通块有多少个点，用组合数的公式进行计算还剩下多少个点，计算之后再减去总的村庄组合。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">&#125; e[M];</span><br><span class="line"></span><br><span class="line">ll n, m, k, par[M], cnt, a[M];</span><br><span class="line">vector&lt;ll&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (par[x] != x)par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">    <span class="keyword">return</span> par[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        ll a = e[i].a, b = e[i].b;</span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b) par[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ll t = <span class="built_in">find</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (t != i)a[t]++;</span><br><span class="line">        <span class="comment">//如果父亲不是自己，那么和别人肯定有一条边联通，累加这个父节点连接的结点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">0</span>)v.<span class="built_in">push_back</span>(a[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//如果该节点连了其他结点，那么就加上他自己压入vector里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t:v)&#123;<span class="comment">//遍历所有的连通块</span></span><br><span class="line">        res += t*(t<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll all = n*(n<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;all-res;<span class="comment">//总的数量减去连通块的数量就是减少的村庄组合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        ll ai, bi;</span><br><span class="line">        cin &gt;&gt; ai &gt;&gt; bi;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= k)<span class="keyword">continue</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        e[cnt].a = ai;</span><br><span class="line">        e[cnt].b = bi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)par[i] = i;</span><br><span class="line">    <span class="built_in">process</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 小比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023算法大赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>E-梅莉的市场经济学</title>
      <link href="/2022/12/29/E-%E6%A2%85%E8%8E%89%E7%9A%84%E5%B8%82%E5%9C%BA%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
      <url>/2022/12/29/E-%E6%A2%85%E8%8E%89%E7%9A%84%E5%B8%82%E5%9C%BA%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p><a name="9784768a"></a></p><h1 id="传智杯-5-初赛-E-梅莉的市场经济学"><a href="#传智杯-5-初赛-E-梅莉的市场经济学" class="headerlink" title="[传智杯 #5 初赛] E-梅莉的市场经济学"></a>[传智杯 #5 初赛] E-梅莉的市场经济学</h1><p>题目背景<br>梅莉这个学期选修了经济学。但是主修心理学的她实在不擅长经济领域的分析，为此她时常抱怨自己学不会，想退课。<br>但是如果现在退掉的话这学期的学分就不够啦，因此她根据“梦中”的经历，“胡诌”了一个简单到不现实的市场模型，并依据这个模型编起了 essay。为了方便地编出图表，她需要写一个程序来查询每个时刻的市场贸易差。<br>题目描述<br>市场每一天的贸易差可以视为一个有周期性规律的数列a:$\color{red}[0],\color{blue}[0, 1, 0, -1, 0],\color{red}[0, 1, 2, 1, 0, -1, -2, -1, 0], \color{blue}[0, 1, 2,3, 2, 1, 0, -1, -2, -3, -2, -1, 0]\dots$。具体而言，<em>a</em> 可以被分为无穷段，第 <em>i</em> 段的内容为 $\{0, 1,\cdots,i,i-1, \cdots,0, -1, \cdots,-i, -i+1,\cdots 0\}$如下图所示，是将a数列内的前一些点绘制在坐标轴上的情况：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/wrl89jka.png#id=sOQ4a&amp;originHeight=455&amp;originWidth=869&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt><br>现在梅莉对市场发起了 q次询问，每次她会给定一个 k，希望求出 $a_k$是多少。<br>输入格式</p><ul><li>第一行有一个正整数 q，表示询问次数。</li><li>接下来 q 行，每行一个正整数 k，描述每次询问。</li></ul><p>输出格式</p><ul><li>输出共 q行。对于每次询问，输出对应的结果。</li></ul><p>样例 #1<br>样例输入 #1<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">100</span><br><span class="line">1000</span><br><span class="line">10000</span><br><span class="line">100000</span><br><span class="line">1000000</span><br><span class="line">10000000</span><br><span class="line">100000000</span><br></pre></td></tr></table></figure><br>样例输出 #1<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">-9</span><br><span class="line">-11</span><br><span class="line">-128</span><br><span class="line">406</span><br><span class="line">1629</span><br><span class="line">5154</span><br></pre></td></tr></table></figure><br>提示<br>对于所有数据，有$1 \leq q \leq 10^5，1 \leq k \leq 4\times 10^{18}$。<br><a name="xd80F"></a></p><h1 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h1><p>对于这个数据规模，显然询问的次数是没有办法优化的，这就表明考虑最多的循环的次数至少有10^5。那么就算每次询问使用常数复杂度的方式也会超时，因为这个是一个一个区间的形式，每一个区间的长度是按照规律递增的，那么就可以考虑在最大和最小的区间内二分找。算上查询的O(n)复杂度为O(nlogn)左右，可以通过这个数据范围。<br>比较头疼的是这个规律以及他的上限应该定在哪一个位置比较合适。</p><div class="table-container"><table><thead><tr><th>峰值</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>长度</td><td>1</td><td>6</td><td>15</td><td>28</td><td>45</td></tr><tr><td>规律1</td><td>1</td><td>6</td><td>6+9</td><td>6+9+13</td><td>6+9+13+17</td></tr><tr><td>规律2</td><td>1</td><td>1+5</td><td>1+5+9</td><td>1+5+9+13</td><td>1+5+9+13+17</td></tr><tr><td>规律3<br>（等差求和，an = 1+4<em>n=4n+1<br>=&gt;<br>sn=(5+4n+1)</em>n/2+1=2n^2+3n+1）<br></td><td>1</td><td>2<em>1+3</em>1+1</td><td>2<em>4+3</em>2+1</td><td>2<em>9+3</em>3+1</td><td>2<em>16+3</em>4+1</td></tr></tbody></table></div><p>从表中不难得出规律：2n^2+3<em>n+1,但是在比赛的时候由于没有画表格，所以就只看出了递推关系：an-an-1 =4n+1,然后利用累加法（累加的时候一定要注意初始条件和结束条件以及一共累加了多少次），最后得出2 </em> (2 + n) * (n - 1) + n + 5;这个式子的右边最大要特别的考虑，因为</p><script type="math/tex; mode=display">1 \leq k \leq 4\times 10^{18}</script><p>因为是这个数据，可以计算出二分右边界要开到1.5*1e9左右，不然会出现死循环过不了最后几个点：</p><p>define MAX 1000000000时的情况:</p><p><img src="https://s2.loli.net/2023/09/25/bQJwV5OrTKteLAU.png" alt="image _2_.png"></p><p>但是MAX改到1500000000时就能ac</p><p>ac代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1500000000</span></span><br><span class="line"></span><br><span class="line">ll q, k, lb, n;</span><br><span class="line">ll pren;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getnum</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * (<span class="number">2</span> + n) * (n - <span class="number">1</span>) + n + <span class="number">5</span>;<span class="comment">//其实也可以写这个：2*n*n+3*n+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分找区间</span></span><br><span class="line"><span class="function">ll <span class="title">getindex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">lb = <span class="number">0</span>;</span><br><span class="line">ll ub = MAX;</span><br><span class="line">ll ubnum = <span class="built_in">getnum</span>(ub);</span><br><span class="line">ll lbnum = <span class="built_in">getnum</span>(lb);</span><br><span class="line"><span class="keyword">while</span> (!(lbnum &lt;= k &amp;&amp; k &lt;= <span class="built_in">getnum</span>(lb + <span class="number">1</span>))) &#123;<span class="comment">//如果二分右边界不对的话这里就会死循环</span></span><br><span class="line">ll mid = (lb + ub) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getnum</span>(mid) &gt;= k) &#123;</span><br><span class="line">ub = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lb = mid;</span><br><span class="line">&#125;</span><br><span class="line">ubnum = <span class="built_in">getnum</span>(ub);</span><br><span class="line">lbnum = <span class="built_in">getnum</span>(lb);</span><br><span class="line">&#125;</span><br><span class="line">pren = <span class="built_in">getnum</span>(lb);</span><br><span class="line">n = <span class="built_in">getnum</span>(lb + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> lb + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="comment">//包括首尾的话每个区间一共有6个特殊点</span></span><br><span class="line">ll top = <span class="built_in">getindex</span>();</span><br><span class="line">ll bottom = -top;</span><br><span class="line">ll zeroindex2 = (pren + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">ll zeroindex1 = pren + <span class="number">1</span>;</span><br><span class="line">ll topindex = (zeroindex1 + zeroindex2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">ll bottomindex = (zeroindex2 + n) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//k位于不同特殊点之间都有不一样的结果</span></span><br><span class="line"><span class="keyword">if</span> (zeroindex1 &lt; k &amp;&amp; k &lt; topindex) &#123;</span><br><span class="line">ans = k - zeroindex1;</span><br><span class="line">cout &lt;&lt; ans  &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (topindex &lt;= k &amp;&amp; k &lt; zeroindex2) &#123;</span><br><span class="line">ans = top - (k - topindex);</span><br><span class="line">cout &lt;&lt; ans  &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (zeroindex2 &lt; k &amp;&amp; k &lt; bottomindex) &#123;</span><br><span class="line">ans =  zeroindex2 - k;</span><br><span class="line">cout &lt;&lt;  ans &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bottomindex &lt;= k &amp;&amp; k &lt; n) &#123;</span><br><span class="line">ans = bottom + (k - bottomindex);</span><br><span class="line">cout &lt;&lt; ans  &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这道题目的难点有三：求通项公式，二分的右边界以及一堆条件分支。<br>求通项因为当时没有想到用表格的形式找规律，就只找到了递推关系式，并且在累加的时候没有考虑好累加的次数导致算错了好几次，如果用表格的话或许就能减少很多时间的浪费。<br>递增序列很容易想到二分，但是这道题要特别考虑右边界，这里也花了不少时间。<br>一堆条件分支删删改改了好久，如果在纸上先分析也可以省下调试的时间。</p>]]></content>
      
      
      <categories>
          
          <category> 小比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022传智杯 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
